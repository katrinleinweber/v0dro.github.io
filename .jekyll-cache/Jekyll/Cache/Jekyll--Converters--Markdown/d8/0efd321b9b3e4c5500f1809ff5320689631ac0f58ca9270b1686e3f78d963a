I"š=<p>ScaLAPACK is the distributed version of LAPACK. The interface of most functions is 
almost similar. However, not much documentation and example code is available for 
scalapack in C++, which is why Iâ€™m writing this blog post to document my learnings.
Hopefully this will be useful for others too. The full source code can be found in
<a href="https://github.com/v0dro/scalapack-lu">this repo</a>. This program calls fortran routines
from CPP and therefore all array storage is column major.</p>

<p>This post is part of a larger post where Iâ€™ve implemented and benchmarked synchronous 
and asynchronous block LU deocomposition. That post can be found <a href="URL">here</a>. <a href="https://software.intel.com/en-us/mkl-developer-reference-c-p-getrf">This</a> intel resource is also helpful for this purpose.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#scalapack-protips">Scalapack protips</a>
    <ul>
      <li><a href="#errors">Errors</a></li>
      <li><a href="#linking-and-compiling">Linking and compiling</a></li>
    </ul>
  </li>
  <li><a href="#function-usage-protips">Function usage protips</a>
    <ul>
      <li><a href="#storage-in-the-arrays">Storage in the arrays</a></li>
    </ul>
  </li>
  <li><a href="#source-code">Source code</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="scalapack-protips">Scalapack protips</h1>

<p>There are certain terminologies that are pretty widely used in scalapack. They are as follows:</p>
<ul>
  <li>Scalapack docs assume that a matrix of <code>K</code> rows or columns is distributed over a process grid of dimensions p x q.</li>
  <li><code>LOCr</code> :: <code>LOCr(K)</code> denotes the number of elements of K that a process would receive if K were
distributed over the p processes of its process column.</li>
  <li><code>LOCc</code> :: <code>LOCc(K)</code> denotes the number of elements of K that a process would receive if K were 
distributed over the q processes of its process row.</li>
  <li>The values of <code>LOCc</code> and <code>LOCr</code> can be determined using a call to the <code>numroc</code> function.</li>
  <li><strong>IMPORTANT</strong> :: None of these functions have C interfaces the way there are for LAPACK via LAPACKE. 
Therefore, you must take care to pass all variables by address, not by value and store all your data 
in FORTRAN-style, i.e. column-major format not row-major.</li>
</ul>

<h2 id="getting-process-block-size-with-numroc">Getting process block size with numroc</h2>

<p>The <code>numroc</code> function is useful in almost every scalapack function. It computes the number of rows 
and columns of a distributed matrix owned by the process (the return value). Hereâ€™s an explanation 
alongwith the prototype:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> numroc_(
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#777">// (global) the number of rows/cols in dist matrix</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#777">// (global) block size. size of blocks the distributed matrix is split into.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *iproc, <span style="color:#777">// (local input) coord of the process whose local array row is to be determined.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *srcproc, <span style="color:#777">// (global input) coord of the process that has the first row/col of distributed matrix.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nprocs <span style="color:#777">// (global input) total no. of processes over which the matrix is distributed.</span>
);
</pre></td>
</tr></table>
</div>

<h3 id="usage-of-numroc">Usage of numroc</h3>

<p>Pass the row or column number of the current matrix block in order to obtain the total
number of rows/columns of the full matrix that will be contained in the process. For example,
say you have a matrix of size <code>16384</code> that you want to split into blocks of <code>512</code> and distribute
them over 9 processes. This will lead to an uneven splitting and will therefore require careful
calculation of the number of elements.</p>

<p>The correct way to obtain the total elements that exist on each process would be as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> N = <span style="color:#00D">16384</span>, NB = <span style="color:#00D">512</span>;
<span style="color:#0a8;font-weight:bold">int</span> rsrc = <span style="color:#00D">0</span>, csrc = <span style="color:#00D">0</span>;
<span style="color:#0a8;font-weight:bold">int</span> nprow = <span style="color:#00D">3</span>, npcol = <span style="color:#00D">3</span>;

<span style="color:#0a8;font-weight:bold">int</span> np = numroc_(&amp;N, &amp;NB, &amp;myrow, &amp;rsrc, &amp;nprow);
<span style="color:#0a8;font-weight:bold">int</span> nc = numroc_(&amp;N, &amp;NB, &amp;mycol, &amp;csrc, &amp;npcol);

std::cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">ipr: </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> np: </span><span style="color:#710">&quot;</span></span> &lt;&lt; np &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> nc: </span><span style="color:#710">&quot;</span></span> &lt;&lt; nc &lt;&lt; std::endl;

<span style="color:#777">// ipr: 6 np: 5120 nc: 5632</span>
<span style="color:#777">// ipr: 5 np: 5632 nc: 5120</span>
<span style="color:#777">// ipr: 3 np: 5632 nc: 5632</span>
<span style="color:#777">// ipr: 7 np: 5120 nc: 5632</span>
<span style="color:#777">// ipr: 2 np: 5632 nc: 5120</span>
<span style="color:#777">// ipr: 4 np: 5632 nc: 5632</span>
<span style="color:#777">// ipr: 8 np: 5120 nc: 5120</span>
<span style="color:#777">// ipr: 0 np: 5632 nc: 5632</span>
<span style="color:#777">// ipr: 1 np: 5632 nc: 5632</span>
</pre></td>
</tr></table>
</div>

<h2 id="checking-where-an-element-exists-with-indxg2p">Checking where an element exists with indxg2p</h2>

<p>You can check which process a given global co-ordinate exists on using the <code>indxg2l_()</code> function.
This function returns the process number of the element. Usage example:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> l = <span style="color:#00D">513</span>, NB = <span style="color:#00D">512</span>, rsrc = <span style="color:#00D">0</span>;
<span style="color:#0a8;font-weight:bold">int</span> p = indxg2p_(&amp;l, &amp;NB, &amp;myrow, &amp;rsrc, &amp;nprocs);
</pre></td>
</tr></table>
</div>
<p>Docs: http://www.netlib.org/scalapack/explore-html/d6/d88/indxg2p_8f_source.html</p>

<h2 id="obtain-local-co-oridnates-using-indxg2l">Obtain local co-oridnates using indxg2l</h2>

<p>You can pass global co-ordinates along with process co-ordinates to the <code>indxg2l_()</code> function
in order to obtain the local co-ordinates of the data element. A sample usage is like so:</p>

<p>Docs: http://www.netlib.org/scalapack/explore-html/d9/de1/infog2l_8f_source.html</p>

<h2 id="errors">Errors</h2>

<p>Scalapack reports errors using the XERBLA error handler. Hereâ€™s some resources for this:</p>
<ul>
  <li><a href="http://www.netlib.org/scalapack/slug/node151.html#SECTION04751000000000000000">Invalid arguments and XERBLA.</a></li>
  <li><a href="http://www.netlib.org/scalapack/slug/node149.html#seccommonerrors">Common errors in calling ScaLAPACK routines.</a></li>
</ul>

<h2 id="linking-and-compiling">Linking and compiling</h2>

<p>If youâ€™re using an intel MKL distribution, use their <a href="https://software.intel.com/sites/products/mkl/mkl_link_line_advisor.htm">linker options tool</a> for knowing
exact link options.</p>

<p>Take care to link with the <code>_lp64</code> libraries since they treat integers as 32 bit and thatâ€™s what you want for scalapack. This link <a href="https://software.intel.com/en-us/forums/intel-math-kernel-library/topic/283403">offers some explanation</a>.</p>

<h1 id="function-usage-protips">Function usage protips</h1>

<p>As with other PBLAS or ScaLAPACK functions, this function expects the matrix to be already distributed over the BLACS process grid (and of course the BLACS process grid should be initialized).</p>

<p>The function in scalapack for LU decomposition is <code>pdgetrf_</code>. The C++ prototype of this function is
as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> pdgetrf_(
    <span style="color:#0a8;font-weight:bold">int</span> *m,   <span style="color:#777">// (global) The number of rows in the distributed matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *n,   <span style="color:#777">// (global) The number of columns in the distributed matrix sub(A)</span>
    <span style="color:#777">// (local) Pointer into the local memory to an array of local size.</span>
    <span style="color:#777">// Contains the local pieces of the distributed matrix sub(A) to be factored.</span>
    <span style="color:#0a8;font-weight:bold">double</span> *a,
    <span style="color:#0a8;font-weight:bold">int</span> *ia,  <span style="color:#777">// (global) row index in the global matrix A indicating first row matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *ja,  <span style="color:#777">// (global) col index in the global matrix A indicating first col matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *desca, <span style="color:#777">// array descriptor of A</span>
    <span style="color:#0a8;font-weight:bold">int</span> *ipiv, <span style="color:#777">// contains the pivoting information. array of size</span>
    <span style="color:#0a8;font-weight:bold">int</span> *info <span style="color:#777">// information about execution.</span>
);
</pre></td>
</tr></table>
</div>

<p>In the above prototype, <code>m</code> signifies the number of rows of the submatrix, meaning
the matrix that is present in the current process. Similarly for <code>n</code> in case of cols.</p>

<p>A function <code>descinit_</code> can be used for initializing the descriptor array. Its prototype is as
follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> descinit_(<span style="color:#0a8;font-weight:bold">int</span> *desc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m,  <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *mb, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *irsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *icsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ictxt, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *lld, <span style="color:#0a8;font-weight:bold">int</span> *info);
</pre></td>
</tr></table>
</div>
<p>In the <code>descinit_</code>, the <code>MB</code> and <code>NB</code> parameters signify the size of the block into which the
matrix is divided. Not the size of the block that each process will receive. See the <code>sync_lu</code>
code for an <a href="https://github.com/v0dro/scratch/tree/master/c_shizzle/parallel/sync_lu">example</a> of block cyclic LU decomposition.</p>

<p>The <code>ipiv</code> array is not a synchronized data struture - it will be different for each process.
According to the docs, <code>ipiv(i)</code> is the global row local row i was swapped with. This array 
is tied to the distributed matrix A.</p>

<h2 id="storage-in-the-arrays">Storage in the arrays</h2>

<p>Each local array of a process should store a part of the global matrix. The global matrix is stored
in a block cyclic manner and scalapack reads each local array expecting it in a particular format.
It is important to be aware of this.</p>

<p>See <a href="http://netlib.org/scalapack/slug/node28.html">this</a> explanation on the scalapack site to get a complete understanding. <a href="http://netlib.org/scalapack/slug/node35.html">This</a> link has resources
on data distribution in scalapack in general.</p>

<p>For example, say you have a <code>1024 x 1024</code> matrix which you want to distribute on a 3x3 grid of 9 processes.</p>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://software.intel.com/en-us/forums/intel-math-kernel-library/topic/288028">Intel Q and A on numroc</a></li>
  <li><a href="http://www.netlib.org/scalapack/explore-html/d4/d48/numroc_8f_source.html">Numroc fortran docs</a></li>
  <li><a href="https://software.intel.com/en-us/articles/using-cluster-mkl-pblasscalapack-fortran-routine-in-your-c-program">Using PBLAS/ScaLAPACK in your C code by intel (MKL specific)</a></li>
</ul>

:ET