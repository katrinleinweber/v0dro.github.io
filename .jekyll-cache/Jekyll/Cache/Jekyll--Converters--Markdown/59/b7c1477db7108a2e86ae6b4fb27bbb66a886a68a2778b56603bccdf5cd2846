I"/'<p>Solving systems of linear equations is a very important part of scientific computing (some would say most important), and in this post I will show you how a system of linear equations involving <em>n</em> equations and <em>n</em> unknowns can be solved in Ruby using the <a href="https://github.com/SciRuby/nmatrix">NMatrix</a> gem and the methodology that I used for simplyfying the algorithms involved.</p>

<p>This involved solving a system of linear equations using forward substution followed by back substution using the LU factorization of the matrix of co-efficients.</p>

<p>The reduction techniques were quite baffling at first, because I had always solved equations in the traditional way and this was something completely new. I eventually figured it out and also <a href="https://github.com/SciRuby/nmatrix/commit/4241d241ca7744ca2ca5e090782588581160d42b">implemented it in NMatrix</a>. Here I will document how I did that. Hopefully, this will be useful to others like me!</p>

<p>I’m assuming that you are familiar with the LU decomposed form of a square matrix. If not, read <a href="http://en.wikipedia.org/wiki/LU_decomposition">this</a> resource first.</p>

<p>Throughout this post, I will refer to <em>A</em> as the square matrix of co-efficients, <em>x</em> as the column matrix of unknowns and <em>b</em> as column matrix of right hand sides.</p>

<p>Lets say that the equation you want to solve is represented by:</p>

<script type="math/tex; mode=display">A.x = b .. (1)</script>

<p>The basic idea behind an LU decomposition is that a square matrix A can be represented as the product of two matrices <em>L</em> and <em>U</em>, where <em>L</em> is a lower <a href="http://en.wikipedia.org/wiki/Triangular_matrix">triangular matrix</a> and <em>U</em> is an upper triangular matrix.</p>

<script type="math/tex; mode=display">L.U = A</script>

<p>Given this, equation (1) can be represented as:</p>

<script type="math/tex; mode=display">L.(U.x) = b</script>

<p>Which we can use for solving the vector <em>y</em> such that:</p>

<script type="math/tex; mode=display">L.y = b .. (2)</script>

<p>and then solving:</p>

<script type="math/tex; mode=display">U.x = y ..(3)</script>

<p>The LU decomposed matrix is typically carried in a single matrix to reduce storage overhead, and thus the diagonal elements of <em>L</em> are assumed to have a value <em>1</em>. The diagonal elements of <em>U</em> can have any value.</p>

<p>The reason for breaking down <em>A</em> and first solving for an upper triangular matrix is that the solution of an upper triangular matrix is quite trivial and thus the solution to (2) is found using the technique of <em>forward substitution</em>.</p>

<p>Forward substitution is a technique that involves scanning an upper triangular matrix from top to bottom, computing a value for the top most variable and substituting that value into subsequent variables below it. This proved to be quite intimidating, because according to <a href="http://www.nr.com/">Numerical Recipes</a>, the whole process of forward substitution can be represented by the following equation:</p>

<script type="math/tex; mode=display">\begin{align}
  y_{0} = \dfrac{b_{0}}{L_{00}}
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
  y_{i} = \dfrac{1}{L_{ii}}[b_{i} - \sum_{j=0}^{i-1}L_{ii} \times y_{j}] \quad i = 1,2,\dotsc,N-1 \quad (4)
\end{align}</script>

<p>Figuring out what exactly is going on was quite a daunting task, but I did figure it out eventually and here is how I went about it:</p>

<p>Let <em>L</em> in equation (2) to be the lower part of a 3x3 matrix A (as per (1)). So equation (2) can be represented in matrix form as:</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
    \begin{pmatrix}
      L_{00} & 0 & 0 \\
      L_{10} & L_{11} & 0 \\
      L_{20} & L_{21} & L_{22}
    \end{pmatrix}
    \begin{pmatrix}
      y_{0} \\
      y_{1} \\
      y_{2}
    \end{pmatrix}
    =
    \begin{pmatrix}
      b_{0} \\
      b_{1} \\
      b_{2}
    \end{pmatrix}
\end{align} %]]></script>

<p>Our task now is calculate the column matrix containing the <em>y</em> unknowns.
Thus by equation (4), each of them can be calculated with the following sets of equations (if you find them confusing just correlate each value with that present in the matrices above and it should be clear):</p>

<script type="math/tex; mode=display">\begin{align}
  y_{0} = \dfrac{b_{0}}{L_{00}}
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
  y_{1} = \dfrac{1}{L_{11}} \times [b_{1} - L_{00} \times y_{0}]
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
  y_{2} = \dfrac{1}{L_{22}} \times [b_{2} - (L_{20} \times y_{0} + L_{21} \times y_{1})]
\end{align}</script>

<p>Its now quite obvious that forward substitution is called so because we start from the topmost row of the matrix and use the value of the variable calculated in that row to calculate the <em>y</em> for the following rows.</p>

<p>Now that we have the solution to equation (2), we can use the values generated in the <em>y</em> column vector to compute <em>x</em> in equation (3). Recall that the matrix <em>U</em> is the upper triangular decomposed part of <em>A</em> (equation (1)). This matrix can be solved using a technique called <em>backward substitution</em>. It is the exact reverse of the <em>forward substitution</em> that we just saw, i.e. the values of the bottom-most variables are calculated first and then substituted into the rows above to calculate subsquent variables above.</p>

<p>The equation describing backward substitution is described in Numerical Recipes as:</p>

<script type="math/tex; mode=display">\begin{align}
  x_{N-1} = \dfrac{y_{N-1}}{U_{N-1,N-1}}
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
  x_{i} = \dfrac{1}{U_{ii}}[y_{i} - \sum_{j=i+1}^{N-1}U_{ij} \times x_{j}] \quad i = N-2, N-3,\dotsc,0 \quad (5)
\end{align}</script>

<p>Lets try to understand this equation by extending the example we used above to understand forward substitution. To gain a better understanding of this concept, consider the equation (3) written in matrix form (keeping the same 3x3 matrix <em>A</em>):</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align}
    \begin{pmatrix}
      U_{00} & U_{01} & U_{02} \\
      0 & U_{11} & U_{12} \\
      0 & 0 & U_{22}
    \end{pmatrix}
    \begin{pmatrix}
      x_{0} \\
      x_{1} \\
      x_{2}
    \end{pmatrix}
    =
    \begin{pmatrix}
      y_{0} \\
      y_{1} \\
      y_{2}
    \end{pmatrix}
\end{align} %]]></script>

<p>Using the matrix representation above as reference, equation (5) can be expanded in terms of a 3x3 matrix as:</p>

<script type="math/tex; mode=display">\begin{align}
  x_{2} = \dfrac{y_{2}}{U_{22}}
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
  x_{1} = \dfrac{1}{U_{11}} \times [y_{1} - U_{12} \times x_{2}]
\end{align}</script>

<script type="math/tex; mode=display">\begin{align}
  x_{0} = \dfrac{1}{U_{00}} \times [y_{0} - (U_{01} \times x_{1} + U_{02} \times x_{2})]
\end{align}</script>

<p>Looking at the above equations its easy to see how backward substitution can be used to solve for unknown quantities when given a upper triangular matrix of co-efficients, by starting at the lowermost variable and gradually moving upward.</p>

<p>Now that the methodology behind solving sets of linear equations is clear, lets consider a set of 3 linear equations and 3 unknowns and compute the values of the unknown quantities using the nmatrix #solve method.</p>

<p>The #solve method can be called on any nxn square matrix of a floating point data type, and expects its sole argument to be a column matrix containing the right hand sides. It returns a column nmatrix object containing the computed co-efficients.</p>

<p>For this example, consider these 3 equations:</p>

<script type="math/tex; mode=display">x + y − z = 4</script>

<script type="math/tex; mode=display">x − 2y + 3z = −6</script>

<script type="math/tex; mode=display">2x + 3y + z = 7</script>

<p>These can be translated to Ruby code by creating an NMatrix only for the co-efficients and another one only for right hand sides:</p>

<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
</pre></td>
  <td class="code"><pre>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">nmatrix</span><span style="color:#710">'</span></span>
coeffs = <span style="color:#036;font-weight:bold">NMatrix</span>.new([<span style="color:#00D">3</span>,<span style="color:#00D">3</span>],
  [<span style="color:#00D">1</span>, <span style="color:#00D">1</span>,<span style="color:#00D">-1</span>,
   <span style="color:#00D">1</span>,<span style="color:#00D">-2</span>, <span style="color:#00D">3</span>,
   <span style="color:#00D">2</span>, <span style="color:#00D">3</span>, <span style="color:#00D">1</span>], <span style="color:#606">dtype</span>: <span style="color:#A60">:float32</span>)

rhs = <span style="color:#036;font-weight:bold">NMatrix</span>.new([<span style="color:#00D">3</span>,<span style="color:#00D">1</span>],
  [<span style="color:#00D">4</span>,
  <span style="color:#00D">-6</span>,
   <span style="color:#00D">7</span>], <span style="color:#606">dtype</span>: <span style="color:#A60">:float32</span>)

solution = coeffs.solve(rhs)
<span style="color:#777">#=&gt; [1.0, 2.0, -1.0]</span>
</pre></td>
</tr></table>
</div>
:ET