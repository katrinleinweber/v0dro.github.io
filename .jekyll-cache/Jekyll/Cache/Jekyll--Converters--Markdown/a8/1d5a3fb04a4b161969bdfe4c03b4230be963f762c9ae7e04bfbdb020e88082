I"ó…<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#ndtypes">Ndtypes</a>
    <ul>
      <li><a href="#usage">Usage</a>
        <ul>
          <li><a href="#basic-initialization">Basic initialization</a></li>
          <li><a href="#concrete-vs-abstract-types">Concrete Vs. Abstract Types</a></li>
          <li><a href="#typedefs">Typedefs</a></li>
          <li><a href="#usage-via-the-c-api">Usage via The C API</a></li>
        </ul>
      </li>
      <li><a href="#implementation">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#xnd">Xnd</a>
    <ul>
      <li><a href="#basic-usage">Basic Usage</a>
        <ul>
          <li><a href="#data-type-support">Data Type Support</a></li>
          <li><a href="#missing-values">Missing Values</a></li>
          <li><a href="#usage-via-the-c-api">Usage via The C API</a></li>
        </ul>
      </li>
      <li><a href="#implementation">Implementation</a></li>
    </ul>
  </li>
  <li><a href="#gumath">Gumath</a>
    <ul>
      <li><a href="#usage">Usage</a>
        <ul>
          <li><a href="#usage-via-the-c-api">Usage via The C API</a></li>
        </ul>
      </li>
      <li><a href="#implementation">Implementation</a></li>
      <li><a href="#automatic-kernel-generation">Automatic Kernel Generation</a></li>
    </ul>
  </li>
</ul>

<!-- markdown-toc end -->

<h1 id="introduction">Introduction</h1>

<p>Lack of stable and reliable scientific computing software has been a persistent problem
for the Ruby community, making it hard for enthusiastic Ruby developers to use Ruby in
everything from their web applications to their data analysis projects. One of the most important
components of any successful scientific software stack is a well maintained and flexible
array computation library that can act as a fast and simple way of storing in-memory data
and interfacing it with various fast and battle-tested libraries like LAPACK and BLAS.</p>

<p>Various projects have attempted to make such libraries in the past (and some are still thriving
and maintained). Some of the notable ones are <a href="https://github.com/ruby-numo">numo</a>, <a href="https://github.com/SciRuby/nmatrix">nmatrix</a>, and more recently, <a href="https://github.com/SciRuby/numruby">numruby</a>.
These projects attempt to provide a simple Ruby-like API for creating and manipulating arrays
of various types. All of them are able to easily interface with libraries like ATLAS, FFTW
and LAPACK.</p>

<p>However, all of the above projects fall short in two major aspects:</p>
<ul>
  <li>Lack of extensibility to adapt to modern use cases (read Machine Learning).</li>
  <li>Lack of a critical mass of developers to maintain a robust and fast array library.</li>
</ul>

<p>The first problem is mainly due to the fact that they do not support very robust type systems.
The available data types are limited and are extend to more complex uses. Modern use cases like
Machine Learning require much more robust data types, as has been demonstrated by the tensor
implementations of various frameworks like Tensorflow and PyTorch.</p>

<p>The second problem is due to the fact that all of the aforementioned projects are community
efforts that are maintained part-time by developers simply out of a sense of purpose and
passion. Sustaining such complex projects for extended periods of time without expectation
of any support is simply unfeasible even for the most driven engineers.</p>

<p>This is where the XND project comes in. The <a href="https://xnd.io/">XND project</a> is a project for
building a common library that is able to meet the needs of the various data analysis and
machine learning frameworks that have had to build their own array objects and programming 
languages. It is built with the premise of extending arrays with new types and various 
device types (CPUs, GPUs etc.) without loss of performance and ease of use.</p>

<p>The XND project as a whole is a product of three C libraries : ndtypes, xnd and gumath. They
have been made such that they can work as standalone C libraries that can be interfaced
with any language binding (currently supporting Ruby and Python). Ndtypes is used for defining
the shape of data within memory, XND is a data container that holds that data and gumath provides
a multiple dispatch mechanism for performing computations on data held in XND containers. We will
elaborate on each of these in the post below.</p>

<p>The XND project presents the perfect answer to Rubyâ€™s lack of a mature array computation ecosystem. 
It is highly extensible, allows defining data types in almost any combination with a simple and
intuitive interface, is built with performance in mind and is backed by a team consisting of 
experts who have vast experience in this domain for the Python scientific computing stack.</p>

<p>The biggest backer of XND as of now is Quansight, and I as a part-time engineer am responsible 
for maintaining the Ruby wrapper for XND. This post is a rather long and detailed introduction 
to the XND ruby wrapper including various use cases and benchmarks. There will also be some
details on the implementation of the wrapper and how it differs from the python wrapper (which
existed before the Ruby wrapper). Read on for further details.</p>

<p>All the source code can be found in the <a href="https://github.com/xnd-project/xnd-ruby">xnd-ruby</a> repo.</p>

<h1 id="ndtypes">Ndtypes</h1>

<p>Ndtypes is the library that is used for defining the shape of data.</p>

<p>Run <code>gem install ndtypes --pre</code> for easily installing ndtypes onto your machine. It has
been tested with Ruby 2.4.1 so far. The <code>gem install</code> will download the C sources and compile
them by itself.</p>

<h2 id="usage">Usage</h2>

<h3 id="basic-initialization">Basic initialization</h3>

<p>The ndtypes Ruby wrapper provides a simple interface to the ndtypes C library for creating
complex data shapes with extreme simplicity. For example, for creating an array of 10 <code>int64</code>
digits, all we need to do is create an instance of the <code>NDT</code> class:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>t = <span style="color:#036;font-weight:bold">NDT</span>.new <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">10 * int64</span><span style="color:#710">&quot;</span></span>
</pre></td>
</tr></table>
</div>

<p>Not only can you create arrays, but also very complex types, for example a nested record (xnd 
terminology for a Ruby <code>Hash</code>) with the values as arrays of type <code>float32</code> of size 25 each:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>t = <span style="color:#036;font-weight:bold">NDT</span>.new <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">{x: 25 * float32, y: {a: 25 * float64, 25 * float64}}</span><span style="color:#710">&quot;</span></span>
</pre></td>
</tr></table>
</div>

<h3 id="concrete-vs-abstract-types">Concrete Vs. Abstract Types</h3>

<p>Ndtypes distinguishes types depending on whether they are abstract or concrete. Abstract types
can have symbolic values like dimension or type variables and are used for type checking. Concrete 
types additionally have full memory layout information like alignment and data size.</p>

<p>Some operations can be only performed on abstract types.</p>

<h3 id="typedefs">Typedefs</h3>

<p>One can also define typedefs using the <code>NDT#typedef</code> function and then use them in place of
the original type. Hereâ€™s an example of using typedefs to define a graph type:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span style="color:#036;font-weight:bold">NDT</span>.typedef <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">node</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">int32</span><span style="color:#710">&quot;</span></span>
<span style="color:#036;font-weight:bold">NDT</span>.typedef <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">cost</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">int32</span><span style="color:#710">&quot;</span></span>
<span style="color:#036;font-weight:bold">NDT</span>.typedef <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">graph</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">var * var * (node, cost)</span><span style="color:#710">&quot;</span></span>
</pre></td>
</tr></table>
</div>

<h3 id="usage-via-the-c-api">Usage via The C API</h3>

<p>Most of the C API functions of ndtypes deal with creating <code>NDT</code> Ruby objects or obtaining
internal struct data of an <code>NDT</code> Ruby object. The complete specification can be found
in the <a href="https://github.com/xnd-project/xnd-ruby/blob/master/ndtypes/ext/ruby_ndtypes/ruby_ndtypes.h">ruby_ndtypes.h</a> file. This is the file you should include if you want to use the
C API in any of your libraries.</p>

<h2 id="implementation">Implementation</h2>

<p>The Ruby wrapper is a wrapper over the libndtypes library. The <code>NDT</code> Ruby object is a wrapper
over a C struct of type <code>NdtObject</code> that has the following definition:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">typedef</span> <span style="color:#080;font-weight:bold">struct</span> NdtObject {
  <span style="color:#088;font-weight:bold">const</span> ndt_t *ndt;                   <span style="color:#777">/* type */</span>
} NdtObject;
</pre></td>
</tr></table>
</div>
<p>This simple struct stores a pointer to a struct of type <code>const ndt_t *</code> that is provided
by libndtypes for representing an ndtype. The <code>const ndt_t</code> structs are allocated by
various libndtypes functions like <code>ndt_from_string()</code> or <code>ndt_alloc()</code>.</p>

<p>Internally libndtypes uses a reference counting mechanism for keeping track of <code>ndt_t</code> allocations
that need to be destroyed. The reference count can be incremented using <code>ndt_incref()</code> or
decremented using <code>ndt_decref()</code>. Once the refcount reaches the <code>0</code> the object is automatically
destroyed by libndtypes. Of course, <code>ndt_t</code> structs allocated via calls to functions like
<code>ndt_alloc()</code> already come with a refcount of 1.</p>

<h1 id="xnd">Xnd</h1>

<p>XND is the main storage library of the project. It uses types defined by ndtypes for defining
the shape of data and allows users to read and write data into buffers that are of the shape
of the data passed to it by ndtypes. It is responsible for maintaining the memory consistency
of data and has provisions for various operations such as slicing, copying and interfacing
data with 3rd party libraries like Apache Arrow. It also serves as a memory buffer for the
functions that are defined within gumath (explained later in this post).</p>

<p>Similar to the ndtypes wrapper, the xnd Ruby wrapper can be installed with a call to
<code>gem install xnd --pre</code>.</p>

<h2 id="basic-usage">Basic Usage</h2>

<p>The xnd Ruby wrapper is extremely simple to use and provides a single class <code>XND</code> for the
user that interfaces with libxnd. In the simplest case, one can create an XND object as follows:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre>x = <span style="color:#036;font-weight:bold">XND</span>.new [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>]
<span style="color:#777"># =&gt; #&lt;XND:47340720296980&gt;</span>
<span style="color:#777">#         type= 4 * int64</span>
<span style="color:#777">#         value= [1, 2, 3, 4]</span>
</pre></td>
</tr></table>
</div>
<p>Since we have not specified the data type, it will be inferred as <code>int64</code> since we are supplying
an array composed entirely of integers. This can be seen using the <code>XND#dtype</code> function, which
will return the <code>NDT</code> object that holds the type of this <code>XND</code> object:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>x.dtype
<span style="color:#777"># =&gt; #&lt;NDTypes:47340721833280&gt;</span>
<span style="color:#777">#        int64 </span>
</pre></td>
</tr></table>
</div>
<p>While <code>XND#dtype</code> gives the general type of the object, a more precise description of the data
type (including shape etc.) can be obtained using the <code>type</code> method:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>x.type
<span style="color:#777"># =&gt; #&lt;NDTypes:47340721846240&gt;</span>
<span style="color:#777">#  4 * int64</span>
</pre></td>
</tr></table>
</div>
<p>The value within the <code>XND</code> object can be obtained as a Ruby Array (or Hash if it is a NDT record)
using the <code>XND#value</code> method:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>x.value
<span style="color:#777"># =&gt; [1, 2, 3, 4]</span>
</pre></td>
</tr></table>
</div>
<p>We can also perform operations for checking equality between <code>XND</code> objects using the <code>==</code> or <code>!=</code> operators:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>a = <span style="color:#036;font-weight:bold">XND</span>.new [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>]
x == a
<span style="color:#777"># =&gt; true</span>
</pre></td>
</tr></table>
</div>
<p>A nice thing about <code>XND</code> is that it returns copy-free â€˜viewsâ€™ of data when you perform a slicing
operation. So say we define a 2D tensor <code>tensor_2d</code> like this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
</pre></td>
  <td class="code"><pre>tensor_2d = <span style="color:#036;font-weight:bold">XND</span>.new(
  [
    [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>],
    [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>],
    [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>],
    [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>],
    [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>]
  ]
)
tensor_2d.inspect
<span style="color:#777"># =&gt; #&lt;XND:47340720946720&gt;</span>
<span style="color:#777">#         type= 5 * 5 * int64</span>
<span style="color:#777">#         value= [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]</span>
</pre></td>
</tr></table>
</div>
<p>We can obtain a slice (say the 2nd column) of the tensor using Ruby Range. Note that using <code>INF</code> is a shorthand for specifying the entire axis (usually denoted as <code>0..-1</code>):</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre>vector_view = tensor_2d[<span style="color:#036;font-weight:bold">INF</span>, <span style="color:#00D">2</span>]
<span style="color:#777"># =&gt; #&lt;XND:47340720380980&gt;</span>
<span style="color:#777">#         type= 5 * int64</span>
<span style="color:#777">#         value= [3, 3, 3, 3, 3]</span>
</pre></td>
</tr></table>
</div>
<p>When using slices, <code>XND</code> will always return a â€˜viewâ€™ of the original <code>XND</code> object. Changes
made to this slice will reflect on the original XND object as well:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre>vector_view[<span style="color:#00D">2</span>] = <span style="color:#00D">666</span>
tensor_2d.inspect
<span style="color:#777"># =&gt; #&lt;XND:47340720946720&gt;</span>
<span style="color:#777">#         type= 5 * 5 * int64</span>
<span style="color:#777">#         value= [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5], [1, 2, 666, 4, 5], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]</span>
</pre></td>
</tr></table>
</div>
<p>However, the <code>type</code> of the view and the original object differ as they should:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre>vector_view.type
<span style="color:#777"># =&gt; #&lt;NDTypes:47340720381100&gt;</span>
<span style="color:#777">#        5 * int64 </span>
tensor_2d.type
<span style="color:#777"># =&gt; #&lt;NDTypes:47340720939360&gt;</span>
<span style="color:#777">#        5 * 5 * int64</span>
</pre></td>
</tr></table>
</div>
<p>If you want a separate storage space for the view (i.e. do not want changes to the view
to reflect on the parent object), you should use the <code>XND#dup</code> method and make a copy. You
can also allocate a data container without storing any data into it using the <code>XND.empty</code>
method as can be seen in the following examples.</p>

<h3 id="data-type-support">Data Type Support</h3>

<p>As a result of the flexibility provided by the ndtypes type definition interface, xnd is able
to provide type support for far more flexible data shapes than simply for arrays with fixed
dimensions. For example, you can use records for storing Ruby Hashes and performing operations
on them:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre>require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">xnd</span><span style="color:#710">'</span></span>

x = <span style="color:#036;font-weight:bold">XND</span>.empty <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">{x: complex64, y: bytes, z: string}</span><span style="color:#710">&quot;</span></span>
v = { <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">x</span><span style="color:#710">'</span></span> =&gt; <span style="color:#00D">1</span>+<span style="color:#00D">20i</span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">y</span><span style="color:#710">'</span></span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">abc</span><span style="color:#710">&quot;</span></span>.b, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">z</span><span style="color:#710">'</span></span> =&gt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">any</span><span style="color:#710">&quot;</span></span> }
x[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">x</span><span style="color:#710">'</span></span>] = v[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">x</span><span style="color:#710">'</span></span>]
x[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">y</span><span style="color:#710">'</span></span>] = v[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">y</span><span style="color:#710">'</span></span>]
x[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">z</span><span style="color:#710">'</span></span>] = v[<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">z</span><span style="color:#710">'</span></span>]
x
<span style="color:#777"># =&gt; #&lt;XND:47340721378580&gt;</span>
<span style="color:#777">#         type= {x : complex64, y : bytes, z : string}</span>
<span style="color:#777">#         value= {&quot;x&quot;=&gt;(1.0+20.0i), &quot;y&quot;=&gt;&quot;abc&quot;, &quot;z&quot;=&gt;&quot;any&quot;}</span>
</pre></td>
</tr></table>
</div>

<h3 id="missing-values">Missing Values</h3>

<p>XND also supports optional data (represented by <code>nil</code>). It can be created as follows:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre>x = <span style="color:#036;font-weight:bold">XND</span>.empty <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">2 * 4 * ?float64</span><span style="color:#710">&quot;</span></span>
v = [[<span style="color:#60E">10.0</span>, <span style="color:#069">nil</span>, <span style="color:#60E">2.0</span>, <span style="color:#60E">100.12</span>], [<span style="color:#069">nil</span>, <span style="color:#069">nil</span>, <span style="color:#60E">6.0</span>, <span style="color:#60E">7.0</span>]]
x[<span style="color:#036;font-weight:bold">INF</span>] = v <span style="color:#777"># assign full slice</span>
<span style="color:#777"># =&gt; [[10.0, nil, 2.0, 100.12], [nil, nil, 6.0, 7.0]] </span>
</pre></td>
</tr></table>
</div>

<h3 id="usage-via-the-c-api-1">Usage via The C API</h3>

<p>The primary function of the XND Ruby C API is for creating and querying XND Ruby objects.
The full API can be found in the <a href="https://github.com/xnd-project/xnd-ruby/blob/master/xnd/ext/ruby_xnd/ruby_xnd.h">ruby_xnd.h</a> file.</p>

<h2 id="implementation-1">Implementation</h2>

<p>The implementation of the Ruby wrapper differs from the Python wrapper largely due to nature
of the garbage collection algorithms employed by both these languages: Ruby uses a mark-and-sweep
GC while Python uses a reference counted GC. Therefore, Ruby objects created within the C extension
have to somehow be kept â€˜aliveâ€™ such that the GC does not deallocate them thinking that they
have gone out of scope and are no longer useful.</p>

<p>For this purpose we utilize a â€˜GC guardâ€™ structure (inspired by the implementation of 
<a href="https://github.com/mrkn/">@mrkn</a>â€™s <a href="https://github.com/mrkn/matplotlib.rb">matplotlib.rb</a> gem). The GC guard is basically a global Ruby Hash that has the
Ruby object created within the C extension as a key and something random as a value. We
use a Hash because it provides lookups in <code>O(1)</code> time and we donâ€™t care about the value
because we only want to save the object in some kind of a global store so that Ruby is 
aware of its presence (in case of NDT we use <code>true</code> for the value). XND uses three different
GC guards for various internal objects, which can be found in the <a href="https://github.com/xnd-project/xnd-ruby/blob/master/xnd/ext/ruby_xnd/gc_guard.h">gc_guard.h</a> file.</p>

<h1 id="gumath">Gumath</h1>

<p>While ndtypes and xnd allow us to define types and memory storage, gumath allows us to actually
do something with them. The basic idea behind gumath is that it is a library that allows defining
functions for various data types stored within an <code>XND</code> object and allows the user to transparently
call them using a high level interface that uses multiple dispatch for calling the relevant function
on the appropriate type. The Ruby interface is a wrapper over the <code>libgumath</code> C library.</p>

<p>Some functions (known as kernels) come bundled with libgumath and others can be written fairly
easily. Similar to the xnd and ndtypes wrappers, the gumath Ruby wrapper can be installed with a call to <code>gem install gumath --pre</code>.</p>

<h2 id="usage-1">Usage</h2>

<p>The <code>Gumath</code> class is a top level namespace for various modules that serve as namespaces for
functions that come rolled in with the libgumath C library. These modules will keep expanding
as more interfaces are added to libgumath. The <code>Gumath::Functions</code> module contains various
such functions that are provided by libgumath by default.</p>

<p><code>Gumath</code> functions accept <code>XND</code> objects as arguments and output <code>XND</code> objects with the result
of the function. An example of a simple element-wise multiply kernel is the following:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre>require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">xnd</span><span style="color:#710">'</span></span>
require <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">'</span><span style="color:#D20">gumath</span><span style="color:#710">'</span></span>

x = <span style="color:#036;font-weight:bold">XND</span>.new [<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>,<span style="color:#00D">6</span>,<span style="color:#00D">7</span>,<span style="color:#00D">8</span>,<span style="color:#00D">9</span>], <span style="color:#606">dtype</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">float64</span><span style="color:#710">&quot;</span></span>
y = <span style="color:#036;font-weight:bold">XND</span>.new [<span style="color:#00D">1</span>,<span style="color:#00D">2</span>,<span style="color:#00D">3</span>,<span style="color:#00D">4</span>,<span style="color:#00D">5</span>,<span style="color:#00D">6</span>,<span style="color:#00D">7</span>,<span style="color:#00D">8</span>], <span style="color:#606">dtype</span>: <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">float64</span><span style="color:#710">&quot;</span></span>
z = <span style="color:#036;font-weight:bold">Gumath</span>::<span style="color:#036;font-weight:bold">Functions</span>.multiply x, y
<span style="color:#777"># =&gt; #&lt;XND:47340721458320&gt;</span>
<span style="color:#777">#         type= 8 * float64</span>
<span style="color:#777">#         value= [2.0, 6.0, 12.0, 20.0, 30.0, 42.0, 56.0, 72.0]</span>
</pre></td>
</tr></table>
</div>

<h3 id="usage-via-the-c-api-2">Usage via The C API</h3>

<p>Since the main purpose of the gumath C API is to allow adding kernels to a Ruby module,
it provides a single function of the prototype:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> rb_gumath_add_functions(VALUE module, <span style="color:#088;font-weight:bold">const</span> gm_tbl_t *tbl);
</pre></td>
</tr></table>
</div>
<p>The <code>module</code> parameter is a Ruby object, and <code>tbl</code> is a function table of gumath kernels.</p>

<h2 id="implementation-2">Implementation</h2>

<p>Compared to xnd and ndtypes, the gumath Ruby wrapper is much simpler
since its primary function is to take functions from libgumath and add them as module 
functions to Ruby modules.</p>

<p>When the library is initially loaded using a call to <code>require</code>, the relevant libgumath kernels
provided by default are loaded into the Ruby interpreter by interfacing each kernel with a
Ruby object. Further details on the working of the method dispatch within Ruby can be found
in the <a href="https://github.com/xnd-project/xnd-ruby/blob/master/gumath/CONTRIBUTING.md">CONTRIBUTING</a> file.</p>

<p>The most important part of the C implementation is the <code>GufuncObject</code> class which is a Ruby
class defined within the C API that helps interface with a single gumath function. This class
is basically a wrapper over a C struct <code>GufuncObject</code> that can be found in the <a href="https://github.com/xnd-project/xnd-ruby/blob/master/gumath/ext/ruby_gumath/gufunc_object.h">gufunc_object.h</a>
file.</p>

<p>The struct has the following definition:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">typedef</span> <span style="color:#080;font-weight:bold">struct</span> {
  <span style="color:#088;font-weight:bold">const</span> gm_tbl_t *table;          <span style="color:#777">/* kernel table */</span>
  <span style="color:#0a8;font-weight:bold">char</span> *name;                     <span style="color:#777">/* function name */</span>
  uint32_t flags;                 <span style="color:#777">/* memory target */</span>
  VALUE identity;                 <span style="color:#777">/* identity element */</span>
} GufuncObject;
</pre></td>
</tr></table>
</div>

<p>The <code>table</code> pointer is the pointer to the definition of the function within libgumath that
holds information about the function that is used by <code>gm_apply</code> for making the actual call to
the function with the data. <code>name</code> is a string holding the name of the function. <code>flags</code>
signify whether the function is a CPU function or a CUDA function (or for that matter any
other device that might be added in the future). <code>identity</code> is a Ruby object used for identifying
this function. It is initially set to <code>nil</code>.</p>

<h2 id="automatic-kernel-generation">Automatic Kernel Generation</h2>

<p>Writing kernels can be painstaking if youâ€™re not familiar with the various functionalities
that libgumath provides for this purpose. Therefore we also provide a kernel generator
called <a href="https://xnd.readthedocs.io/en/latest/xndtools/index.html#kernel-generator">xndtools</a> that allows writing gumath kernels by simply providing the function
that needs to wrapped. However, this functionality has not yet been tested for Ruby.</p>
:ET