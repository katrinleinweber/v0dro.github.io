I"¼<h1 id="purpose">Purpose</h1>

<p>An accepted convention for writing Ruby C extensions.</p>

<h1 id="reason">Reason</h1>

<p>Too many C extensions with absoltely no correlation in terms of conventions.</p>

<h1 id="proposal">Proposal</h1>

<h2 id="ruby-specific-things">Ruby-specific things</h2>

<h3 id="ruby-methods">Ruby methods</h3>

<p>All Ruby methods should have the name format <code>&lt;class name&gt;_&lt;ruby method name&gt;</code>. So the
<code>initialize</code> method of a class <code>NDTypes</code> would like so:</p>
<pre><code>rb_define_method(cNDTypes, "initialize", NDTypes_initialize, 1);
</code></pre>

<h3 id="ruby-singleton-methods">Ruby singleton methods</h3>

<p>Singleton method names should be prefixed by a <code>s</code> before the method name. For example,
if you want to define a singleton <code>foo</code> inside a class <code>Bar</code>:</p>
<pre><code>rb_define_singleton_method(cBar, "foo", Bar_s_foo, 1);
</code></pre>

<h3 id="ruby-classes">Ruby classes</h3>

<p>The <code>VALUE</code> variable containing Ruby classes should be prefixed with a <code>c</code>. So if
youâ€™re defining a Ruby class <code>NMatrix</code>, it would look like so:</p>
<pre><code>VALUE cNMatrix = rb_define_class("NMatrix", rb_cObject);
</code></pre>

<h3 id="ruby-nested-classes">Ruby nested classes</h3>

<p>If you have nested classes, the nested class name should come after the parent class,
separted by an underscore. For example, to define a class <code>Foo</code> nested inside <code>Bar</code>:</p>
<pre><code>VALUE cBar = rb_define_class("Bar", rb_cObject);
VALUE cBar_Foo = rb_define_class_under(cBar, "Foo", rb_cObject);
</code></pre>

<h3 id="ruby-modules">Ruby modules</h3>

<h3 id="parsing-keyword-arguments-to-ruby-methods">Parsing keyword arguments to Ruby methods</h3>

<p>Since there is no direct way for accessing kwargs via C extensions we advocate usage
of</p>

<p>However, you should be mindful of this <a href="https://bugs.ruby-lang.org/issues/11339">bug</a> and avoid arg
scanning in C for performance reasons.</p>

<h2 id="c-specific-things">C-specific things</h2>

<h3 id="general-c-function-conventions">General C function conventions</h3>

<p>All functions should be defined as <code>static</code>.</p>

<h3 id="bang-and-boolean-methods">bang and boolean methods</h3>

<p>Ruby supports method names ending in bang (<code>String#chomp!</code>) and boolean methods
ending in question mark (<code>Array#empty?</code>). The corresponding function in C will
end with <code>_bang</code> and <code>_qmark</code> respectively.</p>

<h3 id="struct-definitions">Struct definitions</h3>

<p>Struct definitions should always be done with a <code>typedef</code>. Nowhere in the code should you
use the <code>struct</code> keyword for specifying a type. Example:</p>
<pre><code>typedef struct {
  int x;
  float y;
} foo_t;
</code></pre>

<h3 id="default-values-for-structs">Default values for structs</h3>

<p>Structs should be initialized to defaults with C99â€™s compound literal syntax. For example:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">typedef</span> <span style="color:#080;font-weight:bold">struct</span> {
  <span style="color:#0a8;font-weight:bold">int</span> x;
  <span style="color:#0a8;font-weight:bold">float</span> y;
} foo_t;

foo_t var = { .x = <span style="color:#00D">44</span>, .y = <span style="color:#00D">5</span><span style="color:#60E">5</span><span style="color:#60E">.0</span> };
</pre></td>
</tr></table>
</div>

<h3 id="struct-markfreesize-functions">Struct mark/free/size functions</h3>

<p>Various functions required for GC marking, freeing and getting the size of structs should be
written using the convention <code>&lt;struct name&gt;_d&lt;task name&gt;</code>. So for example, the <code>mark</code> function
of type <code>foo_t</code> would be <code>foo_t_dmark</code>, <code>foo_t_dsize</code> and <code>foo_t_dfree</code>.</p>

<h3 id="defining-structs-for-telling-ruby-how-to-handle-c-structs">Defining structs for telling Ruby how to handle C structs</h3>

<p>The latest Ruby requires you to set the parameters of a C struct of type <code>rb_data_type_t</code> that
tells Ruby how to handle a particular C struct when it is encapsulated inside a Ruby object.</p>

<p>This must be declared as <code>static const</code>. The name of the struct must be postfixâ€™d with <code>_type</code>
in order to name the type. Hereâ€™s an example for a struct <code>foo</code>:</p>
<pre><code>static const rb_data_type_t foo_type = {
  .wrap_struct_name = "foo",
  .function = {
    .dmark = foo_dmark,
    .dfree = foo_dfree,
    .dsize = foo_dsize,
  },
  .flags = RUBY_TYPED_FREE_IMMEDIATELY,
};
</code></pre>

<p>Links:</p>

<ul>
  <li>https://github.com/ruby/ruby/blob/trunk/doc/extension.rdoc#c-struct-to-ruby-object</li>
</ul>

<h3 id="macros">Macros</h3>

<p>Macros should be <code>ALL_CAPITAL_WITH_SNAKE_CASE</code>.</p>

<h2 id="c-apis">C APIs</h2>

<p>Some important features of C APIs that will be exposed to other extensions of other
Ruby gems:</p>

<ul>
  <li>API functions or any indirect functions that they call should never raise Ruby errors.</li>
  <li>Error conditions should be indicated by a numerical value. Ideally</li>
</ul>

<h2 id="internal-ruby-objects-for-c-extensions">Internal Ruby objects for C extensions</h2>

<p>It is common to create some internal Ruby objects that only visible via C extensions
for things like saving state between multiple Ruby objects. If you want to use these
objects as a means of sharing data between multiple Ruby objects, you need take some 
precautions when working with the Ruby GC.</p>

<h2 id="general-organization-of-c-files">General organization of C files</h2>

<p>Since C does not have namespaces, it becomes a little hard to keep track of data and the
functions that act on the data. Therefore, it is advisable to keep structs and the important
functions that act on the structs (like allocation, deallocation, marking, etc.) together
for fast reference and reading of code.</p>
:ET