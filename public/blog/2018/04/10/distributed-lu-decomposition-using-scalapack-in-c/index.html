<p>ScaLAPACK is the distributed version of LAPACK. The interface of most functions is 
almost similar. However, not much documentation and example code is available for 
scalapack in C++, which is why I’m writing this blog post to document my learnings.
Hopefully this will be useful for others too.</p>

<p>This post is part of a larger post where I’ve implemented and benchmarked synchronous 
and asynchronous block LU deocomposition. That post can be found <a href="URL">here</a>. <a href="https://software.intel.com/en-us/mkl-developer-reference-c-p-getrf">This</a> intel resource is also helpful for this purpose.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#scalapack-protips">Scalapack protips</a></li>
  <li><a href="#function-usage-protips">Function usage protips</a></li>
  <li><a href="#source-code">Source code</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="scalapack-protips">Scalapack protips</h1>

<p>There are certain terminologies that are pretty widely used in scalapack. They are as follows:</p>
<ul>
  <li>Scalapack docs assume that a matrix of <code>K</code> rows or columns is distributed over a process grid of dimensions p x q.</li>
  <li><code>LOCr</code> :: <code>LOCr(K)</code> denotes the number of elements of K that a process would receive if K were
distributed over the p processes of its process column.</li>
  <li><code>LOCc</code> :: <code>LOCc(K)</code> denotes the number of elements of K that a process would receive if K were 
distributed over the q processes of its process row.</li>
  <li>The values of <code>LOCc</code> and <code>LOCr</code> can be determined using a call to the <code>numroc</code> function.</li>
  <li><strong>IMPORTANT</strong> :: None of these functions have C interfaces the way there are for LAPACK via LAPACKE. 
Therefore, you must take care to pass all variables by address, not by value and store all your data 
in FORTRAN-style, i.e. column-major format not row-major.</li>
</ul>

<p>The <code>numroc</code> function is useful in almost every scalapack function. It computes the number of rows 
and columns of a distributed matrix ownded by the process (the return value). Here’s an explanation 
alongwith the prototype:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> numroc_(
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#777">// (global) the number of rows/cols in dist matrix</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#777">// (global) block size. size of blocks the distributed matrix is split into.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *iproc, <span style="color:#777">// (local input) coord of the process whose local array row is to be determined.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *srcproc, <span style="color:#777">// (global input) coord of the process that has the first row/col of distributed matrix.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nprocs <span style="color:#777">// (global input) total no. of processes over which the matrix is distributed.</span>
);
</pre></td>
</tr></table>
</div>

<h2 id="errors">Errors</h2>

<p>Scalapack reports errors using the XERBLA error handler. Here’s some resources for this:</p>
<ul>
  <li><a href="http://www.netlib.org/scalapack/slug/node151.html#SECTION04751000000000000000">Invalid arguments and XERBLA.</a></li>
  <li><a href="http://www.netlib.org/scalapack/slug/node149.html#seccommonerrors">Common errors in calling ScaLAPACK routines.</a></li>
</ul>

<h1 id="function-usage-protips">Function usage protips</h1>

<p>As with other PBLAS or ScaLAPACK functions, this function expects the matrix to be already distributed over the BLACS process grid (and of course the BLACS process grid should be initialized).</p>

<p>The function in scalapack for LU decomposition is <code>pdgetrf_</code>. The C++ prototype of this function is
as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> pdgetrf_(
    <span style="color:#0a8;font-weight:bold">int</span> *m,   <span style="color:#777">// (global) The number of rows in the distributed matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *n,   <span style="color:#777">// (global) The number of columns in the distributed matrix sub(A)</span>
    <span style="color:#777">// (local) Pointer into the local memory to an array of local size.</span>
    <span style="color:#777">// Contains the local pieces of the distributed matrix sub(A) to be factored.</span>
    <span style="color:#0a8;font-weight:bold">double</span> *a,
    <span style="color:#0a8;font-weight:bold">int</span> *ia,  <span style="color:#777">// (global) row index in the global matrix A indicating first row matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *ja,  <span style="color:#777">// (global) col index in the global matrix A indicating first col matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *desca, <span style="color:#777">// array descriptor of A</span>
    <span style="color:#0a8;font-weight:bold">int</span> *ipiv, <span style="color:#777">// contains the pivoting information. array of size</span>
    <span style="color:#0a8;font-weight:bold">int</span> *info <span style="color:#777">// information about execution.</span>
);
</pre></td>
</tr></table>
</div>

<p>In the above prototype, <code>m</code> signifies the number of rows of the submatrix, meaning
the matrix that is present in the current process. Similarly for <code>n</code> in case of cols.</p>

<p>A function <code>descinit_</code> can be used for initializing the descriptor array. Its prototype is as
follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> descinit_(<span style="color:#0a8;font-weight:bold">int</span> *desc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m,  <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *mb, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *irsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *icsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ictxt, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *lld, <span style="color:#0a8;font-weight:bold">int</span> *info);
</pre></td>
</tr></table>
</div>
<p>In the <code>descinit_</code>, the <code>MB</code> and <code>NB</code> parameters signify the size of the block into which the
matrix is divided. Not the size of the block that each process will receive. See the <code>sync_lu</code>
code for an <a href="https://github.com/v0dro/scratch/tree/master/c_shizzle/parallel/sync_lu">example</a> of block cyclic LU decomposition.</p>

<p>The <code>ipiv</code> array is not a synchronized data struture - it will be different for each process.
According to the docs, <code>ipiv(i)</code> is the global row local row i was swapped with. This array 
is tied to the distributed matrix A.</p>

<h2 id="storage-in-the-arrays">Storage in the arrays</h2>

<p>Each local array of a process should store a part of the global matrix. The global matrix is stored
in a block cyclic manner and scalapack reads each local array expecting it in a particular format.
It is important to be aware of this.</p>

<p>See <a href="http://netlib.org/scalapack/slug/node28.html">this</a> explanation on the scalapack site to get a complete understanding.</p>

<h1 id="source-code">Source code</h1>

<p>Here’s a full source implementing a simple LU decomposition using ScaLAPACK:</p>

<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
<a href="#n63" name="n63">63</a>
<a href="#n64" name="n64">64</a>
<a href="#n65" name="n65">65</a>
<a href="#n66" name="n66">66</a>
<a href="#n67" name="n67">67</a>
<a href="#n68" name="n68">68</a>
<a href="#n69" name="n69">69</a>
<strong><a href="#n70" name="n70">70</a></strong>
<a href="#n71" name="n71">71</a>
<a href="#n72" name="n72">72</a>
<a href="#n73" name="n73">73</a>
<a href="#n74" name="n74">74</a>
<a href="#n75" name="n75">75</a>
<a href="#n76" name="n76">76</a>
<a href="#n77" name="n77">77</a>
<a href="#n78" name="n78">78</a>
<a href="#n79" name="n79">79</a>
<strong><a href="#n80" name="n80">80</a></strong>
<a href="#n81" name="n81">81</a>
<a href="#n82" name="n82">82</a>
<a href="#n83" name="n83">83</a>
<a href="#n84" name="n84">84</a>
<a href="#n85" name="n85">85</a>
<a href="#n86" name="n86">86</a>
<a href="#n87" name="n87">87</a>
<a href="#n88" name="n88">88</a>
<a href="#n89" name="n89">89</a>
<strong><a href="#n90" name="n90">90</a></strong>
<a href="#n91" name="n91">91</a>
<a href="#n92" name="n92">92</a>
<a href="#n93" name="n93">93</a>
<a href="#n94" name="n94">94</a>
<a href="#n95" name="n95">95</a>
<a href="#n96" name="n96">96</a>
<a href="#n97" name="n97">97</a>
<a href="#n98" name="n98">98</a>
<a href="#n99" name="n99">99</a>
<strong><a href="#n100" name="n100">100</a></strong>
<a href="#n101" name="n101">101</a>
<a href="#n102" name="n102">102</a>
<a href="#n103" name="n103">103</a>
<a href="#n104" name="n104">104</a>
<a href="#n105" name="n105">105</a>
<a href="#n106" name="n106">106</a>
</pre></td>
  <td class="code"><pre><span style="color:#777">// Implement simple distributed LU decomposition using scalapack.</span>
<span style="color:#777">// This code uses a simple block distribution of data. Not block cyclic.</span>
<span style="color:#777">// author: Sameer Deshmukh (@v0dro)</span>

<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&quot;mpi.h&quot;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cstdlib&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cmath&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;iostream&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;fstream&gt;</span>
<span style="color:#088;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#088;font-weight:bold">extern</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">C</span><span style="color:#710">&quot;</span></span> {
  <span style="color:#777">/* Cblacs declarations */</span>
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pinfo(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_get(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridinit(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pcoord(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridexit(<span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_barrier(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*);
 
  <span style="color:#0a8;font-weight:bold">int</span> numroc_(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);

  <span style="color:#088;font-weight:bold">void</span> descinit_(<span style="color:#0a8;font-weight:bold">int</span> *desc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m,  <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *mb, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *irsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *icsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ictxt, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *lld, <span style="color:#0a8;font-weight:bold">int</span> *info);
  <span style="color:#088;font-weight:bold">void</span> pdgetrf_(
                <span style="color:#0a8;font-weight:bold">int</span> *m, <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#0a8;font-weight:bold">double</span> *a, <span style="color:#0a8;font-weight:bold">int</span> *ia, <span style="color:#0a8;font-weight:bold">int</span> *ja, <span style="color:#0a8;font-weight:bold">int</span> *desca,
                <span style="color:#0a8;font-weight:bold">int</span> *ipiv,<span style="color:#0a8;font-weight:bold">int</span> *info);
}

<span style="color:#088;font-weight:bold">void</span> print_arr(<span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#0a8;font-weight:bold">int</span> size, <span style="color:#0a8;font-weight:bold">string</span> desc, ostream &amp;o)
{
  o &lt;&lt; desc &lt;&lt; endl;
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; size; ++i) {
    o &lt;&lt; A[i] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
  }
  o &lt;&lt; endl;
}

<span style="color:#088;font-weight:bold">void</span> print_files(<span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#0a8;font-weight:bold">int</span> nrows, <span style="color:#0a8;font-weight:bold">int</span> ncols, <span style="color:#0a8;font-weight:bold">int</span> myrow, <span style="color:#0a8;font-weight:bold">int</span> mycol)
{
  <span style="color:#0a8;font-weight:bold">string</span> n = to_string(myrow*<span style="color:#00D">2</span> + mycol); 
  std::ofstream file;

  file.open(n + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">.txt</span><span style="color:#710">&quot;</span></span>);
  print_arr(A, nrows*ncols, n, file);
  file.close();
}

<span style="color:#0a8;font-weight:bold">int</span> main(<span style="color:#0a8;font-weight:bold">int</span> argc, <span style="color:#0a8;font-weight:bold">char</span> ** argv)
{
  <span style="color:#777">// MPI init</span>
  MPI_Init(&amp;argc, &amp;argv);
  <span style="color:#777">// end MPI Init</span>
  
  <span style="color:#777">// BLACS init</span>
  <span style="color:#0a8;font-weight:bold">int</span> BLACS_CONTEXT, proc_nrows, proc_ncols, myrow, mycol;
  <span style="color:#0a8;font-weight:bold">int</span> proc_id, num_procs;
  proc_nrows = <span style="color:#00D">2</span>; proc_ncols = <span style="color:#00D">2</span>;
  Cblacs_pinfo(&amp;proc_id, &amp;num_procs);
  Cblacs_get( -<span style="color:#00D">1</span>, <span style="color:#00D">0</span>, &amp;BLACS_CONTEXT );
  Cblacs_gridinit( &amp;BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Row</span><span style="color:#710">&quot;</span></span>, proc_nrows, proc_ncols );
  Cblacs_pcoord(BLACS_CONTEXT, proc_id, &amp;myrow, &amp;mycol);
  <span style="color:#777">// end BLACS init</span>

  <span style="color:#777">// matrix properties</span>
  <span style="color:#777">// mat size, blk size, portion of block per process</span>
  <span style="color:#0a8;font-weight:bold">int</span> N = <span style="color:#00D">8</span>, nb = <span style="color:#00D">4</span>, process_block_size = <span style="color:#00D">2</span>;
  <span style="color:#0a8;font-weight:bold">int</span> num_blocks_per_process = N/process_block_size;
  <span style="color:#0a8;font-weight:bold">int</span> block_size_per_process_r = sqrt(num_blocks_per_process);
  <span style="color:#0a8;font-weight:bold">int</span> block_size_per_process_c = sqrt(num_blocks_per_process);
  <span style="color:#0a8;font-weight:bold">double</span>* a = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);
  <span style="color:#777">// generate matrix data</span>
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#0a8;font-weight:bold">int</span> index = i + j*nb;
      <span style="color:#0a8;font-weight:bold">int</span> row_i = myrow*nb + i;
      <span style="color:#0a8;font-weight:bold">int</span> col_j = mycol*nb + j;
      a[index] = row_i + col_j*N;
    }
    cout &lt;&lt; endl;
  }
  <span style="color:#777">// end matrix properties</span>

  <span style="color:#777">// create array descriptor</span>
  <span style="color:#0a8;font-weight:bold">int</span> desca[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> rsrc = <span style="color:#00D">0</span>, csrc = <span style="color:#00D">0</span>, info;
  descinit_(desca, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  <span style="color:#777">// end create array descriptor</span>

  Cblacs_barrier(BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">All</span><span style="color:#710">&quot;</span></span>);

  <span style="color:#777">// LU decomposition</span>
  <span style="color:#0a8;font-weight:bold">int</span> ia = <span style="color:#00D">1</span>, ja = <span style="color:#00D">1</span>;
  <span style="color:#0a8;font-weight:bold">int</span> *ipiv = (<span style="color:#0a8;font-weight:bold">int</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">int</span>)*N);
  pdgetrf_(&amp;N, &amp;N, a, &amp;ia, &amp;ja, desca, ipiv, &amp;info);
  <span style="color:#777">// end LU decomposition</span>

  print_files(a, nb, nb, myrow, mycol);
  <span style="color:#080;font-weight:bold">if</span> (myrow == <span style="color:#00D">0</span> &amp;&amp; mycol == <span style="color:#00D">0</span>) {
    <span style="color:#080;font-weight:bold">for</span>(<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; N; ++i) {
      cout &lt;&lt; ipiv[i] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
    }
  }
  MPI_Finalize();
}
</pre></td>
</tr></table>
</div>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://software.intel.com/en-us/forums/intel-math-kernel-library/topic/288028">Intel Q and A on numroc</a></li>
  <li><a href="http://www.netlib.org/scalapack/explore-html/d4/d48/numroc_8f_source.html">Numroc fortran docs</a></li>
  <li><a href="https://software.intel.com/en-us/articles/using-cluster-mkl-pblasscalapack-fortran-routine-in-your-c-program">Using PBLAS/ScaLAPACK in your C code by intel (MKL specific)</a></li>
</ul>

