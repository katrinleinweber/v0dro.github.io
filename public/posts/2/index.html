
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Travel &lt;code&gt; Music</title>
  <meta name="author" content="Sameer Deshmukh">

  
  <meta name="description" content="
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://v0dro.github.io/posts/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Travel &lt;code&gt; Music" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-55005305-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$', '$'], ["\(", "\)"] ],
        displayMath: [ ['$$', '$$'], ["\[", "\]"] ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
      //,
      //displayAlign: "left",
      //displayIndent: "2em"
    });
  </script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Travel &lt;code&gt; Music</a></h1>
  
    <h2>A place where I share my experiences with Travel, Programming and Music</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="v0dro.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/archives">Archive</a></li>
  <li><a href="/travel">Travel</a></li>
  <li><a href="/code">Code</a></li>
  <li><a href="/music">Music</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/04/07/binding-c-structs-to-ruby-objects-using-rubex/">Binding C Structs to Ruby Objects Using Rubex.</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/04/05/distributed-matrix-multiplication-using-pblas-and-blacs/">Distributed Matrix Multiplication Using PBLAS and BLACS.</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>PBLAS (or Parallel BLAS) is a parallel version of BLAS that use BLACS internally for
parallel computing. It expects the matrix to be already distributed among processors
before it starts computing. You first create the data in each process and then provide 
PBLAS with information that will help it determine how exactly the matrix is distributed.
Each process can access only its local data.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#array-descriptor">Array descriptor</a></li>
  <li><a href="#multiplication-function-description">Multiplication function description</a></li>
  <li><a href="#full-code">Full code</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="array-descriptor">Array descriptor</h1>

<p>You also need to define an ‘array descriptor’ for the matrix that you are working on. 
The array descriptor is an integer array of length 9 that contains the following data:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> array_desc[<span style="color:#00D">9</span>] = {
    dtype,   <span style="color:#777">// descriptor type (=1 for dense matrix)</span>
    context, <span style="color:#777">// BLACS context handle for process grid</span>
    m,       <span style="color:#777">// num of rows in the global array</span>
    n,       <span style="color:#777">// num of cols in the global array</span>
    mb,      <span style="color:#777">// num of rows in a block</span>
    nb,      <span style="color:#777">// num of cols in a block</span>
    rsrc,    <span style="color:#777">// process row over which first row of the global array is distributed</span>
    csrc,    <span style="color:#777">// process col over which first col of the global array is distributed</span>
    lld      <span style="color:#777">// leading dimension of the local array</span>
}
</pre></td>
</tr></table>
</div>

<p>Although you can do it yourself, using the <code>descinit</code> function for initializing the array descriptor is a good way to keep the code clean. This function looks as follows:</p>
<pre><code>void descinit_ (
    int *desc, 
    const int *m, 
    const int *n, 
    const int *mb, 
    const int *nb, 
    const int *irsrc, 
    const int *icsrc, 
    const int *ictxt, 
    const int *lld, 
    int *info
);
</code></pre>

<h1 id="multiplication-function-description">Multiplication function description</h1>

<p>According to PBLAS conventions, the global matrix can be denoted by <code>A</code> and the 
block of matrix possessed by the particlar process as <code>sub(A)</code>. The number of
rows and columns of a global dense matrix that a particular process in a grid
receives after data distributing is denoted by <code>LOCr()</code> and <code>LOCc()</code>, respectively.
To compute these numbers, you can use the ScaLAPACK tool routine <code>numroc</code>.</p>

<p>To explain with example, see the prototype of the <code>pdgemm</code> routine 
(<a href="https://software.intel.com/en-us/mkl-developer-reference-c-p-gemm#5258C6E6-D85C-4E79-A64C-A45F300B0C3C">intel</a> resource):</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> pdgemm_(
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span> *transa ,  <span style="color:#777">// (g) form of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span> *transb ,  <span style="color:#777">// (g) form of sub(B)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m ,        <span style="color:#777">// (g) number of rows of sub(A) and sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n ,        <span style="color:#777">// (g) number of cols of sub(B) and sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *k ,        <span style="color:#777">// (g) Number of cols of sub(A) and rows of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *alpha , <span style="color:#777">// (g) scalar alpha</span>
    <span style="color:#777">// array that contains local pieces of distributed matrix sub(A). size lld_a by kla.</span>
    <span style="color:#777">//   kla is LOCq(ja+m-1) for C code (transposed).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *a ,     <span style="color:#777">// (l)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ia ,       <span style="color:#777">// (g) row index in the distributed matrix A indicating first row of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ja ,       <span style="color:#777">// (g) col index in the distributed matrix A indicating first col of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *desca ,    <span style="color:#777">// (g &amp; l)array of dim 9. Array descriptor of A.</span>
    <span style="color:#777">// array that contains local pieces of dist matrix sub(B). size lld_b by klb.</span>
    <span style="color:#777">//   klb is LOCq(jb+k-1) for C code (transposed).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *b ,     <span style="color:#777">// (l)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ib ,       <span style="color:#777">// (g) row index of dist matrix B indicating first row of sub(B)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *jb ,       <span style="color:#777">// (g) col index of dist matrix B indicating first col of sub(B)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *descb ,    <span style="color:#777">// (g &amp; l) array desc of matrix B (dim 9).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *beta ,  <span style="color:#777">// (g) scalar beta</span>
    <span style="color:#0a8;font-weight:bold">double</span> *c ,           <span style="color:#777">// (l) Array of size (lld_a, LOCq(jc+n-1)). contains sub(C) pieces.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ic ,       <span style="color:#777">// (g) row index of dist matrix C indicating first row of sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *jc ,       <span style="color:#777">// (g) col index of dist matrix C indicating first col of sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *descc      <span style="color:#777">// (g &amp; l) array of dim 9. Array desc of C.</span>
)
</pre></td>
</tr></table>
</div>
<p>The above function looks very similar to non-parallel <code>dgemm</code> from BLAS, with
additions for making it easy to find elements in a parallel scenario. Keep in
mind that there are some arguments that refer to the global array properties
and some that refer to the local array properties.</p>

<p>A function called <code>numroc</code> from ScaLAPACK is useful for determining how many
rows or cols of the global matrix are present in a particular process. The 
prototype looks as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> numroc_(
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n,       <span style="color:#777">// (g) number of rows/cols in dist matrix (global matrix).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb,      <span style="color:#777">// (g input) block size. (must be square blocks)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *iproc,   <span style="color:#777">// (l input) co-ordinate of process whole local array row/col is to be determined.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *srcproc, <span style="color:#777">// (g input) co-ordinate of the process that contains the frist row or col of the dist matrix.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nprocs   <span style="color:#777">// (g input) total number of processes.</span>
)
</pre></td>
</tr></table>
</div>

<p>When compiling these functions, don’t forget to link with the <code>-lgfortran</code> flag.</p>

<h1 id="full-code">Full code</h1>

<p>A simple implementation of matrix multiplication using BLACS and PBLAS:</p>

<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
<a href="#n63" name="n63">63</a>
<a href="#n64" name="n64">64</a>
<a href="#n65" name="n65">65</a>
<a href="#n66" name="n66">66</a>
<a href="#n67" name="n67">67</a>
<a href="#n68" name="n68">68</a>
<a href="#n69" name="n69">69</a>
<strong><a href="#n70" name="n70">70</a></strong>
<a href="#n71" name="n71">71</a>
<a href="#n72" name="n72">72</a>
<a href="#n73" name="n73">73</a>
<a href="#n74" name="n74">74</a>
<a href="#n75" name="n75">75</a>
<a href="#n76" name="n76">76</a>
<a href="#n77" name="n77">77</a>
<a href="#n78" name="n78">78</a>
<a href="#n79" name="n79">79</a>
<strong><a href="#n80" name="n80">80</a></strong>
<a href="#n81" name="n81">81</a>
<a href="#n82" name="n82">82</a>
<a href="#n83" name="n83">83</a>
<a href="#n84" name="n84">84</a>
<a href="#n85" name="n85">85</a>
<a href="#n86" name="n86">86</a>
<a href="#n87" name="n87">87</a>
<a href="#n88" name="n88">88</a>
<a href="#n89" name="n89">89</a>
<strong><a href="#n90" name="n90">90</a></strong>
<a href="#n91" name="n91">91</a>
<a href="#n92" name="n92">92</a>
<a href="#n93" name="n93">93</a>
<a href="#n94" name="n94">94</a>
<a href="#n95" name="n95">95</a>
<a href="#n96" name="n96">96</a>
<a href="#n97" name="n97">97</a>
<a href="#n98" name="n98">98</a>
<a href="#n99" name="n99">99</a>
<strong><a href="#n100" name="n100">100</a></strong>
<a href="#n101" name="n101">101</a>
<a href="#n102" name="n102">102</a>
<a href="#n103" name="n103">103</a>
<a href="#n104" name="n104">104</a>
<a href="#n105" name="n105">105</a>
<a href="#n106" name="n106">106</a>
<a href="#n107" name="n107">107</a>
<a href="#n108" name="n108">108</a>
<a href="#n109" name="n109">109</a>
<strong><a href="#n110" name="n110">110</a></strong>
<a href="#n111" name="n111">111</a>
<a href="#n112" name="n112">112</a>
<a href="#n113" name="n113">113</a>
<a href="#n114" name="n114">114</a>
<a href="#n115" name="n115">115</a>
<a href="#n116" name="n116">116</a>
<a href="#n117" name="n117">117</a>
<a href="#n118" name="n118">118</a>
<a href="#n119" name="n119">119</a>
<strong><a href="#n120" name="n120">120</a></strong>
<a href="#n121" name="n121">121</a>
<a href="#n122" name="n122">122</a>
<a href="#n123" name="n123">123</a>
<a href="#n124" name="n124">124</a>
<a href="#n125" name="n125">125</a>
<a href="#n126" name="n126">126</a>
<a href="#n127" name="n127">127</a>
<a href="#n128" name="n128">128</a>
<a href="#n129" name="n129">129</a>
<strong><a href="#n130" name="n130">130</a></strong>
<a href="#n131" name="n131">131</a>
<a href="#n132" name="n132">132</a>
<a href="#n133" name="n133">133</a>
<a href="#n134" name="n134">134</a>
<a href="#n135" name="n135">135</a>
</pre></td>
  <td class="code"><pre><span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&quot;mpi.h&quot;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;iostream&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cstdlib&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cmath&gt;</span>
<span style="color:#088;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#088;font-weight:bold">extern</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">C</span><span style="color:#710">&quot;</span></span> {
  <span style="color:#777">/* Cblacs declarations */</span>
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pinfo(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_get(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridinit(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pcoord(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridexit(<span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_barrier(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*);
 
  <span style="color:#0a8;font-weight:bold">int</span> numroc_(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);

  <span style="color:#088;font-weight:bold">void</span> descinit_(<span style="color:#0a8;font-weight:bold">int</span> *desc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m,  <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *mb, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *irsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *icsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ictxt, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *lld, <span style="color:#0a8;font-weight:bold">int</span> *info);

  <span style="color:#088;font-weight:bold">void</span> pdgemm_( <span style="color:#0a8;font-weight:bold">char</span>* TRANSA, <span style="color:#0a8;font-weight:bold">char</span>* TRANSB,
                <span style="color:#0a8;font-weight:bold">int</span> * M, <span style="color:#0a8;font-weight:bold">int</span> * N, <span style="color:#0a8;font-weight:bold">int</span> * K,
                <span style="color:#0a8;font-weight:bold">double</span> * ALPHA,
                <span style="color:#0a8;font-weight:bold">double</span> * A, <span style="color:#0a8;font-weight:bold">int</span> * IA, <span style="color:#0a8;font-weight:bold">int</span> * JA, <span style="color:#0a8;font-weight:bold">int</span> * DESCA,
                <span style="color:#0a8;font-weight:bold">double</span> * B, <span style="color:#0a8;font-weight:bold">int</span> * IB, <span style="color:#0a8;font-weight:bold">int</span> * JB, <span style="color:#0a8;font-weight:bold">int</span> * DESCB,
                <span style="color:#0a8;font-weight:bold">double</span> * BETA,
                <span style="color:#0a8;font-weight:bold">double</span> * C, <span style="color:#0a8;font-weight:bold">int</span> * IC, <span style="color:#0a8;font-weight:bold">int</span> * JC, <span style="color:#0a8;font-weight:bold">int</span> * DESCC );
}


<span style="color:#0a8;font-weight:bold">int</span> main(<span style="color:#0a8;font-weight:bold">int</span> argc, <span style="color:#0a8;font-weight:bold">char</span> ** argv)
{
  <span style="color:#777">// MPI init</span>
  MPI_Init(&amp;argc, &amp;argv);
  <span style="color:#0a8;font-weight:bold">int</span> mpi_rank, mpi_size;
  MPI_Comm_rank(MPI_COMM_WORLD, &amp;mpi_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &amp;mpi_size);
  <span style="color:#777">// end MPI init</span>

  <span style="color:#777">// BLACS init</span>
  <span style="color:#0a8;font-weight:bold">int</span> BLACS_CONTEXT, proc_nrows, proc_ncols, myrow, mycol;
  <span style="color:#0a8;font-weight:bold">int</span> proc_id, num_procs;
  proc_nrows = <span style="color:#00D">2</span>; proc_ncols = <span style="color:#00D">2</span>;
n  <span style="color:#777">//int proc_dims[2] = {proc_nrows, proc_ncols};</span>
  Cblacs_pinfo(&amp;proc_id, &amp;num_procs);
  Cblacs_get( -<span style="color:#00D">1</span>, <span style="color:#00D">0</span>, &amp;BLACS_CONTEXT );
  Cblacs_gridinit( &amp;BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Row</span><span style="color:#710">&quot;</span></span>, proc_nrows, proc_ncols );
  Cblacs_pcoord(BLACS_CONTEXT, mpi_rank, &amp;myrow, &amp;mycol);
  cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">myrow </span><span style="color:#710">&quot;</span></span> &lt;&lt; myrow &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> mycol </span><span style="color:#710">&quot;</span></span> &lt;&lt; mycol &lt;&lt; endl;
  cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">procid </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> num_procs </span><span style="color:#710">&quot;</span></span> &lt;&lt; num_procs &lt;&lt; endl;
  <span style="color:#777">// end BLACS init</span>

  <span style="color:#777">// matrix properties</span>
  <span style="color:#0a8;font-weight:bold">int</span> N = <span style="color:#00D">8</span>, nb = <span style="color:#00D">4</span>; <span style="color:#777">// mat size, blk size.</span>
  <span style="color:#0a8;font-weight:bold">double</span>* a = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);
  <span style="color:#0a8;font-weight:bold">double</span>* b = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);
  <span style="color:#0a8;font-weight:bold">double</span>* c = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);

  <span style="color:#777">// generate matrix data</span>
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb*nb; ++i) {
    a[i] = <span style="color:#00D">1</span>;
    b[i] = <span style="color:#00D">2</span>;
    c[i] = <span style="color:#00D">0</span>;
  }
  <span style="color:#777">// end matrix properties</span>

  <span style="color:#777">// create array descriptor</span>
  <span style="color:#0a8;font-weight:bold">int</span> desca[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> descb[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> descc[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> rsrc = <span style="color:#00D">0</span>, csrc = <span style="color:#00D">0</span>, info;
  descinit_(desca, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  descinit_(descb, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  descinit_(descc, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  cout &lt;&lt; proc_id &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> info: </span><span style="color:#710">&quot;</span></span> &lt;&lt; info &lt;&lt; endl;
  <span style="color:#777">// end create array descriptor</span>
  
  Cblacs_barrier(BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">All</span><span style="color:#710">&quot;</span></span>);
  <span style="color:#0a8;font-weight:bold">int</span> ia = <span style="color:#00D">1</span>, ja = <span style="color:#00D">1</span>, ib = <span style="color:#00D">1</span>, jb = <span style="color:#00D">1</span>, ic = <span style="color:#00D">1</span>, jc = <span style="color:#00D">1</span>;
  <span style="color:#0a8;font-weight:bold">double</span> alpha = <span style="color:#00D">1</span>, beta = <span style="color:#00D">1</span>;
  pdgemm_(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">T</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">T</span><span style="color:#710">&quot;</span></span>, &amp;N, &amp;N, &amp;N, &amp;alpha, a, &amp;ia, &amp;ja, desca, b, &amp;ib, &amp;jb, descb,
          &amp;beta, c, &amp;ic, &amp;jc, descc);

  <span style="color:#777">// print results on a per-process basis</span>
  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">0</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">1</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">2</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">3</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  MPI_Finalize();
}
</pre></td>
</tr></table>
</div>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="http://www.netlib.org/utk/papers/pblas/node20.html">Use of PBLAS from netlib.</a></li>
  <li><a href="https://www.ibm.com/support/knowledgecenter/en/SSNR5K_5.1.0/com.ibm.cluster.pessl.v5r1.pssl100.doc/am6gr_lnumroc.htm">numroc IBM explanation.</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/04/05/reading-block-cyclic-matrices-using-mpi-io-c-interface/">Reading Block Cyclic Matrices Using MPI-IO C Interface.</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://stackoverflow.com/questions/10341860/mpi-io-reading-and-writing-block-cyclic-matrix#_=_">This</a> answer on stack overflow is pretty detailed for this purpose. Since the answer is in FORTRAN, I’ll explain with some C code and how I went about this.</p>

<p>A very cumbersome way of reading a row-major matrix from a file into an MPI process is to read individual chunks one by one in a block cyclic manner in a loop. A better way is to use the <a href="https://www.mpich.org/static/docs/v3.1/www3/MPI_Type_create_darray.html">MPI darray type</a> that is useful for reading chunks of the file directly without writing too much code. MPI lets you define a ‘view’ of a file and each process can just read its part of the view. It lets you define “distributed array” data types which you can use for directly reading a matrix stored in a file into memory in a block cyclic manner accoridng to the co-ordinates of the processor. We use the <code>MPI_Type_create_darray</code> <a href="http://mpi.deino.net/mpi_functions/MPI_Type_create_darray.html">function</a> for this purpose.</p>

<p>Here’s a sample usage of this function for initializing a <code>MPI_darray</code>:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
</pre></td>
  <td class="code"><pre>MPI_Status status;
MPI_Datatype MPI_darray;
<span style="color:#0a8;font-weight:bold">int</span> N = <span style="color:#00D">8</span>, nb = <span style="color:#00D">4</span>;
<span style="color:#0a8;font-weight:bold">int</span> dims[<span style="color:#00D">2</span>] = {N, N};
<span style="color:#0a8;font-weight:bold">int</span> distribs[<span style="color:#00D">2</span>] = {MPI_DISTRIBUTE_CYCLIC, MPI_DISTRIBUTE_CYCLIC};
<span style="color:#0a8;font-weight:bold">int</span> dargs[<span style="color:#00D">2</span>] = {nb, nb};
<span style="color:#0a8;font-weight:bold">int</span> proc_nrows = <span style="color:#00D">2</span>, proc_ncols = <span style="color:#00D">2</span>;
<span style="color:#0a8;font-weight:bold">int</span> proc_dims[<span style="color:#00D">2</span>] = {proc_nrows, proc_ncols};

MPI_Type_create_darray(
    num_procs, <span style="color:#777">// size of process group (positive integer)</span>
    proc_id, <span style="color:#777">// rank in process group (non-negative integer)</span>
    <span style="color:#00D">2</span>, <span style="color:#777">//         number of array dimensions as well as process grid dimensions (positive integer)</span>
    dims, <span style="color:#777">// number of elements of type oldtype in each dimension of global array (array of positive integers)</span>
    distribs, <span style="color:#777">// distribution of array in each dimension (array of state)</span>
    dargs, <span style="color:#777">// distribution argument in each dimension (array of positive integers)</span>
    proc_dims, <span style="color:#777">// size of process grid in each dimension (array of positive integers)</span>
    MPI_ORDER_C, <span style="color:#777">// array storage order flag (state)</span>
    MPI_INT, <span style="color:#777">// old datatype (handle)</span>
    &amp;MPI_darray <span style="color:#777">// new datatype (handle)</span>
);
MPI_Type_commit(&amp;MPI_darray);
MPI_Type_size(MPI_darray, &amp;darray_size);
nelements = darray_size / <span style="color:#00D">4</span>;
MPI_Type_get_extent(MPI_darray, &amp;lower_bound, &amp;darray_extent);
</pre></td>
</tr></table>
</div>

<p>For reading a file in MPI, you need to use the <code>MPI_File_*</code> functions. This involves opening the file like any other normal file, but that file is handled internally by MPI. You need to set a ‘view’ for the file for each MPI process, and then the process can ‘seek’ the appropriate location in the file and read the required data.</p>

<p>The following code in useful for this purpose:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>
</pre></td>
</tr></table>
</div>

<p>Sometimes reading from files can give divide-by-zero errors,</p>

<p>Note on <code>MPI_File_set_view</code>: this function is used for setting a ‘file view’ for each process so that the process knows where to start the data reading from. In case you’re using <code>MPI_File_read_all</code> you should know that the file pointer is set implicitly and you don’t need to explicitly supply an offset value. The file pointer for the current view is set based on what the process previous to this process accessed.</p>

<p>A full program for performing a matrix multiplication using PBLAS and BLACS using a block cyclic data distribution can be found <a href="">here</a>. Some more docs are <a href="http://mpi-forum.org/docs/mpi-2.2/mpi22-report/node73.htm">here</a>.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/04/04/debugging-mpi-programs-with-gdb/">Debugging MPI Programs With GDB</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>When programming with MPI you might get run time errors like segfaults due to faulty IO programming or the like.</p>

<p>Since you’re programming in a distributed environment, using gdb with MPI programs is a bit of a challenge, but is quite possible and reasonalbly easy to use as well. All you need to do is use the <code>mpirun</code> command with gdb in the following manner:</p>
<pre><code>mpirun -np &lt;num_processes&gt; xterm -e gdb ./a.out
</code></pre>

<p>A modified Makefile using the above command would look like so:</p>
<pre><code>mpi_debug: mpi_types.o $(SOURCES)
	$(CXX) $? -llapacke -llapack -lcblas
    mpirun -np 2 xterm -e gdb ./a.out
</code></pre>

<p>You can then call <code>run</code> inside gdb for each process. <a href="https://stackoverflow.com/questions/329259/how-do-i-debug-an-mpi-program">This stackoverflow answer</a> provides more insights into this.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/03/30/notes-on-learning-fortran/">Notes on Learning FORTRAN</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>I’ve been trying to understand the distributed <a href="http://people.eecs.berkeley.edu/~demmel/cs267/lecture12/pdgetrf.f">block LU code written in ScaLAPACK</a>, which is written in FORTRAN. In order to understand the algorithms properly I took a 30 min crash course in FORTRAN. In this blog post I’ll write some details about the language that are relevant to understanding the ScaLAPACK code.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#learning-resources">Learning resources</a></li>
  <li><a href="#salient-fortran-features">Salient FORTRAN features</a>
    <ul>
      <li><a href="#program-structure">Program structure</a></li>
      <li><a href="#printing">Printing</a></li>
    </ul>
  </li>
  <li><a href="#fortran-wrt-scalapack">FORTRAN w.r.t ScaLAPACK</a>
    <ul>
      <li><a href="#subroutines-and-functions">Subroutines and functions</a></li>
      <li><a href="#arrays">Arrays</a></li>
      <li><a href="#logical-and-comparison-expressions">Logical and comparison expressions</a></li>
      <li><a href="#loops">Loops</a></li>
    </ul>
  </li>
</ul>

<!-- markdown-toc end -->

<h1 id="learning-resources">Learning resources</h1>

<ul>
  <li><a href="https://www.tutorialspoint.com/fortran/index.htm">Fortran tutorial on tutorialspoint</a>.</li>
  <li><a href="https://www.fortrantutorial.com/">Fortran tutorial website</a>.</li>
  <li><a href="http://www.chem.ox.ac.uk/fortran/subprograms.html">Functions and subroutines</a>.</li>
  <li><a href="http://pages.mtu.edu/~shene/COURSES/cs201/NOTES/F90-Basics.pdf">Presentation on F90 basics</a>.</li>
  <li><a href="http://www.fortran.com/fortran_storenew/Html/Info/books/gd3_c04_1.html">Fortran Arrays</a>.</li>
  <li><a href="http://www.pcc.qub.ac.uk/tec/courses/f90/stu-notes/F90_notesMIF_6.html">Logical and comparison expressions</a>.</li>
</ul>

<h1 id="salient-fortran-features">Salient FORTRAN features</h1>

<p>Here’s a simple addition program:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
</pre></td>
  <td class="code"><pre>program addNumbers

! This simple program adds two numbers. This is a comment.
   implicit none
   
! Type declarations
   real :: a, b, result 
   
! Executable statements 
   a = 12.0
   b = 15.0
   result = a + b
   print *, 'The total is ', result
   
end program addNumbers 
</pre></td>
</tr></table>
</div>

<p>Each program begins with keyword <code>program &lt;prog_name&gt;</code> and ends with <code>end program &lt;prog_name&gt;</code>.</p>

<p>A statement <code>implicit none</code> allows the compiler to check whether all variable types are declared correctly. This statement must be there to check if types have been declared correctly.</p>

<h2 id="program-structure">Program structure</h2>

<p>A full program should be kept inside a <code>program</code> statement. A simple ‘hello world!’ program
looks like so:</p>
<pre><code>program hello
  implicit none

  print*,"Hello"
  print*,"World!"
end program
</code></pre>

<h2 id="printing">Printing</h2>

<p>Write to standard output using the <code>print</code> statement.</p>

<p>Link: https://en.wikibooks.org/wiki/Fortran/Fortran_simple_input_and_output</p>

<p>Printing multi-dimensional arrays can be tricky since the <code>print</code> statement by
default outputs newlines after each printing. Here’s a link that explains how
to print 2d arrays in fortran using <code>write</code>:</p>

<p>Link: https://jblevins.org/log/array-write</p>

<p>If you want to use format specifiers with floating point numbers, read below link:</p>

<p>Link: https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</p>

<h1 id="fortran-wrt-scalapack">FORTRAN w.r.t ScaLAPACK</h1>

<h2 id="subroutines-and-functions">Subroutines and functions</h2>

<p>I will now explain the <code>pdgetrf</code> routine from ScaLAPACK.</p>

<p>The <code>SUBROUTINE</code> keyword is used for defining subroutines. For example:</p>
<pre><code>SUBROUTINE PDGETRF( M, N, A, IA, JA, DESCA, IPIV, INFO )
</code></pre>
<p>Types of arguments to subroutines are defined in the subroutine definition itself. For example, in scalapack:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre>*     .. Scalar Arguments ..
      INTEGER            IA, INFO, JA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            DESCA( * ), IPIV( * )
      DOUBLE PRECISION   A( * )
</pre></td>
</tr></table>
</div>

<p>Unlike in C, the argument types are not declared alongwith the  name and argument list.</p>

<p>Functions and subroutines are different in FORTRAN. The main difference lies in the fact that functions can be used in an expression and can return only one value (exactly like functions in C or Java). A subroutine on the other hand, cannot be used in expressions, but has the advantage that it can be used for returning multiple values. In the respect of returning multiple values it is somewhat similar to MATLAB functions.</p>

<p>A subroutine ends with the <code>RETURN</code> and <code>END</code> statement. The arguements passed to a subroutine are similar to call by reference in the case of C. If you modify any value inside the subroutine, the value will be modified in the calling function too.</p>

<p>In order to tell the compiler the return value of a function, you must use the name of the function in an assignment statement that will tell the compiler the value to be returned. For example:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre> REAL FUNCTION AVRAGE(X,Y,Z)
     REAL X,Y,Z,SUM
     SUM = X + Y + Z
     AVRAGE = SUM /3.0
 RETURN
 END
</pre></td>
</tr></table>
</div>

<h2 id="arrays">Arrays</h2>

<p>Arrays are used/declared in a similar manner to C. For example, to declare an array:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>INTEGER            IDUM1( 1 ), IDUM2( 1 )
</pre></td>
</tr></table>
</div>
<p>Array elements can be accessed using round brackets:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>ICTXT = DESCA( 7 )
</pre></td>
</tr></table>
</div>

<p>By default, arrays in fortran begin from index <code>1</code>.</p>

<p>One can also specify the <code>kind</code> parameter in the array to tell the compiler which of its suppported
kinds it should use.</p>

<p>Multi-dimensional arrays are referenced in their indexing the same way as C arrays <code>(row, col)</code> but
the internal storage is of course column major. See the second link below.</p>

<p>Link:</p>
<ul>
  <li>https://stackoverflow.com/questions/838310/fortran-90-kind-parameter</li>
  <li>https://www.obliquity.com/computer/fortran/array.html</li>
</ul>

<h2 id="logical-and-comparison-expressions">Logical and comparison expressions</h2>

<p>Logical and comparison operators are written enclosed in dots. So <code>&amp;&amp;</code> in C is
<code>.AND.</code> in fortran. Similarly, <code>!=</code> is <code>.NE.</code>.</p>

<h2 id="loops">Loops</h2>

<p>Fortran has a curious way of writing loops, given that I’m coming from the C world. 
Loops are written using the <code>do-continue</code> syntax. Each loop statement in a program 
requires a statement label. Any label number can be used but the <code>do</code> and <code>continue</code>
of a single block must have the same label.</p>

<p>The variable that is defined in the line of the <code>do</code> block is the counter variable.
Its default step is <code>1</code> but you can change that as you want.</p>

<p>The general form is:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>do label var =  expr1, expr2, expr3
  ! statements
label continue
</pre></td>
</tr></table>
</div>

<p>In the above loop, <code>var</code> is the loop variable (this must be an integer). <code>expr1</code>
specifies the initial value of <code>var</code>, <code>expr2</code> is the terminating bound, and 
<code>expr3</code> is the increment (step).</p>

<p>Many Fortran 77 compilers allow <code>do</code>-loops to be closed by the <code>enddo</code> 
statement. The advantage of this is that the statement label can then be omitted
since it is assumed that an <code>enddo</code> closes the nearest previous do statement. 
The <code>enddo</code> construct is widely used, but it is not a part of ANSI Fortran 77.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/03/26/notes-on-learning-emacslisp/">Notes on Learning Emacslisp</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>Recently, I started development of an emacs language mode called <a href="https://github.com/v0dro/rubex-mode-emacs">rubex-mode</a> for supporting Rubex syntax highlighting in emacs. This took me to the <a href="https://www.emacswiki.org/emacs/ModeTutorial">ModeTutorial</a> on the emacs wiki, which is a very detailed tutorial for learning how to write new emacs language modes. Before starting the tutorial I had no knowledge of Emacslisp or writing emacs language modes.</p>

<p>In this post I will share some of the important things that I learned about Emacslisp and some things that I think are important about writing language modes for Emacs.</p>

<h1 id="learning-resources">Learning resources</h1>

<ul>
  <li><a href="https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html">Learn emacs lisp in 15 minutes</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/">Programming in Emacs Lisp</a></li>
  <li><a href="https://emacs.stackexchange.com/questions/715/how-to-know-when-or-when-not-to-use-the-single-quote-before-variable-names">How to know whether to use single quote in elisp.</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">Quote in elisp</a></li>
</ul>

<h1 id="emacs-lisp-basics">Emacs lisp basics</h1>

<h2 id="lisp-evaluation">Lisp evaluation</h2>

<p>If you enable ‘lisp-interaction-mode’ in emacs you can evaluate lisp using the <code>C-j</code> shortcut. That will insert the result of the evaluation in the buffer. <code>C-x C-e</code> displays the same result in the minibuffer.</p>

<h2 id="sexps">Sexps</h2>

<p>Programs are made of symbolic expressions (pre-fix notation), like <code>(+ 2 2)</code>, this means ‘2 + 2’.</p>

<p>Expressions are made of atomic expressions or more symbolic expressions. In <code>(+ 2 (+ 1 1))</code>, 1 and 2 are atoms, (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.</p>

<h2 id="getting-and-setting-variables">Getting and setting variables</h2>

<p><code>setq</code> stores a value into a variable:</p>
<div class="language-elisp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>(setq my-name &quot;sameer&quot;)
</pre></td>
</tr></table>
</div>

<p>Variables can also be initialized using <code>defvar</code>. The emacswiki page is <a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/defvar.html">here</a>. <code>defvar</code> is similar to <code>setq</code>, but the difference is that <code>defvar</code> will not set the variable if it already has a value.</p>

<h2 id="setting-global-constants">Setting global constants</h2>

<p>The <code>defconst</code> keyword is used for setting global constants. It informs a person reading your code that symbol has a standard global value, established here, that should not be changed by the user or by other programs. Note that symbol is not evaluated; the symbol to be defined must appear explicitly in the defconst.</p>

<p>For example:</p>
<pre><code>(defconst pi 3.141592653589793 "The value of Pi.")
</code></pre>
<p>Above code initializes the variable <code>pi</code> to a value and sets a docstring.</p>

<h2 id="functions">Functions</h2>

<p>Functions can be defined using the <code>defun</code> keyword. For example, to defined a function <code>hello</code> that accepts an argument <code>name</code> and inserts the variable with a string on the buffer:</p>
<pre><code>(defun hello (name) (insert "Hello " name))
</code></pre>

<p>Fun fact: when evaluating elisp in a buffer, place the cursor at the bottom of the file otherwise emacs will only evaluate code until the cursor and throw unexpected output.</p>

<h2 id="combining-expressions">Combining expressions</h2>

<p>You can use the <code>progn</code> form for evaluating a set of expressions one by one and returning the value of the last one. The preceding expressions are only evaluated for their side effects and their values are discarded.</p>

<p>All emacs commands are basically just elisp function calls. So you can call something like this:</p>
<pre><code>(progn
  (switch-to-buffer-other-window "*scratch*")
  (hello "you"))
</code></pre>
<p>And it will switch the active window to the <code>*scratch*</code> buffer and print <code>Hello you</code> in the buffer.</p>

<p>A value can be bound to a local variable using <code>let</code>. This command can also be used for combining several sexps.</p>
<pre><code>(let ((local-name "you"))
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello local-name))
</code></pre>

<h2 id="quote">Quote</h2>

<p><code>quote</code> is a special form in elisp that returns its single argument, without 
evaluating it. This provides a way to include constants and lists, which are not 
self-evaluating objects, in a program. This <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">link</a> talks about it in detail.</p>

<p>Its used so often that a short form of using a single quote is often used instead (<code>'</code>). This <a href="https://emacs.stackexchange.com/questions/715/how-to-know-when-or-when-not-to-use-the-single-quote-before-variable-names">answer</a> talks in detail about when to and when not to use it.</p>

<p>In general, if you are trying to use the variable itself, use the quoted form, otherwise directly use the variable name. For example, in the expression <code>(mapcar 'hello list-of-names)</code>, we use a quoted <code>hello</code> because don’t actually want to call the function, we just want to pass a reference to it to the <code>mapcar</code> function which will then call <code>hello</code> at its own leisure.</p>

<h2 id="lists">Lists</h2>

<p>A list of names can be stored like so:</p>
<pre><code>(setq list-of-names '("Sarah" "Chloe" "Mathilde"))
</code></pre>

<p>The above expression is quoted because we want to set the whole expression as a list to <code>list-of-names</code>.</p>

<p>Use the <code>car</code> function for getting the first element of the list and <code>cdr</code> for getting all elements except the first element.</p>

<h3 id="cons-cells">Cons cells</h3>

<p>Lists are composed of cons cells. Each cons cell is a tuple of two lisp objects,
the <code>car</code> and <code>cdr</code>. In the case of a list, the first slot of a cons cell holds 
the element of the list and the next part chains to the next element of the list. 
The cdr of the last cell of the list is <code>nil</code>. This helps in detecting the end 
of a list.</p>

<h2 id="dotted-pair-notation">Dotted pair notation</h2>

<p>A dotted pair notation is a general syntax for creating cons cells that represents
the car and cdr explicitly.  In this syntax, <code>(a . b)</code> stands for a cons cell whose 
<code>car</code> is the object <code>a</code> and whose <code>cdr</code> is the object <code>b</code>. Dotted pair notation is 
more general than list syntax because the <code>cdr</code> does not have to be a list.</p>

<p>Dotted pairs can be chained together to form a list. For example, <code>(1 2 3)</code> is written 
as <code>(1 . (2 . (3 . nil)))</code>.</p>

<h1 id="writing-an-emacs-major-mode">Writing an emacs major mode</h1>

<h2 id="basic-mode-setup">Basic mode setup</h2>

<p>There are certain variables that all modes must define. Here’s a list:</p>
<ul>
  <li><code>wpdl-mode-hook</code>: allows the user to run their own code when your mode is run.</li>
  <li><code>wpdl-mode-map</code>: allows both you and your users to define their own keymaps.</li>
</ul>

<p>In order to tell emacs that this mode must start when a particular file extension is detected, we add to a list called <code>auto-mode-alist</code> using the <code>add-to-list</code> function. For example:</p>
<pre><code>(add-to-list 'auto-mode-alist '("\\.rubex\\'" . rubex-mode))
</code></pre>

<p>Protip: An <code>alist</code> is for historical reasons made of plain cons cells instead of full lists.</p>

<h2 id="syntax-highlighting">Syntax highlighting</h2>

<h2 id="indentation">Indentation</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/03/23/implementing-block-lu-decomposition-using-mpi-and-blacs/">Implementing Block LU Decomposition Using MPI and BLACS</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>Recently I was tasked with implemented a block LU decomposition in parallel using
a block cyclic process distribution using BLACS and MPI. This decomposition would
then be extended to hierarchical matrices and would eventually work with dense matrices
instead of hierarchical. Thus we cannot use already implemented distributed LU factorization
methods like scalapack for this purpose.</p>

<p>In this post I would like to document my learnings about desinging the parallel algorithm
and installing the various libraries that are required for this purpose. Hopefully, the reader
will find something useful in this post too. This post will cover only LU factorization of dense
matrices. Hierarchical matrices will be covered in another post.</p>

<p>I have written about using the scalapack C++ interface for a simple block LU decomposition 
in <a href="URL">this</a> post.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#installing-libraries">Installing libraries</a></li>
  <li><a href="#designing-the-algorithm">Designing the algorithm</a>
    <ul>
      <li><a href="#asynchronous-block-lu">Asynchronous block LU</a></li>
      <li><a href="#synchronous-block-lu">Synchronous block LU</a></li>
      <li><a href="#resources">Resources</a></li>
    </ul>
  </li>
  <li><a href="#implementation-with-mpi">Implementation with MPI</a>
    <ul>
      <li><a href="#block-cyclic-data-distribution">Block cyclic data distribution</a>
        <ul>
          <li><a href="#block-cyclic-nomenclature">Block cyclic nomenclature</a></li>
        </ul>
      </li>
      <li><a href="#scalapack-protips">ScaLAPACK protips</a>
        <ul>
          <li><a href="#use-of-m-and-n-in-routines">Use of M and N in routines</a></li>
        </ul>
      </li>
      <li><a href="#blacs-protips">BLACS protips</a>
        <ul>
          <li><a href="#blacs-topologies">BLACS topologies</a></li>
          <li><a href="#blacs-general-apis">BLACS general APIs</a></li>
        </ul>
      </li>
      <li><a href="#asynchronous-block-lu">Asynchronous block LU</a></li>
      <li><a href="#synchronous-block-lu">Synchronous block LU</a></li>
    </ul>
  </li>
  <li><a href="#resources">Resources</a>
    <ul>
      <li><a href="#blacs">BLACS</a></li>
    </ul>
  </li>
</ul>

<!-- markdown-toc end -->

<h1 id="installing-libraries">Installing libraries</h1>

<p>For this computation, we use MPICH and <a href="">BLACS</a>. While MPICH is easily installable on most
GNU/Linux distributions, the same cannot be said for BLACS.</p>

<p>I first tried downloading <a href="">BLACS sources</a> and compiling the library, however it gave too
many compilation errors and was taking a long time to debug. Therefore, I resorted to using
the <a href="">ScaLAPACK installer</a>, which is a Python script that downloads the sources of BLACS,
LAPACK and ScaLAPACK, compiles all these libraries on your system and produces a single 
shared object file <code>libscalapack.a</code> which you can use for linking with your program. 
Since BLACS is included in the ScaLAPACK distribution, you can use the scalapack binary
directly for linking.</p>

<p>Just download the ScaLAPACK installer from the website and follow the instructions in the README for quick and easy installation.</p>

<h1 id="designing-the-algorithm">Designing the algorithm</h1>

<h2 id="asynchronous-block-lu">Asynchronous block LU</h2>

<p>One problem that I faced when designing the algorithm is that when writing a CBLACS
program, you are basically writing the same code that is being run on multiple processes, 
however the data that is stored in variables is not the same for each process.</p>

<p>So it becomes important to write the program in such a way that maximum data is shared
between the processes but there is minimmum communication of things like the block
that is currently under process.</p>

<p>If it is a diagonal block, it simply factorizes the block into L &amp; U parts and broadcasts
it to rows and columns.</p>

<p>If it is a row or column block, it listens for the broadcast from the diagonal block and mutliplies the contents that it receives with the data it posseses. It then broadcasts the multiplied matrix block accross the lower right block so that the block can be reduced.</p>

<p>It can be expressed with this line of code:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>p2p_recv(recv_block, blocksize, rows[index] % N, rows[index] % N);
</pre></td>
</tr></table>
</div>

<p>The source row and source col arguments (last two) are computed by keeping in mind
that we can compute the diagonal block of a particular block if we know the absolute
row number of the block.</p>

<p>If is a block in the right lower block of the matrix (the A^ block), it waits for 
the broadcast from the row and column elements, multiplies the received data with
the stored data and over writes the stored data.</p>

<p>The computation and communication is mostly asynchronous. This means that there
needs to be some kind of a trigger to launch the computation or communication
tasks in a given process.</p>

<p>A major problem is synchronization of successive diagonal matrix blocks. The
computation must proceed from the top left corner of the matrix until the lower
right corner. For this to work properly it is important that the diagonal blocks
do not compute and send their data unless the diagonal block to the upper left 
of the block has finished computing.</p>

<h2 id="synchronous-block-lu">Synchronous block LU</h2>

<p>The main thing to take care of in synchronous block LU is that of the indexing of the data array
and the subsequent generation of the matrix. To demonstrate, here is what the matrix structure of
the synchronous block LU looks like:</p>

<!-- insert that hand drawn image of sync block LU here -->

<p>We can know the actual row and col number of the global matrix through the process ID and the
block number. The following lines of code are useful for this purpose:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
</pre></td>
  <td class="code"><pre><span style="color:#777">// bcounter_i is a counter identifying the block row within a process</span>
<span style="color:#777">// bcounter_j is a counter identifying the block col within a process</span>
<span style="color:#777">// num_blocks_per_process is the number of blocks in a process</span>
<span style="color:#777">// myrow is the BLACS process row number</span>
<span style="color:#777">// mycol is the BLACS process col number</span>
<span style="color:#777">// block_size_per_process_r is the row size of each block within the process</span>
<span style="color:#777">// block_size_per_process_c is the col size of each block within the process</span>

row_i = bcounter_i*num_blocks_per_process + myrow*block_size_per_process_r + i;
col_j = bcounter_j*num_blocks_per_process + mycol*block_size_per_process_c + j;
</pre></td>
</tr></table>
</div>

<p>We can get the index number of the data array in the following manner:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> index = (bcounter_i*block_size_per_process_r + bcounter_j)*
    num_blocks_per_process +  i*process_block_size + j;
</pre></td>
</tr></table>
</div>

<p>Before creating a full-fledged version of this code, I first made a simple code
that would calculate the LU decomposition in the case where there is only one
matrix block per process.</p>

<h2 id="resources">Resources</h2>

<p>Some resources that I found during this phase are as follows:</p>
<ul>
  <li><a href="http://www.mcs.anl.gov/~itf/dbpp/">Designing and building parallel programs.</a></li>
  <li><a href="http://www-users.cs.umn.edu/~karypis/parbook/">Introduction to Parallel Computing.</a></li>
  <li><a href="https://computing.llnl.gov/tutorials/parallel_comp/#Designing">Designing parallel programs course.</a></li>
  <li><a href="http://people.eecs.berkeley.edu/~demmel/cs267/lecture12/lecture12.html">Lecture on parallel Gaussian from Berkeley</a>.</li>
  <li><a href="https://cseweb.ucsd.edu/classes/sp07/cse262/Projects/260_fa06/Ricketts_SR.pdf">Parallelizing LU factorization.</a></li>
</ul>

<h1 id="implementation-with-mpi">Implementation with MPI</h1>

<p>Each process should hold only the part of the matrix that it is working upon.</p>

<h2 id="block-cyclic-data-distribution">Block cyclic data distribution</h2>

<p>The block cyclic distribution is a central idea in the case of PBLAS and BLACS.
It is important to store the matrix in this configuration since it is the most 
efficient in terms of load balancing for most applications.</p>

<p>If you’re reading a matrix from an external file it can get cumbersome to read 
into in a block cyclic manner manually. You do this with little effort using MPI IO.
Refer <a href="URL">this blog post</a> that describes this in detail along with C code.</p>

<p>For this code we generate the data on a per process basis.</p>

<h3 id="block-cyclic-nomenclature">Block cyclic nomenclature</h3>

<p>Its somewhat confusing how exactly the blocks are named. So here’s the nomenclature
I’m using when talking about certain kinds of blocks:</p>
<ul>
  <li>Process blocks :: blocks inside a process.</li>
  <li>Matrix blocks :: blocks of the global matrix.</li>
  <li>Matrix sub-blocks :: Each matrix block is divided into sub-blocks that are scattered
over processes. Each of these sub-blocks corresponds to a single process block.</li>
</ul>

<h2 id="scalapack-protips">ScaLAPACK protips</h2>

<h3 id="use-of-m-and-n-in-routines">Use of M and N in routines</h3>

<p>ScaLAPACK operates on a block cyclic data distribution. Most of the routines accept
two parameters: <code>M</code> and <code>N</code> that are described as the number of rows and cols of the
distributed submatrix sub(A). Its easy to get confused by thinking of these variables
as the dimensions of the <em>global</em> matrix. However, since scalapack relies on a block
cyclic data distribution, the ‘world’ for all processes at <em>one</em> time is basically one
matrix block which is spread over all the processes. Therefore, when calling scalapack
routines care must be taken to specify the dimensions of the matrix block in <code>M</code> and <code>N</code>
and not those of the global matrix.</p>

<p>If you see other code that does not rely on multiple sub-matrix blocks inside processes, 
they will usually pass the dimensions of the global matrix to the routine, which is correct
for that case since there is only one sub-matrix block per process.</p>

<h2 id="blacs-protips">BLACS protips</h2>

<h3 id="blacs-topologies">BLACS topologies</h3>

<h3 id="blacs-general-apis">BLACS general APIs</h3>

<p>Similar to MPI, BLACS contains some routines for sending and receiving data in 
a point-to-point manner. They are as below:</p>
<ul>
  <li><code>gesd2d</code>: This routine is for point-to-point sending of data from one process to another. This routine is non-blocking by default (unlike <code>MPI_Send</code> which is blocking). It’s prototype for the C interface is as follows:
    <div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> Cdgesd2d(
  <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS context</span>
  <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// row size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// col size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">double</span>* A, <span style="color:#777">// pointer to matrix block</span>
  <span style="color:#0a8;font-weight:bold">int</span> LDA, <span style="color:#777">// leading dim of A (col size for C programs)</span>
  <span style="color:#0a8;font-weight:bold">int</span> RDEST, <span style="color:#777">// row number of destination process</span>
  <span style="color:#0a8;font-weight:bold">int</span> CDEST <span style="color:#777">// col number of destination process</span>
);
</pre></td>
</tr></table>
    </div>
  </li>
  <li><code>trsd2d</code>: This routine is used for point-to-point sending of trapezoidal matrices.</li>
  <li><code>gerv2d</code>: This routine is used for point-to-point receiving of general rectangular
matrices. This routine will block until the message is received. Its prototype looks like so:
    <div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> Cdgerv2d(
  <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS conntext</span>
  <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// row size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// col size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#777">// pointer to matrix data.</span>
  <span style="color:#0a8;font-weight:bold">int</span> LDA, <span style="color:#777">// leading dim of A (col size for C)</span>
  <span style="color:#0a8;font-weight:bold">int</span> RSRC, <span style="color:#777">// process row co-ordinate of the sending process.</span>
  <span style="color:#0a8;font-weight:bold">int</span> CSRC <span style="color:#777">// process col co-ordinate of the sending process.</span>
);
</pre></td>
</tr></table>
    </div>
  </li>
</ul>

<p>For broadcast receive, there is the <code>gebr2d</code> routine. This routine is particularly 
useful since it can broadcast over all processes, or a specific row or column. 
This can be helpful over using MPI directly since it allows us to easily broadcast
over rows or columns without having to define separate communicators.</p>

<p>The prototype of this routine is as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
</pre></td>
  <td class="code"><pre><span style="color:#777">// Cd stands for 'C double'</span>
<span style="color:#777">// ge is 'general rectangular matrix'</span>
<span style="color:#777">// br is 'broadcast receive'</span>
<span style="color:#088;font-weight:bold">void</span> Cdgebr2d(
    <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS context</span>
    <span style="color:#0a8;font-weight:bold">char</span>* SCOPE, <span style="color:#777">// scope of the broadcast. Can be &quot;Row&quot;, &quot;Column&quot; or &quot;All&quot;</span>
    <span style="color:#0a8;font-weight:bold">char</span>* TOP, <span style="color:#777">// indicates communication pattern to use for broadcast.</span>
    <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// number of rows of matrix.</span>
    <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// number of columns of matrix.</span>
    <span style="color:#0a8;font-weight:bold">double</span>* A, <span style="color:#777">// pointer to matrix data.</span>
    <span style="color:#0a8;font-weight:bold">int</span> LDA, <span style="color:#777">// leading dim of matrix (col size for C)</span>
    <span style="color:#0a8;font-weight:bold">int</span> RSRC, <span style="color:#777">// process row co-ordinate of the process who called broadcast/send.</span>
    <span style="color:#0a8;font-weight:bold">int</span> CSRC <span style="color:#777">// process column co-ordinate of the process who called broadcast/send.</span>
);
</pre></td>
</tr></table>
</div>

<p>For broadcast send, there is the <code>gebs2d</code> routine. This is helpful for receiving broadcasts.
The prototype of this function is as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre>Cdgebs2d(
    <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS context.</span>
    <span style="color:#0a8;font-weight:bold">char</span>* SCOPE, <span style="color:#777">// scope of broadcast. can be &quot;All&quot;, &quot;Row&quot; or &quot;Column&quot;.</span>
    <span style="color:#0a8;font-weight:bold">char</span>* TOP, <span style="color:#777">// network topology to be used.</span>
    <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// num of rows of the matrix.</span>
    <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// num of cols of the matrix.</span>
    <span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#777">// pointer to the matrix data.</span>
    <span style="color:#0a8;font-weight:bold">int</span> LDA <span style="color:#777">// leading dimension of A.</span>
);
</pre></td>
</tr></table>
</div>
<p>The <code>TOP</code> argument specifies the communication pattern to use. Leave it as a blank space
(<code>" "</code>) to use the default.</p>

<h2 id="asynchronous-block-lu-1">Asynchronous block LU</h2>

<h2 id="synchronous-block-lu-1">Synchronous block LU</h2>

<p>In the asynchronous LU, it is assumed that the block size is equal to the processor size,
i.e each block of the matrix is limited to only a single processor. For synchronous LU 
decomposition, we take blocks which are spread out over multiple processors. To illustrate, 
see the below figure:</p>

<p>Four of the above colors represent a single block and each color represents a process. This
means that each block is spread out over 4 processes. This ensures that the processes are
always kept busy no matter the operation.</p>

<p>It should be remembered that scalapack expects the data to be in column-major format.
Therefore, it must be stored that way.</p>

<h1 id="resources-1">Resources</h1>

<h2 id="blacs">BLACS</h2>

<ul>
  <li><a href="https://software.intel.com/en-us/mkl-developer-reference-c-blacs-routines">Intel MKL BLACS resources</a>.</li>
  <li><a href="https://andyspiros.wordpress.com/2011/07/08/an-example-of-blacs-with-c/">Blog post detailing use of BLACS for scatter operations.</a></li>
  <li><a href="http://www.netlib.org/blacs/BLACS/QRef.html#BS">Netlib BLACS reference</a>.</li>
  <li><a href="http://www.netlib.org/blacs/BLACS/Array.html">BLACS array-based communication</a>.</li>
  <li><a href="http://www.netlib.org/lapack/lawnspdf/lawn94.pdf">BLACS user manual</a>.</li>
  <li><a href="http://www.netlib.org/blacs/BLACS/Top.html">BLACS communication topologies</a>.</li>
  <li><a href="https://scicomp.stackexchange.com/questions/1688/how-do-i-use-scalapack-pblas-for-matrix-vector-multiplication">Using PBLAS for matrix multiplication.</a></li>
  <li><a href="https://software.intel.com/en-us/mkl-developer-reference-c-pblas-routines-overview">PBLAS rountines overview from Intel.</a></li>
  <li><a href="http://www.nersc.gov/users/software/programming-libraries/math-libraries/libsci/libsci-example/">ScaLAPACK pdgemm matrix multiplication example.</a></li>
  <li><a href="http://www.training.prace-ri.eu/uploads/tx_pracetmo/scalable_linear_algebra.pdf">Presentation about Scalapack/PBLAS/BLACS with good details on usage.</a></li>
  <li><a href="http://www.netlib.org/utk/papers/scalapack/node8.html">Block cyclic data distribution (netlib).</a></li>
  <li><a href="http://www.netlib.org/blacs/BLACS/Top.html">BLACS Topology.</a></li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2018/02/02/japan-chronicles/">Japan Chronicles</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>In this post (which will hopefully be continually upgraded for a long, long time) I will document some interesting experiences that I have been having as an Indian living and studying in Japan.</p>

<h1 id="reflections-of-life-in-tokyo">Reflections of life in Tokyo</h1>

<h2 id="life-in-a-university-cs-lab">Life in a university CS lab</h2>

<h2 id="dorm-life">Dorm life</h2>

<h2 id="moving-to-a-new-apartment">Moving to a new apartment</h2>

<h1 id="travelling-aroung-tokyo">Travelling aroung Tokyo</h1>

<p>Since the past 4 months I have been very busy with settling down into a new life and doing some 
really challenging work at my University. In this subsection I will document my experiences of 
travelling around the wonderful city of Tokyo. You can of course follow my <a href="">instagram</a> or 
<a href="">twitter</a> for quick updates :)</p>

<h1 id="travelling">Travelling</h1>

<h2 id="hiking">Hiking</h2>

<h3 id="mt-takao">Mt. Takao</h3>

<h3 id="mt-koubou">Mt. Koubou</h3>

<h3 id="okutama-valley">Okutama valley</h3>

<h3 id="mt-fuji">Mt. Fuji</h3>

<h2 id="skiing">Skiing</h2>

<h3 id="yuzawa-ski-resort">Yuzawa ski resort</h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/10/23/explanation-of-exafmm-learning-codes/">Explanation of ExaFMM Learning Codes.</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>In this file I will write descriptions of the exafmm ‘learning’ codes and my understanding of them. I have been tasked with understanding the code and porting it to Ruby, my favorite language.
We shall start from the first tutorial, i.e. <a href="">0_tree</a>. You can find the full Ruby code here.</p>

<!-- MarkdownTOC style="round" autolink="true" depth="4" -->

<ul>
  <li>0_tree
    <ul>
      <li>step1.cxx</li>
      <li>step2.cxx</li>
      <li>step3.cxx</li>
      <li>step04.cxx</li>
    </ul>
  </li>
  <li>1_traversal
    <ul>
      <li>step1.cxx</li>
      <li>step2.cxx</li>
    </ul>
  </li>
  <li>2_kernels
    <ul>
      <li>kernel.h</li>
      <li>vector.h</li>
      <li>exafmm.h</li>
      <li>exafmm2d.h and step1.cxx</li>
      <li>step2.cxx</li>
    </ul>
  </li>
</ul>

<!-- /MarkdownTOC -->

<h1 id="0_tree">0_tree</h1>

<h2 id="step1cxx">step1.cxx</h2>

<p>This program simply populates some bodies with random numbers, creates a hypothetical X and Y axes and figures out the quadrant of each of the bodies.</p>

<p>Each of the nodes of the tree have a maximum of <a href="">4 immediate children</a>. We first initialize 100 <code>struct Body</code> objects, and then set the X and Y co-ordinates of each of them to a random number between 0 and 1.</p>

<p>In order to actually build the tree we follow the following steps:</p>

<ul>
  <li>First <a href="">get the bounds</a> between which the random numbers lie. That is, we figure out the min and max random number that is present in the bodies.</li>
  <li>We then get a <a href="">‘center’ and a ‘radius’</a>. This is useful for creating ‘quadrants’ and partitioning points into different quandrants in later steps. The center is calculated by adding the min and max numbers (which we treat as the diameter) and dividing by 2. This step is necessary since there is no ‘square’ space that can be partitioned into multiple spaces like there was in the lecture series. The way of calculating the radius <code>r0</code> is a little peculiar. It does not use the distance formula, its main purpose is….</li>
  <li>And then simply count the bodies in each quadrant and display them.</li>
</ul>

<p>Ruby code:
The body is represented as the Ruby class <code>Body</code>:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Body</span>
  attr_reader <span style="color:#A60">:x</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>
    <span style="color:#33B">@x</span> = [<span style="color:#60E">0.0</span>, <span style="color:#60E">0.0</span>]
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>There is an interesting way of knowing the quadrant in this code. It goes like this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>a = body.x[<span style="color:#00D">0</span>] &gt; x0[<span style="color:#00D">0</span>] ? <span style="color:#00D">1</span> : <span style="color:#00D">0</span>
b = body.x[<span style="color:#00D">1</span>] &gt; x0[<span style="color:#00D">1</span>] ? <span style="color:#00D">1</span> : <span style="color:#00D">0</span>
quadrant = a + (b &lt;&lt; <span style="color:#00D">1</span>)
</pre></td>
</tr></table>
</div>
<p>Above code basically plays with 0 and 1 and returns a number between 0 and 3 as the correct quadrant number.</p>

<h2 id="step2cxx">step2.cxx</h2>

<p>This code basically takes the bodies created in the previous step, counts the number of bodies in each quadrant and sorts them by quadrant.</p>

<p>The new steps introduced in this program can be summarized as follows:</p>
<ul>
  <li>Count the bodies in each quadrant and store the count in an array. The <code>size</code> array in case of the Ruby implementation.</li>
  <li>In the next step we successively add the number of elements in each quadrant so that it gives us the offset value at which elements from a new quadrant will start in the <code>bodies</code> Array (of course, after it is sorted).</li>
  <li>We then sort the bodies according to the quadrant that they belong to. Something peculiar that I notice about this part is that <code>counter[quadrant]</code> also gets incremented after each iteration for sorting. Why is this the case even though the counters have been set to the correct offsets previously?</li>
</ul>

<h2 id="step3cxx">step3.cxx</h2>

<p>This program introduces a new method called <code>buildTree</code>, inside of which we will actually build the tree. It removes some of the sorting logic from <code>main</code> and puts it inside <code>buildTree</code>. The <code>buildTree</code> function performs the following functions:</p>
<ul>
  <li>Most of the functions relating to sorting etc are same. Only difference is that there is in-place sorting of the <code>bodies</code> array and the <code>buffer</code> array does not store elements anymore.</li>
  <li>A new function introduced is that we re-calculate the center and the radius based on sorted co-ordinates. This is done because we want new center and radii for the children.</li>
  <li>The <code>buildTree</code> function is called recursively such that the quadrants are divided until a point is reached where the inner most quadrant in the hierarchy does not contain more than 4 elements.</li>
</ul>

<p>Implementation:</p>

<p>There is an interesting piece of code in the part for calculating new center and radius:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre> <span style="color:#777"># i is quadrant number</span>
center[d] = x0[d] + radius * (((i &amp; <span style="color:#00D">1</span> &lt;&lt; d) &gt;&gt; d) * <span style="color:#00D">2</span> - <span style="color:#00D">1</span>)
</pre></td>
</tr></table>
</div>

<p>In the above code, there is some bit shifting and interleaving taking place whose prime purpose is to split the quadrant number into X and Y dimension and then using this to calculate the center of the child cell.</p>

<p>Another piece of code is this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>counter = <span style="color:#036;font-weight:bold">Array</span>.new <span style="color:#00D">4</span>, start
<span style="color:#00D">1</span>.upto(<span style="color:#00D">3</span>) <span style="color:#080;font-weight:bold">do</span> |i|
  counter[i] = size[i-<span style="color:#00D">1</span>] + counter[i-<span style="color:#00D">1</span>]
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#777"># sort bodies and store them in buffer</span>
buffer = bodies.dup
start.upto(finish-<span style="color:#00D">1</span>) <span style="color:#080;font-weight:bold">do</span> |n|
  quadrant = quadrant_of x0, buffer[n]
  bodies[counter[quadrant]] = buffer[n]
  counter[quadrant] += <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>In the above code, the <code>counter</code> variable is first used to store offsets of the elements in different quadrants. In the next loop it is in fact a counter for that stores in the index of the body that is currently under consideration.</p>

<h2 id="step04cxx">step04.cxx</h2>

<p>In this step we use the code written in the previous steps and actually build the tree.
The tree is built recursively by splitting into quadrants and then assigning them to cells
based on the quadrant. The ‘tree’ is actually stored in an array.</p>

<p>The cells are stored in a C++ vector called <code>cells</code>.</p>

<p>In the <code>Cell</code> struct, I wonder why the body is stored as a pointer and not a variable.</p>

<p>Implementation in the Ruby code, like saving the size of an Array during a recursive call
is slightly different since Ruby does not support pointers, but the data structures and
overall code is more or less a direct port.</p>

<h1 id="1_traversal">1_traversal</h1>

<p>These codes are for traversal of the tree that was created in the previous step. The full code can be found in <a href="">1_traversal.rb</a> file.</p>

<h2 id="step1cxx-1">step1.cxx</h2>

<p>This step implements the P2M and M2M passes of the FMM.</p>

<p>One major difference between the C++ and Ruby implementation is that since Ruby does not have pointers, I
have used the array indices of the elements instead. For this purpose there are two attributes in the
<code>Cell</code> class called <code>first_child_index</code> that is responsible for holding the index in the <code>cells</code> array
about the location of the first child of this cell, and the second <code>first_body_index</code> which is responsible for holding the index of the body in the <code>bodies</code> array.</p>

<p>This step does this by introducing a method called <code>upwardPass</code> which iterates through nodes and thier children and computes the P2M and M2M kernels.</p>

<h2 id="step2cxx-1">step2.cxx</h2>

<p>This step implements the rest of the kernels i.e. M2L, L2L, L2P and P2P. It also introduces two new methods <code>downward_pass</code> that calculates the local forces from other local forces and L2P interactions and <code>horizontal_pass</code> that calculates the inter-particle interactions and m2l.</p>

<p>No special code as such over here, its just the regular FMM stuff.</p>

<h1 id="2_kernels">2_kernels</h1>

<p>This code is quite different from the previous two. While the previous programs were mostly retricted to a single file, this program substantially increases complexity and spreads the implementation across several files. We start using 3 dimensional co-ordinates too.</p>

<p>In this code, we start to make a move towards spherical co-ordinate system to represent the particles in 3D. A few notable algorithms taken from some research papers have been implemented in this code.</p>

<p>Lets describe each file and see what implementation lies inside</p>

<h2 id="kernelh">kernel.h</h2>

<p>The <code>kernel.h</code> header file implemenets all the FMM kernels. It also implements two special functions called <code>evalMultipole</code> and <code>evalLocal</code> that evaluate the multipoles and local expansion for spherical co-ordinates using the actual algorithm that is actually used in exafmm. An implementation of this algorithm can be found on page 16 of the paper <a href="https://arxiv.org/pdf/1010.1482.pdf%20">“Treecode and fast multipole method for N-body simulation with CUDA”</a> by Yokota sensei. A preliminary implementation of this algorithm can be found in <a href="http://www.sciencedirect.com/science/article/pii/S0021999199963556">“A Fast Adaptive Multipole Algorithm in Three Dimensions”</a> by Cheng.</p>

<p>The Ruby implementation of this file is in <code>kernel.rb</code>.</p>

<p>I will now describe this algorithm here best I can:</p>

<h3 id="preliminaries">Preliminaries</h3>

<h4 id="ynm-vector">Ynm vector</h4>

<p>This is a vector that defines the <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">spherical harmonics</a> of degree <em>n</em> and order <em>m</em>. A primitive version for computing this exists in the paper by Cheng and a newer, faster version in the paper by Yokota.</p>

<p>Spherical harmonics allow us to define series of a function in 3D rather in 1D that is usually the case for things like the expansion of <em>sin(x)</em>. They are representations of functions on the surface of a sphere instead of on a circle, which is usually the case with other 2D expansion functions. They are like the Fourier series of the sphere. This <a href="http://mathworld.wolfram.com/SphericalHarmonic.html">article</a> explains the notations used nicely.</p>

<p>The order (<em>n</em>) and degree (<em>m</em>) correspond to the order and degree of the <a href="http://mathworld.wolfram.com/LegendrePolynomial.html">Legendre polynomial</a> that is used for obtaining the spherical harmonic. <em>n</em> is an integer and <em>m</em> goes from <em>0..n</em>.</p>

<p>For causes of optimization, the values stored inside <code>ynm</code> are not the ones that correspond to the spherical harmonic, but are values that yield optimized results when the actual computation happens.</p>

<h4 id="historical-origins-of-kernelh">Historical origins of kernel.h</h4>

<p>This file is a new and improved version of the laplace.h file from the exafmm-alpha repo. Due to the enhacements made, the code in this file performs calculations that are significantly more accurate than those in laplace.h.</p>

<p>laplace.h consists of a C++ class inside which all the functions reside, along with a constructor that computes pre-determined values for subsequent computation of the kernels. For example, in the constructor of the <code>Kernel</code> class, there is a line like so:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>Anm[nm] = oddOrEven(n)/std::sqrt(fnmm*fnpm);
</pre></td>
</tr></table>
</div>
<p>This line is computing the value of <script type="math/tex">A^{m}_{n}</script> as is given by Cheng’s paper (equation 14). This value is used in M2L and L2L kernels later. However, this value is never directly computed in the new and optimized <code>kernel.h</code> file. Instead, it modifies the computation of the <code>Ynm</code> vector such that it no longer becomes necessary to involve the <code>Anm</code> term in any kernel computation.</p>

<h3 id="functions">Functions</h3>

<h4 id="cart2sph">cart2sph</h4>

<p>This function converts cartesian co-ordinates in (X,Y,Z) to spherical co-ordinates involving <code>radius</code>, <code>theta</code> and <code>phi</code>. <code>radius</code> is simply the square root of the norm of the co-ordinates (norm is defined as the sum of squares of the co-ordinates in <code>vec.h</code>).</p>

<h4 id="evalmultipole-simple-implementation">evalMultipole simple implementation</h4>

<p>This algorithm calculates the multipole of a cell. It uses spherical harmonics so that net force of the forces inside a sphere and can be estimated on the surface of the sphere, which can then be treated as a single body for estimating forces.</p>

<p>The optimizations that are presented in the <code>kernel.h</code> version of this file are quite complex to understand since they look quite different from the original equation.</p>

<p>For code that is still sane and easier to read, head over to the <a href="https://github.com/exafmm/exafmm-alpha/blob/develop/kernels/laplace.h#L48">laplace.h</a> file in exafmm-alpha. The explanations that follow for now are from this file. We will see how the same functions in <code>kernel.h</code> have been modified to make computation faster and less dependent on large number divisions which reduce the accuracy of the system.</p>

<p>The <code>evalMultipole</code> function basically tries to populate the <code>Ynm</code> array with data that is computed with the following equation:</p>

<script type="math/tex; mode=display">\rho^{n}Y_{n}^{m}=\sum_{m=0}^{P-1}\sum_{n=m+1}^{P-1}\rho^{n}P_{n}^{m}(x)\sqrt{\frac{(n-m)!}{(n+m)!}}e^{im\beta}</script>

<p>It starts with evaluating terms that need not be computed for every iteration of <code>n</code>, and computes those terms in the outer loop itself. The terms in the outer loop correspond to the condition <code>m=n</code>. The first of these is the exponential term <script type="math/tex">e^{im\beta}</script>.</p>

<p>After this is a curious case of computation of some indexes called <code>npn</code> and <code>nmn</code>. These are computed as follows:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>npn = m * m + <span style="color:#00D">2</span> * m <span style="color:#777"># case Y n  n</span>
nmn = m * m         <span style="color:#777"># case Y n -n</span>
</pre></td>
</tr></table>
</div>

<p>The corresponding index calculation for the inner loop is like this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>npm = n * n + n + m <span style="color:#777"># case Y n  m</span>
nmm = n * n + n - m <span style="color:#777"># case Y n -m</span>
</pre></td>
</tr></table>
</div>

<p>This indexes the <code>Ynm</code> array. This is done because we are visualizing the Ynm array as a pyramid whose base spans from <code>-m</code> to <code>m</code> and who height is <code>n</code>. A rough visualization of this pyramid would be like so:</p>
<pre><code>   -m ---------- m
n  10 11 12 13  14
|    6  7  8  9
|     3  4   5  
|      1   2
V        0
</code></pre>

<p>The above formulas will give the indexes for each half of the pyramid. Since the values of one half of the pyramid are conjugates of the other half, we can only iterate from <code>m=0</code> to <code>m&lt;P</code> and use this indexing method for gaining the index of the other half of the pyramid.</p>

<p>Now let us talk about the evaluation of the <a href="http://mathworld.wolfram.com/AssociatedLegendrePolynomial.html">Associated Legendre Polynomial</a> <script type="math/tex">P^m_{n}(cos(\theta))</script>, where <em>m</em> is the order of the differential equation and <em>n</em> is the degree. The Associated Legendre Polynomial is the solution to the <a href="http://mathworld.wolfram.com/AssociatedLegendreDifferentialEquation.html">Associated Legendre Equation</a>. The Legendre polynomial can be expressed in terms of the <a href="https://en.wikipedia.org/wiki/Associated_Legendre_polynomials#Definition_for_non-negative_integer_parameters_.E2.84.93_and_m">Rodrigues form</a> for computation without dependence on the simple Legendre Polynomial <script type="math/tex">P_{n}</script>. However, due to the factorials and rather large divisions that need to be performed to compute the Associated Legendre polynomial in this form, computing this equation for large values of <em>m</em> and <em>n</em> quickly becomes unstable. Therefore, we use a recurrence relation of the Polynomial in order to compute different values.</p>

<p>The recurrence relation looks like so:</p>

<script type="math/tex; mode=display">(n-m+1)P^m_{n+1}(x)=x(2n+1)P^m_n(x)-(n+m)P^m_{n-1}(x)</script>

<p>This is expressed in the code with the following line:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>p = (x * (<span style="color:#00D">2</span> * n + <span style="color:#00D">1</span>) * p1 - (n + m) * p2) / (n - m + <span style="color:#00D">1</span>)
</pre></td>
</tr></table>
</div>
<p>It can be seen that <code>p</code> is equivalent to <script type="math/tex">P^{m}_{n+1}</script>, <code>p1</code> is equivalent to <script type="math/tex">P^{m}_{n}</script> and <code>p2</code> is equivalent to <script type="math/tex">P^{m}_{n-1}</script>. This convention is followed everywhere in the code.</p>

<p>Observe that the above equation requires the value of <em>P</em> for <em>n-1</em> and <em>n+1</em> to be computed so that the value for <em>P</em> at <em>n</em> can be computed. Therefore, we first set <em>m=m+1</em> and then compute <script type="math/tex">P^m_{m+1}</script> which can be expressed like this:
<script type="math/tex">P^{m}_{m+1}(x)=x(2m+1)P^{m}_{m}(x)</script></p>

<p>The above equation is expressed by the following line in the code:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>p = x * (<span style="color:#00D">2</span> * m + <span style="color:#00D">1</span>) * p1
</pre></td>
</tr></table>
</div>

<p>If you read the code closely, you will see that just at the beginning of the <code>evalMultipole</code> function, we initialize <code>p1 = 1</code> the first time the looping is done. This is because when <code>p1</code> at the first instance is identified with <code>m = 0</code>, and we substitute <code>m=0</code> in this equation:</p>

<script type="math/tex; mode=display">P^{m}_{m} = (-1)^{m}(2m-1)!(1-x^{2})^{\frac{m}{2}}</script>

<p>We will get <script type="math/tex">P^{m}_{m}(x)=1</script>.</p>

<p>When you look at the code initially, there might be some confusion regarding the significance of having to <code>rho</code> terms, <code>rhom</code> and <code>rhon</code>. This is written because each term of <code>Ynm</code> depends on a particular power of <code>rho</code> raised to <code>n</code>. So just before the inner loop, you can see the line <code>rhon = rhom</code>, which basically reduces the number of times that <code>rho</code> needs to be multiplied since the outer loop’s value of <code>rho</code> is already set to what it should be for that particular iteration.</p>

<p>Finally, see that there is a line right after the inner loop which reads like this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>pn = -pn * fact * y
</pre></td>
</tr></table>
</div>
<p>This line is for calculating the value of <code>p1</code> or <script type="math/tex">P^{m}_{m}</script> after the first iteration of the loop. Since the second factorial term in the equation basically just deals with odd numbers, the calculation of this term can be simplified by simply incrementing by <code>2</code> with <code>fact += 2</code>. The <code>y</code> term in the above equation is in fact <code>sin(alpha)</code> (defined at the top of this function). This is because, if you see the original equation, you will see that the third term is <script type="math/tex">(1-x^{2})</script>, and <em>x</em> is in fact <code>cos(alpha)</code>. Therefore, using the trigonometric equation, we can say simply substitute the entire term with <code>y</code>.</p>

<h4 id="evalmultipole-optimized-implementation">evalMultipole optimized implementation</h4>

<p>Now that a background of the basic implementation of <code>evalMultipole</code> has been established, we can move over to understanding the code that is placed inside the <a href="https://github.com/exafmm/exafmm/blob/learning/2_kernels/kernel.h">kernel.h</a> file of the <code>exafmm/learning</code> branch. This code is more optimized and can compute results with much higher accuracy than the code that is present in the <code>exafmm-alpha</code> repo that we previously saw. The main insipiration for this code come’s from the Treecode paper posted above.</p>

<p>In this code, most of the stuff relating to indexing and calculation of the powers of <code>rho</code> is pretty much the same. However, there are some important changes with regards to the computation of the values that go inside the <code>Ynm</code> array. This change is also reflected in the subsequent kernels.</p>

<p>The simplication in computation is basically based on the notion that a P2M kernel will eventually be expanded to M2M and therefore it makes sense to compute some terms that are required for M2M inside P2M itself. In order to see how exactly this will work, consider the line in laplace.h that is used for computing the M2M:</p>
<pre><code>M += Cj-&gt;M[jnkms] * std::pow(I,real_t(m-abs(m))) * Ynm[nm] * real_t(oddOrEven(n) * Anm[nm] * Anm[jnkm] / Anm[jk]);
</code></pre>
<p>The above line computes the M2M as given by eq.13 in <a href="https://ac.els-cdn.com/S0021999199963556/1-s2.0-S0021999199963556-main.pdf?_tid=262a8f4c-d58d-11e7-82f6-00000aacb360&amp;acdnat=1512018967_7cd88d8da2a5a747344fe9c0619e5563">Cheng’s paper</a>. Now, division and multiplication of such large numbers makes the M2M calculation very unstable if the order and/or degree of the equations is large. Therefore, the new <code>evalMultipole</code> simplifies this computation by computing some terms in the P2M stage itself.</p>

<p>In order to understand this, let us see the equation given by Cheng. Let us call this equation <code>1</code>:</p>

<script type="math/tex; mode=display">M^{k}_{j}=\sum_{n=0}^{j}\sum_{m=-n}^{m=n} \frac{O_{j-n}^{k-m}\cdot i^{|k-m|-|k|-|m|}\cdot A^{m}_{n}\cdot A^{k-m}_{j-n}\cdot \rho^{n}\cdot Y^{-m}_{n}(\alpha,\beta)}{A_{j}^{k}}</script>

<p>In the new M2M kernel, the <em>A</em> terms are clubbed together with other terms such that no actual division or multiplication involving these terms takes place the way it does in the laplace.h code. In this regard, we club together <script type="math/tex">O^{k-m}_{j-n}</script> and <script type="math/tex">A^{k-m}_{j-n}</script>. You will notice that <em>O</em> is the actually the multipole that is computed in the P2M stage (the <code>Cj-&gt;M[jnkms]</code> term in the code sample above). Therefore, the actual equation of the P2M kernel using the new evalMultipole method becomes like this:</p>

<script type="math/tex; mode=display">M^{m}_{n}=\sum^{P-1}_{n=0}\sum^{n}_{m=-n} q_{j}\cdot \rho^{n} \cdot Y^{-m}_{n}(\alpha, \beta)\cdot A^{m}_{n}</script>

<p>The <script type="math/tex">A^{m}_{n}</script> part in eq. (1) will be clubbed with the spherical harmonic <em>Y</em> and will be calculated inside the <code>evalMultipole</code> method for every particle in case of P2M and every multipole in case of M2M. Thus since the P2M and M2M have similar behaviour (i.e. grouping of many particles to lesser particles) we can use the same function for both.</p>

<p>In retrospect, inside the evalMultipole method, the part of the above P2M equation after the <em>q</em> is calculated. This equation, upon expansion of spherical harmonics into its consitituents and cancellation of terms with <script type="math/tex">A^{m}_{n}</script>, can be simplified as the following equation. Note that the computed value of this equation is what gets stored inside the <code>Ynm</code> array.</p>

<script type="math/tex; mode=display">array^{n}_{m}=\sum^{P-1}_{m=0}\sum^{P-1}_{n=m+1} \frac{\rho^{n} \cdot P^{n}_{m}(x) \cdot e^{im\beta}}{-(n+m)!}</script>

<p>The implementation of this equation inside evalMultipole is a little funny. It has been optimized in such a way that the division operations never happen between numbers that are too big. The factorials are calculated on the fly while the loop is in progress. This can get a little confusing at first since it is not very obvious. The factorial is mainly calculated in two lines of code, <a href="https://github.com/exafmm/exafmm/blob/learning/2_kernels/kernel.h#L56">here</a> and <a href="https://github.com/exafmm/exafmm/blob/learning/2_kernels/kernel.h#L65">here</a>.</p>

<p>The first line of code reads <code>rhon /= -(n + m)</code>. The origin of this is obvious as can be seen from the above equation that is being calculated inside evalMultipole. The division happens after each iteration and there is no stored factorial that is used the way it was in <code>laplace.h</code> for reducing the number that needs to be used in the division.</p>

<p>The second line of code reads like <code>rhom /= -(2 * m + 2) * (2 * m + 1)</code>. In this case, notice that the LHS has the variable <code>rhom</code>. This variable is used only in the outer loop for computation of Ynm (i.e. the case of <code>n=m</code>). In order to explain this, consider that the inner loop starts from <code>n=m+1</code> and can be rewritten as <code>rhon /= -(2*m+1)</code> (at least for the first iteration). When the Ynm value needs to be calculated for the outer loop, we must have the current value of <code>m</code> and the value for the next iteration in the <code>rhom</code>, therefore we use <code>2*m+2</code> as well.</p>

<p>To understand in somewhat more detail, see the following Ruby code that recreates the values of the above indices:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
</pre></td>
  <td class="code"><pre><span style="color:#036;font-weight:bold">P</span> = <span style="color:#00D">5</span>
m = <span style="color:#00D">0</span>
n = m+<span style="color:#00D">1</span>

prod1 = <span style="color:#00D">1</span>
<span style="color:#00D">0</span>.upto(<span style="color:#036;font-weight:bold">P</span>-<span style="color:#00D">1</span>) <span style="color:#080;font-weight:bold">do</span> |m|
  prod = prod1
  (m+<span style="color:#00D">1</span>).upto(<span style="color:#036;font-weight:bold">P</span>-<span style="color:#00D">1</span>) <span style="color:#080;font-weight:bold">do</span> |n|
    puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">m: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>m<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> n: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>n<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> 2m+1: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>m+n<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
    prod *= (m + n)
  <span style="color:#080;font-weight:bold">end</span>
  prod1 *= (<span style="color:#00D">2</span>*m + <span style="color:#00D">1</span>)*(<span style="color:#00D">2</span>*m + <span style="color:#00D">2</span>)
  puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">P1: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>prod1<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> 2m+1: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span><span style="color:#00D">2</span>*m+<span style="color:#00D">1</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> 2m+2: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span><span style="color:#00D">2</span>*m+<span style="color:#00D">2</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>The above code produces the follwoing output:</p>
<pre><code>m: 0 n: 1 2m+1: 1
P: 1
m: 0 n: 2 2m+1: 2
P: 2
m: 0 n: 3 2m+1: 3
P: 6
m: 0 n: 4 2m+1: 4
P: 24
P1: 2 2m+1: 1 2m+2: 2
m: 1 n: 2 2m+1: 3
P: 6
m: 1 n: 3 2m+1: 4
P: 24
m: 1 n: 4 2m+1: 5
P: 120
P1: 24 2m+1: 3 2m+2: 4
m: 2 n: 3 2m+1: 5
P: 120
m: 2 n: 4 2m+1: 6
P: 720
P1: 720 2m+1: 5 2m+2: 6
m: 3 n: 4 2m+1: 7
P: 5040
P1: 40320 2m+1: 7 2m+2: 8
P1: 3628800 2m+1: 9 2m+2: 10
</code></pre>
<p>If you observe the output of code, you can see that the indices being calculated during P1 phase are exactly one greater than the previous phase, which indicates that the factorial value is being calculated properly, incrementally.</p>

<h2 id="vectorh">vector.h</h2>

<p>This file defines a new custom type for storing 1D vectors called <code>vec</code> as a  C++ class. It also defines various functions that can be used on vectors like <code>norm</code>, <code>exp</code> and other simple arithmetic.</p>

<p>The Ruby implementation of this file is in <code>vector.rb</code>.</p>

<h2 id="exafmmh">exafmm.h</h2>

<h2 id="exafmm2dh-and-step1cxx">exafmm2d.h and step1.cxx</h2>

<p>Shows a very simple preliminary implementation of the actuall exafmm code. Mostly useful for understanding purpose only.</p>

<h2 id="step2cxx-2">step2.cxx</h2>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/11/24/gsoc-2016-wrap-up-for-sciruby/">GSOC 2016 Wrap Up for SciRuby</a></h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


  <div class="entry-content"><p>In the summer of 2016 I was chosen by the SciRuby core team to be admin for SciRuby for Google Summer of Code 2016. GSOC is an important yearly event for us as an organization since it provides a great platform for an upcoming organization like SciRuby and helps us get more users and contributors for the various libraries that we maintain.</p>

<p>This blog post is meant to be a summary of the work that SciRuby did over the summer and also of my experience at the GSOC 2016 mentor’s summit.</p>

<h2 id="gsoc-student-work">GSOC student work</h2>

<p>For the 2016 edition of GSOC we had 4 students - <a href="https://github.com/lokeshh">Lokesh Sharma</a>, <a href="https://github.com/prasunanand">Prasun Anand</a>, <a href="https://github.com/gau27">Gaurav Tamba</a> and <a href="https://github.com/rajithv">Rajith Vidanaarachchi</a>. All four were undergraduate computer engineering students from colleges in India or Sri Lanka at the time of GSOC 2016.</p>

<p>Lokesh worked on making improvements to <a href="https://github.com/sciruby/daru">daru</a>, a Ruby DataFrame library. He made very significant contributions to daru by adding functionality for storing and performing operations on categorical data, and also significantly sped up the sorting and grouping functionality of daru. His work has now been successfully integrated into the main branch and has also been released on rubygems. Lokesh has remained active as a daru contributor and regularly contributes code and replies to Pull Requests and issues. You can find a wrap up of the work he did throughout the summer in <a href="http://sciruby.com/blog/2016/11/24/gsoc-2016-adding-categorical-data-support/">this blog post</a>.</p>

<p>Prasun worked on creating a Java backend for <a href="https://github.com/sciruby/nmatrix">NMatrix</a>, a Ruby library for performing linear algebra operations similar to numpy in Python. This project opened the doors for scientific computation on JRuby. Prasun was able to complete all his project objectives, and his work is currently awaiting review because of the <a href="https://github.com/SciRuby/nmatrix/pull/558">sheer size of the Pull Request</a> and the variety of changes to the library that he had to make in order to accomplish his project goals. You can read about his summer’s work <a href="http://sciruby.com/blog/2016/10/24/gsoc-2016-port-nmatrix-to-jruby/">here</a>. Prasun will also be <a href="http://rubyconfindia.org/program/#prasun-anand">speaking at Ruby Conf India 2017</a> about his GSOC work and scientific computing on JRuby in general.</p>

<p>Gaurav worked on creating a Ruby wrapper for NASA’s <a href="https://naif.jpl.nasa.gov/naif/toolkit.html">SPICE toolkit</a>. A need for this was felt since Gaurav’s mentor John is a rocket scientist and was keen having a Ruby wrapper for a library that he used regularly in his work. This resulted in the <a href="https://github.com/SciRuby/spice_rub">spice_rub</a> gem. It exposes a very intuitive Ruby interface to the SPICE toolkit. Gaurav also gave a lightning talk about his work at <a href="">Deccan Ruby Conf (Pune, India)</a>. Blog posts summarizing his work can be found <a href="http://sciruby.com/blog/2016/11/24/spicerub-kernelpool-and-kernels/">here</a>, <a href="http://sciruby.com/blog/2016/11/24/gsoc-2016-a-look-at-spicerub-body/">here</a> and <a href="http://sciruby.com/blog/2016/11/24/gsoc-2016-a-look-at-spicerub-time/">here</a>.</p>

<p>Rajith worked on growing the Ruby wrapper over <a href="https://github.com/symengine/symengine">symengine</a>. His mentor Abinash was a student with SciRuby for GSOC 2015 and volunteered to mentor Rajith so that Rajith could build upon the work that he had done the previous summer. This resulted in a huge increase in functionality for the <a href="https://github.com/symengine/symengine.rb">symengine.rb ruby gem</a>.</p>

<p>To summarize, all four of our students could execute their chosen tasks within the stipulated time and we did not have to fail anyone. All in all, we mentors had a great time working with the students and hope to keep doing this year on year!</p>

<h2 id="gsoc-2016-mentors-summit">GSOC 2016 mentor’s summit</h2>

<p>The GSOC 2016 mentor’s summit was fantastic. It was great meeting all the contributors and listening to ideas from projects that I had never heard about previously. I also had the opportunity to conduct an unconference session and  share my ideas on Scientific Computation in Ruby with like minded people from other organizations.</p>

<p>Here are some photos that I took at the summit:</p>

<p><img src="/images/gsoc_summit/1.JPG" alt="'ID card'" /></p>

<p><img src="/images/gsoc_summit/2.JPG" alt="'A visit to the Computer History Museum'" /></p>

<p><img src="/images/gsoc_summit/3.JPG" alt="'The (now discontinued) self driving car'" /></p>

<p><img src="/images/gsoc_summit/4.JPG" alt="'Chocolate table at the GSOC summit'" /></p>

<p><img src="/images/gsoc_summit/5.JPG" alt="'Attendees from India'" /></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2018/06/07/notes-using-numpy/">Notes Using Numpy</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/05/01/remote-file-editing-with-emacs/">Remote File Editing With Emacs.</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/05/01/building-a-fast-matrix-multiplication-algorithm/">Building a FAST Matrix Multiplication Algorithm.</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/04/20/emacs-org-mode-notes/">Emacs Org-mode Notes</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/04/20/bash-scripting-to-automate-porting-to-other-machines/">Bash Scripting to Automate Porting to Other Machines</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/v0dro">@v0dro</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'v0dro',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - Sameer Deshmukh -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'v0dro';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
