<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Travel &lt;code&gt; Music]]></title>
  <link href="http://v0dro.github.io/atom.xml" rel="self"/>
  <link href="http://v0dro.github.io/"/>
  <updated>2018-08-05T19:57:10+09:00</updated>
  <id>http://v0dro.github.io/</id>
  <author>
    <name><![CDATA[Sameer Deshmukh]]></name>
    <email><![CDATA[sameer.deshmukh93@icloud.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Notes Using Numpy]]></title>
    <link href="http://v0dro.github.io/blog/2018/06/07/notes-using-numpy/"/>
    <updated>2018-06-07T15:10:07+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/06/07/notes-using-numpy</id>
    <content type="html"><![CDATA[<p>In this post I will document certain things I’ve learned when working with numpy.
Might be interesting to some people.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#axes-in-numpy">Axes in numpy</a></li>
  <li><a href="#printoptions">Printoptions</a></li>
  <li><a href="#debugging">Debugging</a></li>
  <li><a href="#useful-functions">Useful functions</a>
    <ul>
      <li><a href="#setting-diagonals">Setting diagonals</a></li>
    </ul>
  </li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="axes-in-numpy">Axes in numpy</h1>

<p>Axes in numpy are defined for arrays in more than one dim. A 2D array has the 0th axis running
vertically <em>downwards</em> across rows and the 1st axis is running <em>horizontally</em> running across
columns.</p>

<p>See https://docs.scipy.org/doc/numpy-1.10.0/glossary.html</p>

<h1 id="printoptions">Printoptions</h1>

<p>The <code>numpy.printoptions</code> function can be used for setting various global print options like
linewidth and precision during printing to console. Useful for debugging and viewing:</p>
<ul>
  <li><code>suppress</code> - Suppress printing in scientific notation.</li>
  <li><code>precision</code> - Limit the precision of numbers printed.</li>
  <li><code>linewidth</code> - Max width of printing.</li>
</ul>

<h1 id="debugging">Debugging</h1>

<p>The <code>pdb</code> module is useful for debugging python. Place <code>pdb.set_trace()</code> in some place
in the code where you want the code to break. It will then provide you with a python
REPL.</p>

<p>Here’s a link to it: https://pythonconquerstheuniverse.wordpress.com/2009/09/10/debugging-in-python/</p>

<h1 id="broadcasting">Broadcasting</h1>

<p>Numpy uses ‘broadcastable’ data structures. It describes how numpy treats arrays with
different shapes during arithmetic operations.</p>

<p>Link:</p>
<ul>
  <li>https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html</li>
  <li>https://eli.thegreenplace.net/2015/broadcasting-arrays-in-numpy/</li>
</ul>

<h1 id="shape-parameters">Shape parameters</h1>

<p>Sometimes, some operations return their shape at <code>(R,1)</code> and some as <code>(R,)</code>. This design
decision is taken because numpy arrays are indexed by two numbers in the former case and
a single number in the latter case. This allows single number indexing and storage in
flat-indexed arrays.</p>

<p>Link: https://stackoverflow.com/questions/22053050/difference-between-numpy-array-shape-r-1-and-r/22074424</p>

<h1 id="useful-functions">Useful functions</h1>

<h2 id="setting-diagonals">Setting diagonals</h2>

<p>Use <code>numpy.fill_diagonal()</code> for filling the diagonal of an array with some number.
Take note that this is an in-place modification function and that it does not return
any value.</p>

<p>Link: https://docs.scipy.org/doc/numpy/reference/generated/numpy.fill_diagonal.html</p>

<h2 id="matrix-lower-triangle">Matrix lower triangle</h2>

<p>Use <code>numpy.tril()</code> and pass the object.</p>

<h2 id="inverse-of-a-matrix">Inverse of a matrix</h2>

<p>Compute multiplicative inverse of a matrix using <code>numpy.linalg.inv()</code>.</p>

<p>Link: https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.linalg.inv.html</p>

<h2 id="multiplication">Multiplication</h2>

<p><code>*</code> is element-wise multiplication between two arrays. For matrix multiplication use
<code>numpy.matmul</code>.</p>

<h1 id="resources">Resources</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remote File Editing With Emacs.]]></title>
    <link href="http://v0dro.github.io/blog/2018/05/01/remote-file-editing-with-emacs/"/>
    <updated>2018-05-01T17:59:14+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/05/01/remote-file-editing-with-emacs</id>
    <content type="html"><![CDATA[<p>I’m logging into various computers to harness their superior hardware which my
laptop can never support. In this post I’m documenting the stuff that should
be done for accessing remote files using emacs via your local machine.</p>

<h1 id="tramp">TRAMP</h1>

<p>TRAMP is an emacs utility that lets you edit remote files just like they’re local
files. In order to access a remote file, you need to use the following syntax
after doing a <code>C-x C-f</code>:</p>
<pre><code>/method:user@host:/path/to/file. 
</code></pre>
<p>In my case, I have the hosts written down in an ssh config file, so I can access a
file on computer <code>a2</code> in the following manner:</p>
<pre><code>/ssh:a2:/home/sameer/a.cpp
</code></pre>
<p>This is so incredibly intuitive and simple!</p>

<h1 id="note-about-fancy-shells">Note about fancy shells</h1>

<p>If you’re using some kind of fancy shell on your remote machine, it might cause tramp
to hang when accessing the machine via <code>C-x C-f</code>. For example, I was using oh-my-zsh
on a machine and tramp refused to work as a result. It started working fine after
reverting to bash.</p>

<p>Here’s a <a href="https://stackoverflow.com/questions/6954479/emacs-tramp-doesnt-work">resource</a> elaborating on that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building a FAST Matrix Multiplication Algorithm.]]></title>
    <link href="http://v0dro.github.io/blog/2018/05/01/building-a-fast-matrix-multiplication-algorithm/"/>
    <updated>2018-05-01T16:02:40+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/05/01/building-a-fast-matrix-multiplication-algorithm</id>
    <content type="html"><![CDATA[<p>I’ve received an assignment for writing a very fast matrix multiplication code using
multithreading, BLISLAB, SIMD, etc. In this post I will document my approach to writing
this code. I’ve made the best effort to optimize the multiplication to the hilt, but if
readers find anything amiss please leave a comment and I’ll have a look at it ASAP.</p>

<p>I’ve written various benchmarks and machines that the codes were tested on.</p>

<h1 id="testing-machine">Testing machine</h1>

<p>A Xeon server with the following specs was used for this assignment:</p>

<p>Final output of <code>cat /proc/cpuinfo</code></p>
<pre><code>processor	: 15
vendor_id	: GenuineIntel
cpu family	: 6
model		: 79
model name	: Intel(R) Xeon(R) CPU E5-2637 v4 @ 3.50GHz
stepping	: 1
microcode	: 0xb000021
cpu MHz		: 2807.360
cache size	: 15360 KB
physical id	: 1
siblings	: 8
core id		: 3
cpu cores	: 4
apicid		: 23
initial apicid	: 23
fpu		: yes
fpu_exception	: yes
cpuid level	: 20
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer xsave avx f16c rdrand lahf_lm abm 3dnowprefetch ida arat epb invpcid_single pln pts dtherm intel_pt kaiser tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm rdseed adx smap xsaveopt cqm_llc cqm_occup_llc
bugs		:
bogomips	: 7002.86
clflush size	: 64
cache_alignment	: 64
address sizes	: 46 bits physical, 48 bits virtual
power management:
</code></pre>

<p>Top output of <code>cat /proc/meminfo</code>:</p>
<pre><code>MemTotal:       65598536 kB
MemFree:        44152804 kB
MemAvailable:   55485324 kB
Buffers:              80 kB
Cached:         15153880 kB
SwapCached:         4144 kB
</code></pre>

<p>The CPU details for this chip can be found here: https://en.wikichip.org/wiki/intel/xeon_e5/e5-2637_v4</p>

<p>The cache values for this processor are as follows:</p>
<ul>
  <li>L1 cache - 32 KB per chip per core (x4).</li>
  <li>L2 cache - 256 KB per chip per core (x4).</li>
  <li>L3 cache - 10 MB per chip per chip (shared).</li>
</ul>

<h1 id="matrix-parameters">Matrix parameters</h1>

<p>For this experiment, I’m using a 1000x1000 matrix of doubles, each matrix generated 
using a simple function <code>i*j + N</code>.</p>

<h1 id="the-initial-code">The initial code</h1>

<p>I started off with a basic O(N^3) multiplication algorithm that looks like this:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i=<span style="color:#00D">0</span>; i&lt;N; i++) {
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j=<span style="color:#00D">0</span>; j&lt;N; j++) {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> k=<span style="color:#00D">0</span>; k&lt;N; k++) {
      C[i*N + j] += A[i*N + k] * B[k*N + j];
    }
  }
}
</pre></td>
</tr></table>
</div>

<p>This produced the following results:</p>
<pre><code>N = 1000. time: 4.53809 s. Gflops: 0.440714
</code></pre>
<p>Very slow indeed. Lets begin some optimization.</p>

<h1 id="loop-interchange">Loop interchange</h1>

<p>It so happens that when we write a simple 3-level loop for matmul where the result is obtained
one element at a time, we need to access the elements in a manner that does not produce the
same stride and is not therefore easily vectorizable. If the loops are interchanged they
will all become stride-1.</p>

<p>The new loop structure would look like this:</p>
<pre><code>for i = 0:N
  for k = 0:N
    for j = 0:N
      C(i,j) = A(i,k)*B(k,j)
</code></pre>
<p>This simple optimization gives somewhat faster results:</p>
<pre><code>N = 1000. time: 3.29635 s. Gflops: 0.606731
</code></pre>

<p>This mainly happens because now most elements are accessed in order of memory and there are
less cache misses. The cache loading/unloading is done by the OS and compiler until this
step and we have not intervened with these things at all.</p>

<p>Here’s the loop in code with comments as to movement of the pointer:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre><span style="color:#777">// corresponds to rowwise movement of C (slowest). Indicates</span>
<span style="color:#777">// that one panel (horizontal) of C is populated at one time.</span>
<span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; N; i += NR) {
  <span style="color:#777">// corresponds to column of A. Moves with the rows of B.</span>
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> k = <span style="color:#00D">0</span>; k &lt; N; k += KC) {
    <span style="color:#777">// corresponds to the row of B. Moves with the columns of A.</span>
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; N; j += MC) {
      C[i*N + j] += A[i*N + k] * B[k*N + j];
    }
  }
}
</pre></td>
</tr></table>
</div>

<h1 id="loop-unrolling">Loop unrolling</h1>

<p>Slight modifications to the loops which involves unrolling some part of the loop and advancing
at a faster pace than one increment per loop iteration can reduce the overhead of updating the
variables associated with looping. Also, there is a special advantage to advancing the loop
counter by a factor of 4 (for double numbers). The data is brought into the cache line 64 bytes
at a time. This means that accessing data in chunks of 64 bytes reduces the cost of memory
movement between the memory layers.</p>

<p>After using a loop advacement of 5, the result improves to this:</p>
<pre><code>N = 1000. time: 2.04914 s. Gflops: 0.976018
</code></pre>

<p>The code for doing this looks like so:</p>
<pre><code>for (int i = 0; i &lt; N; i += NR) {
  for (int k = 0; k &lt; N; k += KC) {
    for (int j = 0; j &lt; N; j += MC) { // advance by block size
      //macro_kernel(A, B, C, i, j, k);
      A_ptr = A[i*N + k];
      B_ptr = &amp;B[k*N + j];
      C_ptr = &amp;C[i*N + j];
        
      *C_ptr += (*A_ptr)  * (*B_ptr);
      *(C_ptr+1) += (*A_ptr) * (*(B_ptr+1));
      *(C_ptr+2) += (*A_ptr) * (*(B_ptr+2));
      *(C_ptr+3) += (*A_ptr) * (*(B_ptr+3));
      *(C_ptr+4) += (*A_ptr) * (*(B_ptr+4));
    }
  }
}
</code></pre>

<h1 id="use-of-registers">Use of registers</h1>

<p>You can use the C++ <code>register</code> keyword when declaring a variable in order to suggest to the
compiler that the variable is supposed to stay in the register.</p>

<p>These variables are best used in cases where the variable needs to be used as an accumulator
for storing the repeating sum of some result.</p>

<p>For example, the macro kernel can be written this way:</p>
<pre><code>register double a0 = A(0,k), a1 = A(1,k), a2 = A(2,k), a3 = A(3,k);
  for (int j = 0; j &lt; N; j += 1) {
    C(0,j) += a0*B(k,j);
    C(1,j) += a1*B(k,j);
    C(2,j) += a2*B(k,j);
    C(3,j) += a3*B(k,j);
  }
</code></pre>
<p>This results in the following result:</p>
<pre><code>N = 1000. time: 2.2037 s. Gflops: 0.907564
</code></pre>

<h1 id="blocking">Blocking</h1>

<p>In general, it is helpful to compute the matrix in blocks rather than individually so that
we can take advantage of various vector operations and cache blocking. A simple blocking
technique would be to compute a block of 4x4 matrix at one time. For this purpose we can
use SSE instructions that allow computing multiplications of multiple numbers in parallel.</p>

<p>We first start off by trying to multiply the matrix in 4x4 blocks. This can be done by
modifying the loops</p>

<h2 id="aligned-memory-allocation">Aligned memory allocation</h2>

<p>The <code>posix_memalign</code> function allocates memory along a given alignment. Upon successful
completion, it returns a pointer value that is a multiple of the alignment variable. It
is helpful in cases where you want to use SIMD operations with a chunk of memory.</p>

<p>Source: http://pubs.opengroup.org/onlinepubs/009695399/functions/posix_memalign.html</p>

<h2 id="notes-on-blocking">Notes on blocking</h2>

<p>Q: If the numbers are stored in row major order anyway, what difference does it
make whether we use the packing order or the default row major order?
A: When multiplying the block of A with the panel of B, we proceed from left to
right of the panel. Due to this, the numbers of B get accessed in a stride and not in
sequentially. Packing would ensure that they are sequential.</p>

<h2 id="simd-instructions">SIMD instructions</h2>

<p>Intel introduced SIMD instructions in the their processors a while ago. These are now 
accessible via the AVX or SSE data types.</p>

<p>The AVX data types allow the use of 16 YMM registers. These can hold 4 x 64-bit double
numbers or 8 x 32-bit floats.</p>

<p>On the intel Broadwell CPU, there is support for AVX2 and SSE3 instruction sets. According
to intel, AVX is a natural progression of SSE.</p>

<h3 id="notes-on-simd">Notes on SIMD</h3>

<p>SIMD is mainly expressed using two kinds of instructions: SSE and AVX. AVX works with a
kind of register called <code>YMM</code> registers. AVX uses 16 such registers. Each YMM register
contains 4 64-bit double-precision floating point numbers.</p>

<p>In order to use these instructions, you need to include the <code>xmmintrin.h</code> header file into
your code. Data that is to be used using SIMD needs to be packed using the <code>__m256d</code> if
using the YMM registers useful for AVX instructions.</p>

<h3 id="simd-with-gcc">SIMD with gcc</h3>

<p>GCC -O0 is no optimization at all and when using with SIMD uses up about 7-8 instructions
per load of YMM registers.</p>

<p>GCC -O3 optimizations create some blazingly fast and highly optmized SIMD code. In this
section I will document some of the low level instructions that are used by SIMD
and which can be directly used from C++ code in order to produce highly optimized
matrix multiplication.</p>

<h4 id="gcc-inline-assembly">GCC inline assembly</h4>

<p>There’s two kinds of inline assembly - intel assembly and AT&amp;T assembly. GCC uses AT&amp;T
and all examples below will stick with that convention. It is important to note that
AT&amp;T assembly has the source operand as the first operand of the instruction and the
destination as the second operand.</p>

<p>All instructions must end with a <code>\n\t</code> for breaking the line and moving to the next
instruction field.</p>

<p>Link : https://www.codeproject.com/Articles/15971/Using-Inline-Assembly-in-C-C</p>

<h4 id="gcc-extended-assembly">GCC extended assembly</h4>

<p>GCC has a special extended assembly instruction syntax that allows you to freely pass
C variables to and from assembly code. It allows you to specify variables and use
them within the assembly instructions.</p>

<p>It has the following format:</p>
<pre><code>asm [volatile] ( AssemblerTemplate 
                 : OutputOperands 
                 [ : InputOperands
                 [ : Clobbers ] ])
</code></pre>
<p>This allows you to specify an ‘assembler template’ inside which you can specify the
kind of assembly instructions that you want along with a template for input and output
operands. The compiler will read this template along with the specified parameters
and replace the parameters in the template before outputting the assembly code.</p>

<p>The output and input operands have to specified in a given format for correct processing:</p>
<pre><code>[ [asmSymbolicName] ] constraint (cvariablename)
</code></pre>
<p>The first <code>[ [asmSymbolicName] ]</code> is usually expressed in the assembler template. The
<code>constraint</code> is a literal string that specifies certain constraints on the placement of 
the operand. Output constraints <em>must</em> begin with either <code>=</code> (a variable overwriting an
existing value) or <code>+</code> (when reading and writing). After this prefix, specify another
constraint where the value resides. Use <code>r</code> for register and <code>m</code> for memory or <code>rm</code> for
register or memory (compiler will choose).</p>

<p>After specifying input and output variables, if your asm modifies any of the system
registers as a side effect, they should be specified in the <code>Clobbers</code> field.</p>

<p>Link : https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html</p>

<h4 id="register-naming-and-conventions">Register naming and conventions</h4>

<p>Registers names being with a <code>%</code>. So register <code>rdx</code> is named as <code>%rdx</code>. The special purpose
ymm registers are used with a suffix of the number of the register. So you can refer to the
3rd YMM register using <code>%ymm3</code>.</p>

<h4 id="immediate-operands">Immediate operands</h4>

<p>Immediate operands (or literals) are marked using a <code>$</code>. So to add <code>5</code>, register 
<code>eax</code> would be <code>add $5, %eax</code>.</p>

<h4 id="indexing">Indexing</h4>

<p>Indexing or indirection is done by enclosing the index register or indirection 
memory cell address in parentheses. For example <code>mov %edx, (%eax)</code> will move the
data pointed to by <code>%eax</code> to <code>%edx</code>. Specifying a number before the bracket will</p>

<h4 id="mov-instructions">mov instructions</h4>

<p><code>movq</code> is used for moving 64-bit words from source to destination and <code>movl</code> is used for 32-bit.</p>

<p>Link : https://www.quora.com/What-is-the-difference-between-movq-and-movl-assembly-instruction</p>

<h4 id="instruction-vmovapd">Instruction vmovapd</h4>

<p>This is the assembly equivalent of <code>_mm256_load_pd(double*)</code>. It accepts two instructions,
source (second operand) and destination (first operand).</p>

<p>Link : https://www.felixcloutier.com/x86/MOVAPD.htmlx</p>

<p>A sample <code>vmovapd</code> from gcc looks like <code>vmovapd	(%rdx), %ymm13</code>. This is assigning
the contents in the pointer</p>

<h4 id="instruction-vbroadcastsd">Instruction vbroadcastsd</h4>

<p>Broadcasts a value kept at a pointer to a YMM register.</p>

<h4 id="instruction-vfmadd231pd">Instruction vfmadd231pd</h4>

<p>Performs a set of SIMD multiply-add computation on packed double-precision 
floating-point values using three source operands and writes the multiply-add
results in the destination operand. The destination operand is also the first
source operand. The second operand must be a SIMD register. The third source
operand can be a SIMD register or a memory location.</p>

<p>Link : https://www.felixcloutier.com/x86/VFMADD132PD:VFMADD213PD:VFMADD231PD.html</p>

<h1 id="packing-data-into-caches">Packing data into caches</h1>

<p>According to the GotoBLAS (and later BLIS) approach, it is necessary to pack the panels of 
A and B in such a way that the data within is sequentially accessible. This requires some
reconstruction of each mini-panel before performing the actual computation.</p>

<p>The BLISlab framework uses a novel approach for this purpose. It first stores the pointers
of all the elements that need to be copied into a new array using an array to pointers of 
doubles. It then simply dereferences these pointers and copies them into the packed array.</p>

<p>Here’s some C code that makes this happen:</p>

<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> p; 
<span style="color:#0a8;font-weight:bold">double</span> *b_pntr[ SIZE ]; <span style="color:#777">// create array of pointers of doubles.</span>

<span style="color:#777">// ... code that copies pointers of packed array to b_pntr</span>

<span style="color:#777">// deference b_pntr and copy data one by one to packB</span>
<span style="color:#080;font-weight:bold">for</span> (p = <span style="color:#00D">0</span>; p &lt; SIZE; p++) {
  *packB++ = *b_pntr[ p ] ++;
}
</pre></td>
</tr></table>
</div>

<h1 id="using-pointers">Using pointers</h1>

<p>When you call something like <code>C[i*N + j]</code> for getting the value in memory of an element in C,
you are wasting time in calculating the address of the element in C where it resides. Instead,
you directly use pointers to advance the pointer value in memory rather than such explicit
calculation.</p>

<p>For example, to set the value of all elements of an array C to 0:</p>
<pre><code>double *cp;
for ( j = 0; j &lt; n; j ++ ) { 
  cp = &amp;C[ j * ldc ];
  for ( i = 0; i &lt; m; i ++ ) { 
    *cp++ = 0.0;
  }
}
</code></pre>

<p>After using pointers in the matrix multplication, it looks like this:</p>
<pre><code>N = 1000. time: 1.71545 s. Gflops: 1.16587
</code></pre>

<h1 id="multithreading-optimization">Multithreading optimization</h1>

<p>Using the <code>for</code> loop openmp threading directive led to a pretty massive speedup. Here’s the
results with a <code>#pragma openmp parallel for</code> for the above stride-oriented code:</p>
<pre><code>N = 1000. time: 0.815704 s. Gflops: 2.45187
</code></pre>
<p>This is faster than gemm! Wonder what does dgemm do internally that causes it to not
fully exploit the resources of the CPU.</p>

<p>How exactly does the omp for loop parallelization work?</p>

<p>Using pointers with the above implementation produces the following result:</p>

<h1 id="blislab">BLISlab</h1>

<p>BLISlab provides a framework for efficiently implementing your own version of BLAS. This is
particularly handy for people who want to implement a BLAS of their own on any machine.</p>

<h2 id="blislab-notes">BLISlab notes</h2>

<p>In original BLISlab framework it is important to remember that the A matrix is stored
in row-major and B in column-major.</p>

<h1 id="results-on-tsubame">Results on TSUBAME</h1>

<h2 id="notes-on-tsubame">Notes on TSUBAME</h2>

<p>The TSUBAME users guide can be found <a href="http://www.t3.gsic.titech.ac.jp/docs/TSUBAME3.0_Users_Guide_en.html">here</a>.</p>

<p>The <code>qsub</code> command is used for submitting a jobs. A ‘job script’ is used for this
purpose. A sample job script looks like so:</p>
<pre><code>#!/bin/sh
#$ -cwd
#$ -l f_node=1
#$ -l h_rt=0:02:00
./a.out 1024
</code></pre>
<p>In the above program the lines that begin with <code>#$</code> specify various parameters that specify
the kind of node and number of such nodes (<code>f_node</code> in this case) and the time for which 
we want to reserve the node (2 min in the above case). At the end of the file we specify
the executable name and the parameters that are to be passed to it.</p>

<p>You can check the status of your job with the <code>qstat</code> command. A sample execution looks like so:</p>
<pre><code>17M38101@login0:~/&gt; qstat
job-ID     prior   name       user         state submit/start at     queue                          jclass                         slots ja-task-ID 
------------------------------------------------------------------------------------------------------------------------------------------------
   2627115 0.00000 job.sh     17M38101     qw    06/10/2018 18:23:45  
</code></pre>

<p>Once the job is done, it will deposit the error and output in separate files in your pwd.</p>

<p>You can use <code>qdel &lt;task_id&gt;</code> for deleting a submitted job.</p>

<h2 id="debugging-using-tsubame-tools">Debugging using TSUBAME tools</h2>

<p>Tools like Allinea DDT can be used from TSUBAME for debugging parallel applications.</p>

<p>For this purpose you need to switch on X window forwarding in your login session and
start an interactive session on TSUBAME. When you ssh into TSUBAME you should also
login using the <code>-Y</code> option.</p>

<p>To test if X forwarding works, use a command like <code>xterm</code> and see if its opens a window
locally. You can use Allinea DDT for parallel debugging.</p>

<p>After compiling, you can execute the binary using <code>ddt a.out</code> command.</p>

<p>Link:</p>
<ul>
  <li>https://kb.iu.edu/d/bdnt</li>
  <li>https://computing.llnl.gov/tutorials/allineaDDT/Examples.pdf</li>
</ul>

<h2 id="cpu-information-on-f-node">CPU information on f-node</h2>

<p>On an f-node of TSUBAME, the CPU information is as follows:</p>
<pre><code>processor	: 55
vendor_id	: GenuineIntel
cpu family	: 6
model		: 79
model name	: Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz
stepping	: 1
microcode	: 0xb00001f
cpu MHz		: 2899.022
cache size	: 35840 KB
physical id	: 1
siblings	: 28
core id		: 14
cpu cores	: 14
apicid		: 61
initial apicid	: 61
fpu		: yes
fpu_exception	: yes
cpuid level	: 20
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch ida arat epb invpcid_single pln pts dtherm intel_pt kaiser tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm rdseed adx smap xsaveopt cqm_llc cqm_occup_llc
bugs		:
bogomips	: 4801.76
clflush size	: 64
cache_alignment	: 64
address sizes	: 46 bits physical, 48 bits virtual
power management:
</code></pre>
<p>More detailed information about the processor can be found <a href="http://www.spec.org/cpu2006/results/res2016q3/cpu2006-20160725-43026.pdfx">here</a>.</p>

<p>The cache levels are as follows:</p>
<ul>
  <li>L1 cache - 32 kb per chip per core.</li>
  <li>L2 cache - 256 kb per chip per core.</li>
  <li>L3 cache - 35 MB per chip per chip.</li>
</ul>

<h1 id="notes-on-computer-architecture">Notes on computer architecture</h1>

<h2 id="cache-access">Cache access</h2>

<p>When the processor requests a particular chunk of memory, it is first copied into the cache
from the main memory (assuming that the cache is ‘empty’ for now). The closer the data is
from the processor, the fewer clock cycles it needs to wait for performing instructions. Every
time during a memory access, the processor first checks the cache for the data, and in case
the data is not present it will fetch the data from the memory. This is called a cache miss.
Data is copied into cache from the memory every time a cache miss occurs. It is assumed that 
data that is adjacent to data that is being used has a high probability of being accessed. This
is called spatial locality. Cache misses are handled by hardware.</p>

<p>The <em>miss rate</em> is simply the component of cache accesses that result in a miss. When the
processor fetches data from the memory into the cache, it will fetch a fixed-size <em>block</em>
or <em>line run</em> chunk of data that contains the requested data.</p>

<h2 id="cache-hierarchies">Cache hierarchies</h2>

<p>Caches are typically L1, L2 and L3. L1 being closest to the CPU (and least capacity) and L3
being farthest (most capacity).</p>

<h2 id="my-processor-config">My processor config</h2>

<p>I’m using the TSUBAME login node which has a <a href="https://en.wikichip.org/wiki/intel/xeon_e5/e5-2637_v4">Intel(R) Xeon(R) CPU E5-2637 v4</a> processor.
The L1 and L2 caches are per-core whereas the L3 cache is shared.
The wikichip page says it has the following cache config:
*</p>

<h1 id="papers">Papers</h1>

<ul>
  <li>BLISlab paper: sandbox for optimizing BLAS.</li>
  <li>Anatomy of high performance matrix multiplication.</li>
  <li>Anatomy of high-performance many-threaded matrix multiplication.</li>
</ul>

<h2 id="brief-paper-summaries">Brief paper summaries</h2>

<h3 id="anatomy-of-high-performance-matrix-multiplication">Anatomy of high performance matrix multiplication</h3>

<p>This paper describes what is currently accepted as the most effective approach,
to implementation, also known as the GotoBLAS approach.</p>

<h1 id="resources">Resources</h1>

<ul>
  <li>http://jguillaumes.dyndns.org/doc_intel/f_ug/vect_int.htm</li>
  <li><a href="https://stackoverflow.com/questions/25475186/sgemm-does-not-multithread-when-dgemm-does-intel-mkl">sgemm does not multithread sometimes.</a></li>
  <li><a href="http://www.catb.org/esr/structure-packing/">Structure packing in C.</a></li>
  <li><a href="https://software.intel.com/en-us/articles/intel-xeon-phi-processor-7200-family-memory-management-optimizations">Intel 7200 family memory management.</a></li>
  <li><a href="https://github.com/flame/how-to-optimize-gemm/wiki">gemm optimization</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">Advanced Vector Instructions (AVX)</a></li>
  <li><a href="https://www.polyhedron.com/web_images/intel/productbriefs/3a_SIMD.pdf">The significance of SSE and AVX.</a></li>
  <li><a href="https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX">Crunching numbers with AVX2</a></li>
  <li><a href="https://austingwalters.com/the-cache-and-multithreading/">Cache and multithreading</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emacs Org-mode Notes]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/20/emacs-org-mode-notes/"/>
    <updated>2018-04-20T22:21:42+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/20/emacs-org-mode-notes</id>
    <content type="html"><![CDATA[<p>Note taking is getting quite tedious these days with just markdown and written notes,
so I started using org-mode, which is supposed to be very good. The results so far have
been fabulous. In this post I will docuement the things that I learned about org-mode
and will update the post as and when I find out new things.</p>

<h1 id="expand-and-collapse-headers">Expand and collapse headers</h1>

<p>Headers are written with <code>*</code>. More <code>*</code>’s you add more the level of indentation. Going to
a header title and pressing TAB will collapse or expand the contents of the header.</p>

<h1 id="tagging-and-searching">Tagging and searching</h1>

<p>Link: https://orgmode.org/worg/org-tutorials/advanced-searching.html</p>

<p>Org mode has some powerful search features that allow you to tag certain headers with
certain tags that allow you to search headers by tag. The tag has the syntax <code>:&lt;tag_name&gt;:</code>
after a header. So if you want a header <code>foo</code> as <code>bar</code> you can do:</p>
<pre><code>* foo :bar:
</code></pre>

<h1 id="writing-presentations">Writing presentations</h1>

<p>Link: https://orgmode.org/worg/exporters/beamer/tutorial.html</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash Scripting to Automate Porting to Other Machines]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/20/bash-scripting-to-automate-porting-to-other-machines/"/>
    <updated>2018-04-20T13:00:51+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/20/bash-scripting-to-automate-porting-to-other-machines</id>
    <content type="html"><![CDATA[<p>I need to log into multiple machines every now and then and its really annoying to
set everything up from scratch. Here’s some simple things I did with bash scripting
for automating most of my workflow.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#bash-basics">Bash basics</a>
    <ul>
      <li><a href="#if-statements">If statements</a></li>
    </ul>
  </li>
  <li><a href="#scripting-protips">Scripting protips</a>
    <ul>
      <li><a href="#checking-env-variables">Checking env variables</a></li>
      <li><a href="#checking-for-programs">Checking for programs</a></li>
    </ul>
  </li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="bash-basics">Bash basics</h1>

<p>A bash must have the line <code>#!/bin/bash</code> on the 1st line to let the OS know that this
is a bash script.</p>

<h2 id="if-statements">If statements</h2>

<p>You can check for existence of environment variables and execute specfic things. To
check whether a env variable exists, following syntax can be used:</p>

<p>If statements have the basic syntax:</p>
<pre><code>if [ &lt;some test&gt; ]; then
  &lt;commands&gt;
elif [ &lt;some test&gt; ]; then
  &lt;commands&gt;
else
  &lt;commands&gt;
fi
</code></pre>
<p>The square brackets in the above <code>if</code> statement are actually a reference to the command
<code>test</code>. This means that all operators that <code>test</code> allows may be used here as well. See
<code>man test</code> to the see capabilities of the <code>test</code> command.</p>

<h1 id="scripting-protips">Scripting protips</h1>

<h2 id="checking-env-variables">Checking env variables</h2>

<p>You can just check whether env variables exist or not with <code>if $VAR_NAME</code>. You need to
specify a call to <code>test</code> inside square brackets and specify <code>-z</code> if you want to check
whether the variables does not exist and <code>-n</code> if you want to check if the variable
exists.</p>

<p>For example, cheking if <code>$SERVER_ENV</code> variable exists or not will look like this:</p>
<pre><code>if [-n "$SERVER_ENV"]; then
    echo "SERVER_ENV exists"
fi
</code></pre>
<h2 id="checking-for-programs">Checking for programs</h2>

<p>If you want to check whether a particular program exists or not, use <code>hash &lt;command_name&gt;</code>.</p>

<p>For example, to see if git exists and print an error if not:</p>
<pre><code>if ! hash git 2&gt;/dev/null; then
    echo "Please install git before proceeding."
    exit 1
fi
</code></pre>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://stackoverflow.com/questions/592620/check-if-a-program-exists-from-a-bash-script">Checking whether program exists.</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Writing Snippets for Yasnippet in Emacs]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/18/writing-snippets-for-yasnippet-in-emacs/"/>
    <updated>2018-04-18T13:40:37+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/18/writing-snippets-for-yasnippet-in-emacs</id>
    <content type="html"><![CDATA[<p>In order to make typing things easier I’ve been yasnippet with some custom snippets
of mine. The yasnippet devs have been kind enough to offer plenty of detailed tutorials
on how to write your own snippets. In this post I will highlight the steps that I took
to write some simple ones. For more detailed information you should of course read the
actual yasnippet docs.</p>

<h1 id="getting-started">Getting started</h1>

<p>Just invoke <code>M-x yas-new-snippet</code> to invoke a new buffer that opens in a major mode
called <code>snippet-mode</code>. This mode is created specifically for creating yasnippets and
is very useful for this purpose. The buffer that it opens will have a template for
writing a snippet. There are some lines at the beginning that start with <code>#</code>, these
lines are comments and are also used for specifying ‘properties’ of the snippet.</p>

<p>For example, here’s a header for a snippet that I wrote for expanding <code>@param</code> listing
in YARD documentation:</p>
<div class="language-snippet highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre># -*- mode: snippet -*-
# name: Write @params attribute of YARD docs.
# key: param
# group: yard_docs
# contributor: Sameer Deshmukh (@v0dro)
# --
</pre></td>
</tr></table>
</div>

<p>In the above header, the <code>name:</code> attribute is a string describing the purpose of this
snippet. <code>key:</code> is an important attribute that describes the key that yasnippet will
lookout for when expanding a snippet. <code>group</code> specifies which group a snippet would
belong to when it is listed in the <code>yas-describe-tables</code> table (it has no other
purpose than grouping). The <code>contributor:</code> field is just used for writing the name
of the contributor.</p>

<h1 id="snippet-syntax">Snippet syntax</h1>

<p>Some tutorials say that the snippet syntax is similar to that of TextMate, but I’ve
never used TextMate so I have no idea. I’ll now describe in as much detail as is required
the yasnippet snippet syntax in this section.</p>

<p>The basic work-flow is that you write some text in the file along with some markup for specifying
places where you want the user to type things when they jump across the snippet (the thing
that happens when you keep pressing TAB after typing something after expanding the snippet).</p>

<p>Following is the text to specify an expansion for @param attribute in the <a href="">YARD syntax</a>:</p>
<pre><code># @param $1 [$2] $3
$0
</code></pre>
<p>In the above text, <code># @param</code> is the text that specifies that this is a Ruby comment and the
<code>@param</code> is a YARD directive that specifies that this is a param being defined. The <code>$</code> followed
by the number are the TAB stop fields. These will specify the first, second and third place in
the text that the cursor will go to after the user presses TAB. The <code>$0</code> has a special significance.
It is the ‘TAB stop field’. This will be the exit point of the snippet once the user is done
pressing TAB for the final time.</p>

<p>The above snippet can be further improved to provide default values for the TAB stop fields by
replacing it with the following syntax:</p>
<pre><code># @param ${1: arg name} [${2: data type}] ${3: description.}
$0
</code></pre>
<p>The <code>${N:description}</code> syntax can be used for providing default values.</p>

<h1 id="organizing-snippets">Organizing snippets</h1>

<p>Snippets are organized by sub-directories by the major-mode in which they belong.
For example:</p>
<pre><code>|-- c-mode
|   `-- printf
|-- java-mode
|   `-- println
`-- text-mode
    |-- email
    `-- time
</code></pre>
<p>By default, your personal snippets collection lives inside <code>~/.emacs.d/snippets</code>.</p>

<p>In order to save the snippet file, press <code>C-c C-c</code>. It will prompt your for entering the
folder where the snippet is to be saved. Keep the folder name as the major mode and the
file name as the key of the snippet.</p>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://joaotavora.github.io/yasnippet/snippet-development.html">Detailed tutorial on writing snippets.</a></li>
  <li><a href="https://joaotavora.github.io/yasnippet/snippet-organization.html">Organizing snippets.</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Emacs for LaTeX Editing]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/14/setup-emacs-for-latex-editing/"/>
    <updated>2018-04-14T17:23:09+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/14/setup-emacs-for-latex-editing</id>
    <content type="html"><![CDATA[<p>I’m writing this blog as I’m learning latex and setting up emacs to use it. Previously
I mainly use LyX for writing research papers but the lack of text leads to lesser
customization options sometimes, which is why I’ll be shifting to plain text LaTeX
henceforth.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#latex-protips">Latex protips</a></li>
  <li><a href="#emacs-latex-setup">Emacs latex setup</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="latex-protips">Latex protips</h1>

<h2 id="structure-of-documents">Structure of documents</h2>

<p>Docs consist of preamble and main document. The preamble contains commands for telling latex
which packages you will use and what kind of document you want to setup.</p>

<p>A sample preamble looks like so:</p>
<pre><code>% Preamble
% ---
\documentclass{article}

% Packages
% ---
\usepackage{amsmath} % Advanced math typesetting
\usepackage[utf8]{inputenc} % Unicode support (Umlauts etc.)
\usepackage{hyperref} % Add a link to your document
\usepackage{graphicx} % Add pictures to your document
\usepackage{listings} % Source code formatting and highlighting
</code></pre>

<p>Only the <code>documentclass</code> command is mandatory. The rest are optional. <code>usepackage</code> cannot be
used inside the main document. When using the <code>article</code> documentclass, latex will add the page
numbers automatically to the bottom of each document.</p>

<p>The main document is contained inside the <code>document</code> environment like this:</p>
<pre><code>\begin{document}
% ...
% ... Text goes here
% ...
\end{document}
</code></pre>

<h2 id="environments">Environments</h2>

<p>Latex comes with many pre-defined environments which you can use for setting up your
documents with minimal work. They come with some useful defaults too. For example, to
write a new Design Thinking assignment, I wrote the following preamble:</p>
<div class="language-latex highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre>\documentclass{article}
\title{Assignment 2: One hour observation}
\date{2018-4-22}
\author{Sameer Deshmukh}
</pre></td>
</tr></table>
</div>
<p>Then using the <code>\maketitle</code> command inside the document body will directly create the
title page for us.</p>

<h2 id="sections-and-paragraphs">Sections and paragraphs</h2>

<p>Add sections using <code>\section{Section-name}</code> and sub-sections using <code>\subsection{sub-sec-name}</code>.
You can add as many <code>sub</code>’s to the subsection in order to specify multiple subsections. Using
the <code>\paragraph{Name goes here}</code> command will add a paragraph to the section.</p>

<h2 id="adding-images">Adding images</h2>

<p>You need the <code>graphicx</code> package to use images in your documents. Then use the 
<code>\graphicspath{ {folder-name/} }</code> command to tell latex the directory in which the images
are stored w.r.t the current directory. These should be declared in the preamble.</p>

<p>You can then use the <code>\includegraphics{graphic-name}</code> command to show images in your
document wherever you want.</p>

<p>You can specify various parameters to <code>includegraphics</code> for working with the image like
height, width and scaling inside square brackets. For example:”</p>
<pre><code>\includegraphics[width=3cm, height=4cm]{image}
</code></pre>
<p>Just seeting width to <code>\textwidth</code> and leaving out height will keep the default height
and set the width to the width of the text in the document. Like this:</p>
<pre><code>\includegraphics[width=\textwidth]{image}
</code></pre>
<p>See the <a href="https://www.sharelatex.com/learn/Inserting_Images#Reference_guide">reference guide</a> for
a more detailed description of the lengths and units that can be specified.</p>

<h2 id="useful-commands">Useful commands</h2>

<ul>
  <li>New page - <code>\newpage</code>.</li>
  <li>Make a title page - <code>\maketitle</code>.</li>
</ul>

<h3 id="text-formatting">Text formatting</h3>

<p>Use <code>\textbf{text}</code> for bold text, <code>\underline{text}</code> for underlined text and
<code>\textit{text}</code> for italics.</p>

<h3 id="symbols">Symbols</h3>

<ul>
  <li>Empty set: <code>\emptyset</code> is a 0 with a back slash through it.</li>
  <li>Uptack or falsum: <code>\bot</code> looks like Japanese 上 but without the upper dash.</li>
  <li>Is a member of: <code>\in</code>, for denoting that something is a part of a set.</li>
  <li>Not equal to: <code>\neq</code>.</li>
  <li>Set union: <code>\cup</code></li>
</ul>

<h2 id="writing-algorithms">Writing algorithms</h2>

<h3 id="setup-of-environment">Setup of environment</h3>

<p>I’m using the <code>algorithmicx</code> package for writing algorithms. This package will be installed
with the <code>texlive-full</code> package on the Ubuntu repos. Put the following lines in the preamble
to use:</p>
<pre><code>\usepackage{algorithm}
\usepackage{algpseudocode}
</code></pre>
<p>This is because algorithmicx pacakage is just a bundle of style files with macros that build
on top of <code>algorithm</code> and <code>algorithmic</code>. It does not define a package of itself.</p>

<p>The algorithms should lie inside the <code>algorithm</code> environment. You can use <code>\caption</code> and
<code>\label</code> to define those properties respectively. For example:</p>
<pre><code>\begin{algorithm}
  \caption{Leader election in arbitrary graph}
  \label{leader_election}
\end{algorithm}
</code></pre>

<h3 id="writing-algorithms-1">Writing algorithms</h3>

<p>The actual algorithm should be written inside the <code>algorithmic</code> block. An optional numerical
argument can specify in how many lines do you want the lines to be numbered. Example:</p>
<pre><code>\begin{algorithmic}[1]
  \State \textbf{when} {START} \textbf{is received do}
\end{algorithmic}
</code></pre>

<h3 id="basic-commands-for-algorithms">Basic commands for algorithms</h3>

<p>Variables and program statements in general should be written inside <code>$</code> signs so that they
will be italicized. Here’s a list of basic commands for writing various tasks:</p>

<ul>
  <li><code>\gets</code>: Assignment using a left pointing arrow like <code>&lt;-</code>.</li>
  <li>For loop: <code>\For{&lt;condition&gt;} &lt;text&gt; \EndFor</code></li>
  <li>Comments: Use <code>\Comment</code> for comments.</li>
</ul>

<h2 id="checking-for-installed-latex-packages">Checking for installed latex packages</h2>

<p>Use the <code>kpsewhich</code> command to see if a package is installed (alongwith its path). Example:</p>
<pre><code>kpsewhich algorithm.sty 
</code></pre>

<h2 id="writing-custom-latex-commands">Writing custom latex commands</h2>

<p>If you want to create certain kinds of custom blocks or more crazy things, you can create
your own custom commands that make such tasks easier. Below is the code for a custom <code>When</code>
command that will insert a <code>When</code> block into the code for denoting certain events.</p>
<pre><code>\algrenewcommand\algorithmicindent{3.0em}
\algnewcommand{\IIf}[1]{\State\algorithmicif\ #1 \algorithmicthen}
\algnewcommand{\EndIIf}{\unskip\ \algorithmicend\ \algorithmicif}
\newcommand*\Let[2]{\State #1 $\gets$ #2}
\algdef{SN}[when]{When}{EndWhen}
[3][\null]{
  \ifthenelse{\equal{#1}{\null}}{
    \ifthenelse{\equal{#3}{}}{
      {\bf when} \Call{#2}{\null} {\bf is received do}
    }{
      {\bf when} \Call{#2}{#3} {\bf is received do}
    }
  }{
    \ifthenelse{\equal{#3}{}}{
      {\bf when} \Call{#2}{\null} {\bf is received from #1 do}
    }{
      {\bf when} \Call{#2}{#3} {\bf is received from #1 do}
    }
  }
}
\renewcommand{\thealgorithm}{}
</code></pre>

<h1 id="emacs-latex-setup">Emacs latex setup</h1>

<p>I mainly followed other blog posts to setup this one. First install texlive and auctex packages
from your package manager.</p>

<p>Then add the following to your emacs init file:</p>
<pre><code>;; setup auctex
(require `tex-site)
(require `tex-style)
(add-hook `LaTeX-mode-hook `turn-on-reftex)

;; spellcheck in LaTex mode
(add-hook `latex-mode-hook `flyspell-mode)
(add-hook `tex-mode-hook `flyspell-mode)
(add-hook `bibtex-mode-hook `flyspell-mode)

;; Math mode for LaTex
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
</code></pre>

<h2 id="auctex-protips">Auctex protips</h2>

<p>Using auctex for your document editing provides some powerful features for editing and previewing
documents. Here’s a list of what can be done:</p>
<ul>
  <li>Preview a section right inside the buffer: <code>C-c C-p C-d</code>.</li>
  <li>Preview the entire buffer: <code>C-c C-p C-b</code>.</li>
  <li>Compile into a PDF: <code>C-c C-c</code>.</li>
</ul>

<h2 id="preview-latex-symbols-within-emacs">Preview latex symbols within emacs</h2>

<h2 id="view-formatted-pdf">View formatted PDF</h2>

<p>The <code>docview-mode</code> can be used for previewing a PDF file from within emacs. This mode is bundled
with emacs 24. Put the line <code>(setq doc-view-continuous 1)</code> in your init file so that you can
scroll through PDFs seamlessly.</p>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://piotrkazmierczak.com/2010/emacs-as-the-ultimate-latex-editor/">Using auctex with emacs</a></li>
  <li><a href="http://hal.case.edu/~rrc/blog/2013/11/04/latex/">Latex, Auctex and emacs.</a></li>
  <li><a href="https://www.latex-tutorial.com">Latex tutorial.</a></li>
  <li><a href="https://piotrkazmierczak.com/2012/previewing-latex-symbols-without-preview-latex/">Preview Latex symbols without preview-latex.</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/DocView-Navigation.html">DocView navigation.</a></li>
  <li><a href="https://www.sharelatex.com/learn/Inserting_Images">Inserting images in latex.</a></li>
  <li><a href="http://tug.ctan.org/macros/latex/contrib/algorithmicx/algorithmicx.pdf">Algorithmicx package tutorial.</a></li>
  <li><a href="https://tex.stackexchange.com/questions/29429/how-to-use-algorithmicx-package">algorithmicx package with latex.</a></li>
  <li><a href="https://tex.stackexchange.com/questions/229355/algorithm-algorithmic-algorithmicx-algorithm2e-algpseudocode-confused">Comparison between various algorithm environments.</a></li>
  <li><a href="https://tex.stackexchange.com/questions/22798/nice-looking-empty-set">Nice looking empty set.</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Learning Scala for Distributed Algorithms]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/12/notes-on-learning-scala-for-distributed-algorithms/"/>
    <updated>2018-04-12T16:28:16+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/12/notes-on-learning-scala-for-distributed-algorithms</id>
    <content type="html"><![CDATA[<p>I’m currently taking a college course on <a href="http://www.coord.c.titech.ac.jp/c/distribalgo/">distributed algorithms</a>, that uses scala for
teaching. I’m not familiar with distributed algorithms or scala, so in this blog I will
document my learnings and provide some protips on a simple scala setup.</p>

<h1 id="scala-setup">Scala setup</h1>

<p>We advised by the instructor so use scala using the intelliJ IDE, but since I’m
not a big fan of IDEs and prefer using my editor (emacs). I thought I get away
with simply installing scala from the command line (<code>apt-get install scala</code>)
and invoking my programs from the command line using the <code>scalac</code> or <code>scala</code>
programs.</p>

<p>The course requires using a dependency called <a href="URL">scalaneko</a>, which of course
needs to specified before building your program. I tried to compile this with
a simple Makefile that looked like this:</p>
<pre><code>run:
	scala -cp scalaneko_2.12-0.19.0-SNAPSHOT.jar hello_world.scala
</code></pre>

<p>Above Makefile simply tries to specify the classpath using the <code>-cp</code> flag and runs
the scala file. However, this approach fails with errors that probably are hinting
towards the dependency being compiled using a different version of scala.</p>

<p>Therefore, I decided to use SBT for this purpose. SBT is more complex tool for my
simple usage but I think the time saved in the long run would be worth it.</p>

<p>For installation, followed the setup guide <a href="">here</a>. I read the <a href="https://www.scala-sbt.org/1.x/docs/Getting-Started.html">getting started guide</a> to see how to make it work.
Here’s a brief description (make sure sbt is installed first):
First cd into the folder you want to setup your first project. Then execute:</p>
<pre><code>sbt new sbt/scala-seed.g8
</code></pre>
<p>Type a project name (say <code>hello</code>) when prompted for it. You then cd into the <code>hello</code>
directory and execute <code>sbt</code>. Once inside the prompt, type <code>run</code>. This whole process
takes a while to complete since it downloads and compiles many sources.</p>

<h1 id="scala-syntax-protips">Scala syntax protips</h1>

<h2 id="values-and-variables">Values and variables</h2>

<p>Scala supports values and variables. Values cannot be changed and are technically
constants (immutable). Values are declared with <code>val</code> and variables with <code>var</code>.</p>

<p>Since scala supports type inference you don’t need to explicitly declare the type
of your values or variables.</p>

<h2 id="for-loop">For loop</h2>

<p>For loops have the following syntax:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>var count = 0
for (i &lt;- 0 to 10) count = count + i
count
</pre></td>
</tr></table>
</div>

<h2 id="functions">Functions</h2>

<p>Since scala is an object-oriented <em>functional</em> programming language, functions are
basically objects that you create with the keyword <code>def</code>. For example:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>def sum(a: Int, b: Int): Int = a + b
sum(900,100)
</pre></td>
</tr></table>
</div>
<p>The <code>Int</code> after the colon is the return type. You can leave out specifying the
return type in most cases since scala can infer that by itself. Just like any
functional language, functions can be stored and passed around like objects.</p>

<p>If you don’t want your function to return a value (like <code>void</code>) in C, use <code>Unit</code>
as the return value:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>def print(a: Int): Unit = println(a)
print(3)
</pre></td>
</tr></table>
</div>

<p>Like Ruby, the last statement in the body of a function is its return value.</p>

<h3 id="higher-order-functions">Higher-order functions</h3>

<p>Scala allows defining functios that take other functions as its arguments.
This can be done by specifying the argument types and return type of the function
as the data type of the variable that accepts this. For example:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>def apply(f: Int =&gt; String, v: Int) = f(v)
</pre></td>
</tr></table>
</div>
<p>In the above code the <code>apply</code> function will accept a function <code>f</code> as an arguement
which accepts one <code>Int</code> and returns a <code>String</code>.</p>

<h3 id="functions-as-variables">Functions as variables</h3>

<p>Functions can be assigned to a <code>val</code> by specifying the prototype of the function:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>val sum: (Int, Int) =&gt; Int = (a: Int, b: Int) =&gt; a + b
sum(3,6)
</pre></td>
</tr></table>
</div>

<p>Or even by a simple assignment using the <code>new</code> keyword:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre>val verboseSum = new Function2[Int, Int, Int] {
    def apply(a: Int, b: Int): Int = a + b
}

verboseSum(3,6)
</pre></td>
</tr></table>
</div>

<p>In the assingnment we’ve used with <code>new Function2[-T1,-T2,+R]</code> constructor. This is a
<a href="http://www.scala-lang.org/api/2.9.1/scala/Function2.html">special scala trait</a> that can be used for
defining anonymous functions. <code>Function2</code> specifies that the this function will accept
parameters of type <code>T1</code> and <code>T2</code> and will return a type <code>R</code>.</p>

<h3 id="passing-blocks-to-method-calls">Passing blocks to method calls</h3>

<p>Passing blocks to functions (similar to Ruby <code>do..end</code> blocks) is done by specifying curly
braces with the method call. Example:</p>
<pre><code>Receive {
  // do something...
}
</code></pre>

<h2 id="classes">Classes</h2>

<p>Classes are defined using the <code>class</code> keyword. Using a default constructor, the class
can be defined like so:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>class User

val user1 = new User
</pre></td>
</tr></table>
</div>

<p>A constructor can be used by directly specifying the expected argument with the classname:</p>
<pre><code>class Point(x: Int, y: Int) {
    def move(dx: Int, dy: Int) {
        dx = x + 1
        dy = y + 1
    }
}

new point1 = Point(2,3)
point1.x
</code></pre>

<h3 id="singleton-classes">Singleton classes</h3>

<p>Singleton classes in scala are created using the <code>object</code> keyword. This is something
like a module in Ruby. You cannot instantiate objects of such classes. You can simply
access the functions by name instead of creating objects. The <code>main</code> function of a
program must be defined inside a singleton class by the name of the package.</p>

<h3 id="inheritance">Inheritance</h3>

<p>Inheritance is done using the <code>extends</code> keyword and the <code>with</code> keyword. You can use
<code>extends</code> only once when defining a class and <code>with</code> multiple times after that. <code>with</code>
is used for multiple inheritance.</p>

<h4 id="instantiating-base-class-with-certain-values">Instantiating base class with certain values</h4>

<h3 id="case-classes">Case classes</h3>

<p>Case classes are useful for modelling immutable data.</p>

<h4 id="defining-case-classes">Defining case classes</h4>

<p>Defined using the <code>case class</code> keyword. These classes do not require the <code>new</code> keyword
for instantiation because they have an implicit <code>apply</code> method defined internally. You
can use these classes like so:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>case class Book(isbn: String)

val frankenstein = Book(&quot;978-0486282114&quot;)
</pre></td>
</tr></table>
</div>
<p>All attributes of case classes are public and are immutable.</p>

<h2 id="pattern-matching">Pattern matching</h2>

<p>Pattern matching is a powerful tool in Scala for matching an input vs. a set of possible
outcomes. It similar in nature to other FP languages like OCaml.</p>

<p>At its simplest, it can be thought of as a switch-case statement in Java, but with more
power. A simple example would be:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
</pre></td>
  <td class="code"><pre>import scala.util.Random

val x: Int = Random.nextInt(10)

x match {
  case 0 =&gt; &quot;zero&quot;
  case 1 =&gt; &quot;one&quot;
  case 2 =&gt; &quot;two&quot;
  case _ =&gt; &quot;many&quot;
}
</pre></td>
</tr></table>
</div>

<h3 id="list-pattern-matching">List pattern matching</h3>

<h3 id="pattern-matching-anonymous-functions">Pattern matching anonymous functions</h3>

<p>Scala provides a way of pattern matching anonymous functions. These are basically blocks
containing the usual <code>case</code> statements but without the <code>match</code>.</p>

<h2 id="operators">Operators</h2>

<p>This warrants a new section because scala uses a lot of fancy operators for doing all sorts
of ‘magic’ things that can be confusing at first.</p>

<h2 id="eccentric-things">Eccentric things</h2>

<h3 id="in-code-todo-statements">In-code TODO statements</h3>

<p>Scala allows you to throw NotImplementedError using a simpler syntax where you can define
a value <code>???</code> to throw an exception:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>def ???: Nothing = throw new NotImplementedError

def answerToLifeAndEverything() = ???
</pre></td>
</tr></table>
</div>

<h3 id="option-types">Option types</h3>

<h3 id="importing-package-inside-classes">Importing package inside classes</h3>

<p>If you write some case classes (or anything for that matter) inside an <code>object</code>, you need to
declare <code>import ObjectName._</code> inside any class where you want to use members defined inside
that object. This is because the symbols get namespaced.</p>

<h1 id="distributed-algorithms-in-scala">Distributed algorithms in scala</h1>

<p>Professor Xavier’s lab has written a library called <a href="http://www.coord.c.titech.ac.jp/projects/scalaneko/api/neko/">scalaneko</a> that is useful
for prototyping and implementing distributed systems using scala. This assingnment
asks us write an algorithm that does a parallel traversal of a connected graph
of processes using scala.</p>

<h2 id="scalaneko-protips">Scalaneko protips</h2>

<p>The basic unit of concurrency is a processs. Each process can contain many protocols. Protocols
implement the actual algorithms of the system. Protocols and processes exchange information
through events. There are two types of events: signals and messages. Signals allows protocols
within the same process to notify each other. Messages are for protocol instances to communicate
across different processes. Therefore, only messages are transmitted through the network.</p>

<p>Working with scalaneko basically involves the following steps:</p>

<h3 id="initialize-scalaneko-environment">Initialize scalaneko environment</h3>

<p>Create a main object that provides the basic parameters for the execution, such as total
number of processes to create and their initializer. For example:</p>
<div class="language-scala highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre>object HelloNeko
  extends Main(topology.Clique(2))(
    ProcessInitializer { p =&gt; 
      new Hello(p) 
    }
  )
</pre></td>
</tr></table>
</div>
<p>In the above code we initialize scalaneko with 2 processes and then state that each process
should be an instance of the <code>Hello</code> class.</p>

<h3 id="create-and-use-protocols">Create and use protocols</h3>

<p>You need to create protocols for the communication logic. This is done by extending a process class
like <code>Hello</code> in the above code using the <code>ActiveProtocol</code> class provided by scalaneko. Inside
the class you must define a method called <code>run</code> which will be called by ActiveProtocol inside
its own thread for running the protocol.</p>

<p>Messages are sent using the <code>ActiveProtocol.SEND</code> method and received via blocking calls to
<code>ActiveProtocol.RECEIVE</code> method. You should call <code>listenTo</code> to register messages of a
particular type before you can receive them.</p>

<p>You can also override the <code>ActiveProtocol.onReceive</code> method to process messages reactively.
Those that are not caught by <code>onReceive</code> are sent into a receive queue and must be handled using
<code>Receive</code>.</p>

<p>The <code>SEND</code> function in <code>ActiveProtocol</code> has the type:</p>
<pre><code>def SEND(m: Event): Unit 
</code></pre>
<p>The <code>Event</code> in the argument can be an object of type that inherits from <code>Unicastmessage</code> or
<code>Broadcastmessage</code>.</p>

<h3 id="process-initialization">Process initialization</h3>

<p>Process initialization is done using the <code>ProcessInitializer</code> class, whose sole role is
to create protocols of a process and combine them. For example:</p>
<pre><code>ProcessInitializer { p =&gt;
    val app  = new PingPong(p)
    val fifo = new FIFOChannel(p)
    app --&gt; fifo
}
</code></pre>

<p>In the above example, each process is initialized by executing the above code. The
code creates two protocols while registering them into the object p given as argument
(which represents the process being initialized). Then, the two protocols are connected
such that all SEND operations of protocol <code>app</code> are handed to protocol <code>fifo</code>. The send
operations of protocol fifo use the default target which is the network interface of
the process.</p>

<h3 id="messages-and-signals">Messages and signals</h3>

<p>Signals happen inside a process, and can go from one protocol to another, but never crosses
process boundaries. Represented by class <code>neko.Signal</code>. A message is an event that crosses
process boundaries, but is typically interpreted by the same protocol in the target process.
Represented by a subclass of <code>neko.Message</code>.</p>

<p>Messages can be multicast (<code>neko.MulticastMessage</code>), unicast (<code>neko.UnicastMessage</code>) or
a wrapper (<code>neko.Wrapper</code>) that wraps an existing message.</p>

<h3 id="message-sending-methoology">Message sending methoology</h3>

<p>The <code>SEND</code> and <code>DELIVER</code> functions are used for sending messages. Both of them work with
objects of type Event. Thugh they sound the same they have some important differences.</p>
<pre><code>         application
  |                      ^
  V                      |
+----------------------------+
| onSend        DELIVER(...) |
|                            | Reactive protocol
| SEND(...)        onReceive |
+----------------------------+
  |                      ^
  V                      |
          network
</code></pre>
<p>Having a look at Professor Xavier’s Tarry traversal codes, I think that SEND is more
useful for communicating from one process to another and DELIVER for communicating
to the App class that send the initiator message and stuff like that.</p>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="http://uclmr.github.io/stat-nlp-book-scala/05_tutorial/01_intro_to_scala_part1.html">Scala crash course.</a></li>
  <li><a href="http://docs.scala-lang.org/tutorials/tour/higher-order-functions.html.html">Higher-order functions.</a></li>
  <li><a href="http://www.scala-lang.org/api/2.9.1/scala/Function2.html">Scala Function2.</a></li>
  <li><a href="https://www.safaribooksonline.com/library/view/learning-scala/9781449368814/ch09.html">Objects and classes in scala.</a></li>
  <li><a href="https://stackoverflow.com/questions/41031166/scala-extends-vs-with">Extends vs with.</a></li>
  <li><a href="http://scala-lang.org/files/archive/spec/2.12/05-classes-and-objects.html">Classes and objects in scala official docs.</a></li>
  <li><a href="https://alvinalexander.com/scala/how-to-declare-constructor-parameters-extending-scala-class">Declare constructor parameters of extended scala class.</a></li>
  <li><a href="https://docs.scala-lang.org/tour/case-classes.html">Scala case classes</a></li>
  <li><a href="http://danielwestheide.com/blog/2012/12/12/the-neophytes-guide-to-scala-part-4-pattern-matching-anonymous-functions.html">Pattern matching anonymous functions.</a></li>
  <li><a href="https://github.com/ghik/opinionated-scala/wiki/Methods-and-operators">Magic in scala methods and operators.</a></li>
  <li><a href="http://www.coord.c.titech.ac.jp/projects/scalaneko/api/neko/">ScalaNeko API docs.</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Chang_and_Roberts_algorithm">Chang-Roberts algorithm.</a></li>
  <li><a href="http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html">Scala Option type.</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Japanese Environment on Ubuntu and Emacs]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/12/setup-japanese-environment-on-ubuntu-and-emacs/"/>
    <updated>2018-04-12T15:11:57+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/12/setup-japanese-environment-on-ubuntu-and-emacs</id>
    <content type="html"><![CDATA[<p>I’m currently living in Japan and learning Japanese in University. In order to make
learning easier I’m using the <a href="https://ankiweb.net">Anki</a> app. However, Ubuntu and 
emacs don’t come with easy Japanese functionality out of the box and in this post 
I will document the efforts I took to make this happen.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#ubuntu-setup">Ubuntu setup</a></li>
  <li><a href="#emacs-setup">Emacs setup</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="ubuntu-setup">Ubuntu setup</h1>

<p>For ubuntu, the preferred Japanese input method is a Japanese keyboard called mozc.
Use the link in the resources below for this purpose.</p>

<p>Then, setup the following ENV variables in your .bashrc:</p>
<pre><code>export QT_IM_MODULE=fcitx
export GTK_IM_MODULE=fcitx
</code></pre>
<p>You can go the text entry setting and set the keyboard change button to ‘pause’,
which I did.</p>

<h1 id="debian-setup">Debian setup</h1>

<p>You can’t install mozc on Debian GUI so you should first install the <code>ibus-mozc</code> package
and then use the ibus GUI for selecting mozc.</p>

<h1 id="emacs-setup">Emacs setup</h1>

<p>You can then proceed to setup your emacs with the mozc keyboard. For this purpose,
you should first copy-paste the file <code>mozc.el</code> from the <a href="https://github.com/google/mozc/blob/master/src/unix/emacs/mozc.el">mozc sources</a>
into your .emacs.d/ folder and then paste the following into your <code>init.el</code> (after
loading the mozc.el file).</p>
<div class="language-elisp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>(require 'mozc)
(setq default-input-method &quot;japanese-mozc&quot;)
(setq mozc-candidate-style 'overlay)
</pre></td>
</tr></table>
</div>
<p>Once this is done, install the <code>emacs-mozc-bin</code> package from the ubuntu sources
so that emacs can communicate with the mozc server.</p>

<p>You should now be able to change between Japanese and English keyboards using the
<code>C-\</code> command inside emacs. This does not change your system input.</p>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://moritzmolch.com/2287">Ubuntu setup instructions for mozc.</a></li>
  <li><a href="https://www.emacswiki.org/emacs/WritingJapanese">Writing Japanese in emacs</a></li>
  <li><a href="https://wiki.archlinux.org/index.php/mozc#Mozc_for_Emacs">Archlinux mozc emacs.</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distributed LU Decomposition Using Scalapack in C++]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/10/distributed-lu-decomposition-using-scalapack-in-c/"/>
    <updated>2018-04-10T15:53:31+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/10/distributed-lu-decomposition-using-scalapack-in-c</id>
    <content type="html"><![CDATA[<p>ScaLAPACK is the distributed version of LAPACK. The interface of most functions is 
almost similar. However, not much documentation and example code is available for 
scalapack in C++, which is why I’m writing this blog post to document my learnings.
Hopefully this will be useful for others too.</p>

<p>This post is part of a larger post where I’ve implemented and benchmarked synchronous 
and asynchronous block LU deocomposition. That post can be found <a href="URL">here</a>. <a href="https://software.intel.com/en-us/mkl-developer-reference-c-p-getrf">This</a> intel resource is also helpful for this purpose.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#scalapack-protips">Scalapack protips</a></li>
  <li><a href="#function-usage-protips">Function usage protips</a></li>
  <li><a href="#source-code">Source code</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="scalapack-protips">Scalapack protips</h1>

<p>There are certain terminologies that are pretty widely used in scalapack. They are as follows:</p>
<ul>
  <li>Scalapack docs assume that a matrix of <code>K</code> rows or columns is distributed over a process grid of dimensions p x q.</li>
  <li><code>LOCr</code> :: <code>LOCr(K)</code> denotes the number of elements of K that a process would receive if K were
distributed over the p processes of its process column.</li>
  <li><code>LOCc</code> :: <code>LOCc(K)</code> denotes the number of elements of K that a process would receive if K were 
distributed over the q processes of its process row.</li>
  <li>The values of <code>LOCc</code> and <code>LOCr</code> can be determined using a call to the <code>numroc</code> function.</li>
  <li><strong>IMPORTANT</strong> :: None of these functions have C interfaces the way there are for LAPACK via LAPACKE. 
Therefore, you must take care to pass all variables by address, not by value and store all your data 
in FORTRAN-style, i.e. column-major format not row-major.</li>
</ul>

<p>The <code>numroc</code> function is useful in almost every scalapack function. It computes the number of rows 
and columns of a distributed matrix ownded by the process (the return value). Here’s an explanation 
alongwith the prototype:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> numroc_(
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#777">// (global) the number of rows/cols in dist matrix</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#777">// (global) block size. size of blocks the distributed matrix is split into.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *iproc, <span style="color:#777">// (local input) coord of the process whose local array row is to be determined.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *srcproc, <span style="color:#777">// (global input) coord of the process that has the first row/col of distributed matrix.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nprocs <span style="color:#777">// (global input) total no. of processes over which the matrix is distributed.</span>
);
</pre></td>
</tr></table>
</div>

<h2 id="errors">Errors</h2>

<p>Scalapack reports errors using the XERBLA error handler. Here’s some resources for this:</p>
<ul>
  <li><a href="http://www.netlib.org/scalapack/slug/node151.html#SECTION04751000000000000000">Invalid arguments and XERBLA.</a></li>
  <li><a href="http://www.netlib.org/scalapack/slug/node149.html#seccommonerrors">Common errors in calling ScaLAPACK routines.</a></li>
</ul>

<h1 id="function-usage-protips">Function usage protips</h1>

<p>As with other PBLAS or ScaLAPACK functions, this function expects the matrix to be already distributed over the BLACS process grid (and of course the BLACS process grid should be initialized).</p>

<p>The function in scalapack for LU decomposition is <code>pdgetrf_</code>. The C++ prototype of this function is
as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> pdgetrf_(
    <span style="color:#0a8;font-weight:bold">int</span> *m,   <span style="color:#777">// (global) The number of rows in the distributed matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *n,   <span style="color:#777">// (global) The number of columns in the distributed matrix sub(A)</span>
    <span style="color:#777">// (local) Pointer into the local memory to an array of local size.</span>
    <span style="color:#777">// Contains the local pieces of the distributed matrix sub(A) to be factored.</span>
    <span style="color:#0a8;font-weight:bold">double</span> *a,
    <span style="color:#0a8;font-weight:bold">int</span> *ia,  <span style="color:#777">// (global) row index in the global matrix A indicating first row matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *ja,  <span style="color:#777">// (global) col index in the global matrix A indicating first col matrix sub(A)</span>
    <span style="color:#0a8;font-weight:bold">int</span> *desca, <span style="color:#777">// array descriptor of A</span>
    <span style="color:#0a8;font-weight:bold">int</span> *ipiv, <span style="color:#777">// contains the pivoting information. array of size</span>
    <span style="color:#0a8;font-weight:bold">int</span> *info <span style="color:#777">// information about execution.</span>
);
</pre></td>
</tr></table>
</div>

<p>In the above prototype, <code>m</code> signifies the number of rows of the submatrix, meaning
the matrix that is present in the current process. Similarly for <code>n</code> in case of cols.</p>

<p>A function <code>descinit_</code> can be used for initializing the descriptor array. Its prototype is as
follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> descinit_(<span style="color:#0a8;font-weight:bold">int</span> *desc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m,  <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *mb, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *irsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *icsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ictxt, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *lld, <span style="color:#0a8;font-weight:bold">int</span> *info);
</pre></td>
</tr></table>
</div>
<p>In the <code>descinit_</code>, the <code>MB</code> and <code>NB</code> parameters signify the size of the block into which the
matrix is divided. Not the size of the block that each process will receive. See the <code>sync_lu</code>
code for an <a href="https://github.com/v0dro/scratch/tree/master/c_shizzle/parallel/sync_lu">example</a> of block cyclic LU decomposition.</p>

<p>The <code>ipiv</code> array is not a synchronized data struture - it will be different for each process.
According to the docs, <code>ipiv(i)</code> is the global row local row i was swapped with. This array 
is tied to the distributed matrix A.</p>

<h2 id="storage-in-the-arrays">Storage in the arrays</h2>

<p>Each local array of a process should store a part of the global matrix. The global matrix is stored
in a block cyclic manner and scalapack reads each local array expecting it in a particular format.
It is important to be aware of this.</p>

<p>See <a href="http://netlib.org/scalapack/slug/node28.html">this</a> explanation on the scalapack site to get a complete understanding.</p>

<h1 id="source-code">Source code</h1>

<p>Here’s a full source implementing a simple LU decomposition using ScaLAPACK:</p>

<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
<a href="#n63" name="n63">63</a>
<a href="#n64" name="n64">64</a>
<a href="#n65" name="n65">65</a>
<a href="#n66" name="n66">66</a>
<a href="#n67" name="n67">67</a>
<a href="#n68" name="n68">68</a>
<a href="#n69" name="n69">69</a>
<strong><a href="#n70" name="n70">70</a></strong>
<a href="#n71" name="n71">71</a>
<a href="#n72" name="n72">72</a>
<a href="#n73" name="n73">73</a>
<a href="#n74" name="n74">74</a>
<a href="#n75" name="n75">75</a>
<a href="#n76" name="n76">76</a>
<a href="#n77" name="n77">77</a>
<a href="#n78" name="n78">78</a>
<a href="#n79" name="n79">79</a>
<strong><a href="#n80" name="n80">80</a></strong>
<a href="#n81" name="n81">81</a>
<a href="#n82" name="n82">82</a>
<a href="#n83" name="n83">83</a>
<a href="#n84" name="n84">84</a>
<a href="#n85" name="n85">85</a>
<a href="#n86" name="n86">86</a>
<a href="#n87" name="n87">87</a>
<a href="#n88" name="n88">88</a>
<a href="#n89" name="n89">89</a>
<strong><a href="#n90" name="n90">90</a></strong>
<a href="#n91" name="n91">91</a>
<a href="#n92" name="n92">92</a>
<a href="#n93" name="n93">93</a>
<a href="#n94" name="n94">94</a>
<a href="#n95" name="n95">95</a>
<a href="#n96" name="n96">96</a>
<a href="#n97" name="n97">97</a>
<a href="#n98" name="n98">98</a>
<a href="#n99" name="n99">99</a>
<strong><a href="#n100" name="n100">100</a></strong>
<a href="#n101" name="n101">101</a>
<a href="#n102" name="n102">102</a>
<a href="#n103" name="n103">103</a>
<a href="#n104" name="n104">104</a>
<a href="#n105" name="n105">105</a>
<a href="#n106" name="n106">106</a>
</pre></td>
  <td class="code"><pre><span style="color:#777">// Implement simple distributed LU decomposition using scalapack.</span>
<span style="color:#777">// This code uses a simple block distribution of data. Not block cyclic.</span>
<span style="color:#777">// author: Sameer Deshmukh (@v0dro)</span>

<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&quot;mpi.h&quot;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cstdlib&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cmath&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;iostream&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;fstream&gt;</span>
<span style="color:#088;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#088;font-weight:bold">extern</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">C</span><span style="color:#710">&quot;</span></span> {
  <span style="color:#777">/* Cblacs declarations */</span>
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pinfo(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_get(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridinit(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pcoord(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridexit(<span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_barrier(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*);
 
  <span style="color:#0a8;font-weight:bold">int</span> numroc_(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);

  <span style="color:#088;font-weight:bold">void</span> descinit_(<span style="color:#0a8;font-weight:bold">int</span> *desc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m,  <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *mb, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *irsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *icsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ictxt, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *lld, <span style="color:#0a8;font-weight:bold">int</span> *info);
  <span style="color:#088;font-weight:bold">void</span> pdgetrf_(
                <span style="color:#0a8;font-weight:bold">int</span> *m, <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#0a8;font-weight:bold">double</span> *a, <span style="color:#0a8;font-weight:bold">int</span> *ia, <span style="color:#0a8;font-weight:bold">int</span> *ja, <span style="color:#0a8;font-weight:bold">int</span> *desca,
                <span style="color:#0a8;font-weight:bold">int</span> *ipiv,<span style="color:#0a8;font-weight:bold">int</span> *info);
}

<span style="color:#088;font-weight:bold">void</span> print_arr(<span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#0a8;font-weight:bold">int</span> size, <span style="color:#0a8;font-weight:bold">string</span> desc, ostream &amp;o)
{
  o &lt;&lt; desc &lt;&lt; endl;
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; size; ++i) {
    o &lt;&lt; A[i] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
  }
  o &lt;&lt; endl;
}

<span style="color:#088;font-weight:bold">void</span> print_files(<span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#0a8;font-weight:bold">int</span> nrows, <span style="color:#0a8;font-weight:bold">int</span> ncols, <span style="color:#0a8;font-weight:bold">int</span> myrow, <span style="color:#0a8;font-weight:bold">int</span> mycol)
{
  <span style="color:#0a8;font-weight:bold">string</span> n = to_string(myrow*<span style="color:#00D">2</span> + mycol); 
  std::ofstream file;

  file.open(n + <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">.txt</span><span style="color:#710">&quot;</span></span>);
  print_arr(A, nrows*ncols, n, file);
  file.close();
}

<span style="color:#0a8;font-weight:bold">int</span> main(<span style="color:#0a8;font-weight:bold">int</span> argc, <span style="color:#0a8;font-weight:bold">char</span> ** argv)
{
  <span style="color:#777">// MPI init</span>
  MPI_Init(&amp;argc, &amp;argv);
  <span style="color:#777">// end MPI Init</span>
  
  <span style="color:#777">// BLACS init</span>
  <span style="color:#0a8;font-weight:bold">int</span> BLACS_CONTEXT, proc_nrows, proc_ncols, myrow, mycol;
  <span style="color:#0a8;font-weight:bold">int</span> proc_id, num_procs;
  proc_nrows = <span style="color:#00D">2</span>; proc_ncols = <span style="color:#00D">2</span>;
  Cblacs_pinfo(&amp;proc_id, &amp;num_procs);
  Cblacs_get( -<span style="color:#00D">1</span>, <span style="color:#00D">0</span>, &amp;BLACS_CONTEXT );
  Cblacs_gridinit( &amp;BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Row</span><span style="color:#710">&quot;</span></span>, proc_nrows, proc_ncols );
  Cblacs_pcoord(BLACS_CONTEXT, proc_id, &amp;myrow, &amp;mycol);
  <span style="color:#777">// end BLACS init</span>

  <span style="color:#777">// matrix properties</span>
  <span style="color:#777">// mat size, blk size, portion of block per process</span>
  <span style="color:#0a8;font-weight:bold">int</span> N = <span style="color:#00D">8</span>, nb = <span style="color:#00D">4</span>, process_block_size = <span style="color:#00D">2</span>;
  <span style="color:#0a8;font-weight:bold">int</span> num_blocks_per_process = N/process_block_size;
  <span style="color:#0a8;font-weight:bold">int</span> block_size_per_process_r = sqrt(num_blocks_per_process);
  <span style="color:#0a8;font-weight:bold">int</span> block_size_per_process_c = sqrt(num_blocks_per_process);
  <span style="color:#0a8;font-weight:bold">double</span>* a = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);
  <span style="color:#777">// generate matrix data</span>
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#0a8;font-weight:bold">int</span> index = i + j*nb;
      <span style="color:#0a8;font-weight:bold">int</span> row_i = myrow*nb + i;
      <span style="color:#0a8;font-weight:bold">int</span> col_j = mycol*nb + j;
      a[index] = row_i + col_j*N;
    }
    cout &lt;&lt; endl;
  }
  <span style="color:#777">// end matrix properties</span>

  <span style="color:#777">// create array descriptor</span>
  <span style="color:#0a8;font-weight:bold">int</span> desca[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> rsrc = <span style="color:#00D">0</span>, csrc = <span style="color:#00D">0</span>, info;
  descinit_(desca, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  <span style="color:#777">// end create array descriptor</span>

  Cblacs_barrier(BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">All</span><span style="color:#710">&quot;</span></span>);

  <span style="color:#777">// LU decomposition</span>
  <span style="color:#0a8;font-weight:bold">int</span> ia = <span style="color:#00D">1</span>, ja = <span style="color:#00D">1</span>;
  <span style="color:#0a8;font-weight:bold">int</span> *ipiv = (<span style="color:#0a8;font-weight:bold">int</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">int</span>)*N);
  pdgetrf_(&amp;N, &amp;N, a, &amp;ia, &amp;ja, desca, ipiv, &amp;info);
  <span style="color:#777">// end LU decomposition</span>

  print_files(a, nb, nb, myrow, mycol);
  <span style="color:#080;font-weight:bold">if</span> (myrow == <span style="color:#00D">0</span> &amp;&amp; mycol == <span style="color:#00D">0</span>) {
    <span style="color:#080;font-weight:bold">for</span>(<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; N; ++i) {
      cout &lt;&lt; ipiv[i] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
    }
  }
  MPI_Finalize();
}
</pre></td>
</tr></table>
</div>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="https://software.intel.com/en-us/forums/intel-math-kernel-library/topic/288028">Intel Q and A on numroc</a></li>
  <li><a href="http://www.netlib.org/scalapack/explore-html/d4/d48/numroc_8f_source.html">Numroc fortran docs</a></li>
  <li><a href="https://software.intel.com/en-us/articles/using-cluster-mkl-pblasscalapack-fortran-routine-in-your-c-program">Using PBLAS/ScaLAPACK in your C code by intel (MKL specific)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binding C Structs to Ruby Objects Using Rubex.]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/07/binding-c-structs-to-ruby-objects-using-rubex/"/>
    <updated>2018-04-07T13:28:16+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/07/binding-c-structs-to-ruby-objects-using-rubex</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distributed Matrix Multiplication Using PBLAS and BLACS.]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/05/distributed-matrix-multiplication-using-pblas-and-blacs/"/>
    <updated>2018-04-05T13:50:59+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/05/distributed-matrix-multiplication-using-pblas-and-blacs</id>
    <content type="html"><![CDATA[<p>PBLAS (or Parallel BLAS) is a parallel version of BLAS that use BLACS internally for
parallel computing. It expects the matrix to be already distributed among processors
before it starts computing. You first create the data in each process and then provide 
PBLAS with information that will help it determine how exactly the matrix is distributed.
Each process can access only its local data.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#array-descriptor">Array descriptor</a></li>
  <li><a href="#multiplication-function-description">Multiplication function description</a></li>
  <li><a href="#full-code">Full code</a></li>
  <li><a href="#resources">Resources</a></li>
</ul>

<!-- markdown-toc end -->

<h1 id="array-descriptor">Array descriptor</h1>

<p>You also need to define an ‘array descriptor’ for the matrix that you are working on. 
The array descriptor is an integer array of length 9 that contains the following data:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> array_desc[<span style="color:#00D">9</span>] = {
    dtype,   <span style="color:#777">// descriptor type (=1 for dense matrix)</span>
    context, <span style="color:#777">// BLACS context handle for process grid</span>
    m,       <span style="color:#777">// num of rows in the global array</span>
    n,       <span style="color:#777">// num of cols in the global array</span>
    mb,      <span style="color:#777">// num of rows in a block</span>
    nb,      <span style="color:#777">// num of cols in a block</span>
    rsrc,    <span style="color:#777">// process row over which first row of the global array is distributed</span>
    csrc,    <span style="color:#777">// process col over which first col of the global array is distributed</span>
    lld      <span style="color:#777">// leading dimension of the local array</span>
}
</pre></td>
</tr></table>
</div>

<p>Although you can do it yourself, using the <code>descinit</code> function for initializing the array descriptor is a good way to keep the code clean. This function looks as follows:</p>
<pre><code>void descinit_ (
    int *desc, 
    const int *m, 
    const int *n, 
    const int *mb, 
    const int *nb, 
    const int *irsrc, 
    const int *icsrc, 
    const int *ictxt, 
    const int *lld, 
    int *info
);
</code></pre>

<h1 id="multiplication-function-description">Multiplication function description</h1>

<p>According to PBLAS conventions, the global matrix can be denoted by <code>A</code> and the 
block of matrix possessed by the particlar process as <code>sub(A)</code>. The number of
rows and columns of a global dense matrix that a particular process in a grid
receives after data distributing is denoted by <code>LOCr()</code> and <code>LOCc()</code>, respectively.
To compute these numbers, you can use the ScaLAPACK tool routine <code>numroc</code>.</p>

<p>To explain with example, see the prototype of the <code>pdgemm</code> routine 
(<a href="https://software.intel.com/en-us/mkl-developer-reference-c-p-gemm#5258C6E6-D85C-4E79-A64C-A45F300B0C3C">intel</a> resource):</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> pdgemm_(
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span> *transa ,  <span style="color:#777">// (g) form of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span> *transb ,  <span style="color:#777">// (g) form of sub(B)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m ,        <span style="color:#777">// (g) number of rows of sub(A) and sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n ,        <span style="color:#777">// (g) number of cols of sub(B) and sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *k ,        <span style="color:#777">// (g) Number of cols of sub(A) and rows of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *alpha , <span style="color:#777">// (g) scalar alpha</span>
    <span style="color:#777">// array that contains local pieces of distributed matrix sub(A). size lld_a by kla.</span>
    <span style="color:#777">//   kla is LOCq(ja+m-1) for C code (transposed).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *a ,     <span style="color:#777">// (l)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ia ,       <span style="color:#777">// (g) row index in the distributed matrix A indicating first row of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ja ,       <span style="color:#777">// (g) col index in the distributed matrix A indicating first col of sub(A)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *desca ,    <span style="color:#777">// (g &amp; l)array of dim 9. Array descriptor of A.</span>
    <span style="color:#777">// array that contains local pieces of dist matrix sub(B). size lld_b by klb.</span>
    <span style="color:#777">//   klb is LOCq(jb+k-1) for C code (transposed).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *b ,     <span style="color:#777">// (l)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ib ,       <span style="color:#777">// (g) row index of dist matrix B indicating first row of sub(B)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *jb ,       <span style="color:#777">// (g) col index of dist matrix B indicating first col of sub(B)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *descb ,    <span style="color:#777">// (g &amp; l) array desc of matrix B (dim 9).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">double</span> *beta ,  <span style="color:#777">// (g) scalar beta</span>
    <span style="color:#0a8;font-weight:bold">double</span> *c ,           <span style="color:#777">// (l) Array of size (lld_a, LOCq(jc+n-1)). contains sub(C) pieces.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ic ,       <span style="color:#777">// (g) row index of dist matrix C indicating first row of sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *jc ,       <span style="color:#777">// (g) col index of dist matrix C indicating first col of sub(C)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *descc      <span style="color:#777">// (g &amp; l) array of dim 9. Array desc of C.</span>
)
</pre></td>
</tr></table>
</div>
<p>The above function looks very similar to non-parallel <code>dgemm</code> from BLAS, with
additions for making it easy to find elements in a parallel scenario. Keep in
mind that there are some arguments that refer to the global array properties
and some that refer to the local array properties.</p>

<p>A function called <code>numroc</code> from ScaLAPACK is useful for determining how many
rows or cols of the global matrix are present in a particular process. The 
prototype looks as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> numroc_(
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n,       <span style="color:#777">// (g) number of rows/cols in dist matrix (global matrix).</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb,      <span style="color:#777">// (g input) block size. (must be square blocks)</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *iproc,   <span style="color:#777">// (l input) co-ordinate of process whole local array row/col is to be determined.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *srcproc, <span style="color:#777">// (g input) co-ordinate of the process that contains the frist row or col of the dist matrix.</span>
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nprocs   <span style="color:#777">// (g input) total number of processes.</span>
)
</pre></td>
</tr></table>
</div>

<p>When compiling these functions, don’t forget to link with the <code>-lgfortran</code> flag.</p>

<h1 id="full-code">Full code</h1>

<p>A simple implementation of matrix multiplication using BLACS and PBLAS:</p>

<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
<a href="#n26" name="n26">26</a>
<a href="#n27" name="n27">27</a>
<a href="#n28" name="n28">28</a>
<a href="#n29" name="n29">29</a>
<strong><a href="#n30" name="n30">30</a></strong>
<a href="#n31" name="n31">31</a>
<a href="#n32" name="n32">32</a>
<a href="#n33" name="n33">33</a>
<a href="#n34" name="n34">34</a>
<a href="#n35" name="n35">35</a>
<a href="#n36" name="n36">36</a>
<a href="#n37" name="n37">37</a>
<a href="#n38" name="n38">38</a>
<a href="#n39" name="n39">39</a>
<strong><a href="#n40" name="n40">40</a></strong>
<a href="#n41" name="n41">41</a>
<a href="#n42" name="n42">42</a>
<a href="#n43" name="n43">43</a>
<a href="#n44" name="n44">44</a>
<a href="#n45" name="n45">45</a>
<a href="#n46" name="n46">46</a>
<a href="#n47" name="n47">47</a>
<a href="#n48" name="n48">48</a>
<a href="#n49" name="n49">49</a>
<strong><a href="#n50" name="n50">50</a></strong>
<a href="#n51" name="n51">51</a>
<a href="#n52" name="n52">52</a>
<a href="#n53" name="n53">53</a>
<a href="#n54" name="n54">54</a>
<a href="#n55" name="n55">55</a>
<a href="#n56" name="n56">56</a>
<a href="#n57" name="n57">57</a>
<a href="#n58" name="n58">58</a>
<a href="#n59" name="n59">59</a>
<strong><a href="#n60" name="n60">60</a></strong>
<a href="#n61" name="n61">61</a>
<a href="#n62" name="n62">62</a>
<a href="#n63" name="n63">63</a>
<a href="#n64" name="n64">64</a>
<a href="#n65" name="n65">65</a>
<a href="#n66" name="n66">66</a>
<a href="#n67" name="n67">67</a>
<a href="#n68" name="n68">68</a>
<a href="#n69" name="n69">69</a>
<strong><a href="#n70" name="n70">70</a></strong>
<a href="#n71" name="n71">71</a>
<a href="#n72" name="n72">72</a>
<a href="#n73" name="n73">73</a>
<a href="#n74" name="n74">74</a>
<a href="#n75" name="n75">75</a>
<a href="#n76" name="n76">76</a>
<a href="#n77" name="n77">77</a>
<a href="#n78" name="n78">78</a>
<a href="#n79" name="n79">79</a>
<strong><a href="#n80" name="n80">80</a></strong>
<a href="#n81" name="n81">81</a>
<a href="#n82" name="n82">82</a>
<a href="#n83" name="n83">83</a>
<a href="#n84" name="n84">84</a>
<a href="#n85" name="n85">85</a>
<a href="#n86" name="n86">86</a>
<a href="#n87" name="n87">87</a>
<a href="#n88" name="n88">88</a>
<a href="#n89" name="n89">89</a>
<strong><a href="#n90" name="n90">90</a></strong>
<a href="#n91" name="n91">91</a>
<a href="#n92" name="n92">92</a>
<a href="#n93" name="n93">93</a>
<a href="#n94" name="n94">94</a>
<a href="#n95" name="n95">95</a>
<a href="#n96" name="n96">96</a>
<a href="#n97" name="n97">97</a>
<a href="#n98" name="n98">98</a>
<a href="#n99" name="n99">99</a>
<strong><a href="#n100" name="n100">100</a></strong>
<a href="#n101" name="n101">101</a>
<a href="#n102" name="n102">102</a>
<a href="#n103" name="n103">103</a>
<a href="#n104" name="n104">104</a>
<a href="#n105" name="n105">105</a>
<a href="#n106" name="n106">106</a>
<a href="#n107" name="n107">107</a>
<a href="#n108" name="n108">108</a>
<a href="#n109" name="n109">109</a>
<strong><a href="#n110" name="n110">110</a></strong>
<a href="#n111" name="n111">111</a>
<a href="#n112" name="n112">112</a>
<a href="#n113" name="n113">113</a>
<a href="#n114" name="n114">114</a>
<a href="#n115" name="n115">115</a>
<a href="#n116" name="n116">116</a>
<a href="#n117" name="n117">117</a>
<a href="#n118" name="n118">118</a>
<a href="#n119" name="n119">119</a>
<strong><a href="#n120" name="n120">120</a></strong>
<a href="#n121" name="n121">121</a>
<a href="#n122" name="n122">122</a>
<a href="#n123" name="n123">123</a>
<a href="#n124" name="n124">124</a>
<a href="#n125" name="n125">125</a>
<a href="#n126" name="n126">126</a>
<a href="#n127" name="n127">127</a>
<a href="#n128" name="n128">128</a>
<a href="#n129" name="n129">129</a>
<strong><a href="#n130" name="n130">130</a></strong>
<a href="#n131" name="n131">131</a>
<a href="#n132" name="n132">132</a>
<a href="#n133" name="n133">133</a>
<a href="#n134" name="n134">134</a>
<a href="#n135" name="n135">135</a>
</pre></td>
  <td class="code"><pre><span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&quot;mpi.h&quot;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;iostream&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cstdlib&gt;</span>
<span style="color:#579">#include</span> <span style="color:#B44;font-weight:bold">&lt;cmath&gt;</span>
<span style="color:#088;font-weight:bold">using</span> <span style="color:#080;font-weight:bold">namespace</span> std;

<span style="color:#088;font-weight:bold">extern</span> <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">C</span><span style="color:#710">&quot;</span></span> {
  <span style="color:#777">/* Cblacs declarations */</span>
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pinfo(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_get(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridinit(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_pcoord(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_gridexit(<span style="color:#0a8;font-weight:bold">int</span>);
  <span style="color:#088;font-weight:bold">void</span> Cblacs_barrier(<span style="color:#0a8;font-weight:bold">int</span>, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">char</span>*);
 
  <span style="color:#0a8;font-weight:bold">int</span> numroc_(<span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*, <span style="color:#0a8;font-weight:bold">int</span>*);

  <span style="color:#088;font-weight:bold">void</span> descinit_(<span style="color:#0a8;font-weight:bold">int</span> *desc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *m,  <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *n, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *mb, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *nb, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *irsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *icsrc, <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *ictxt, 
    <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a8;font-weight:bold">int</span> *lld, <span style="color:#0a8;font-weight:bold">int</span> *info);

  <span style="color:#088;font-weight:bold">void</span> pdgemm_( <span style="color:#0a8;font-weight:bold">char</span>* TRANSA, <span style="color:#0a8;font-weight:bold">char</span>* TRANSB,
                <span style="color:#0a8;font-weight:bold">int</span> * M, <span style="color:#0a8;font-weight:bold">int</span> * N, <span style="color:#0a8;font-weight:bold">int</span> * K,
                <span style="color:#0a8;font-weight:bold">double</span> * ALPHA,
                <span style="color:#0a8;font-weight:bold">double</span> * A, <span style="color:#0a8;font-weight:bold">int</span> * IA, <span style="color:#0a8;font-weight:bold">int</span> * JA, <span style="color:#0a8;font-weight:bold">int</span> * DESCA,
                <span style="color:#0a8;font-weight:bold">double</span> * B, <span style="color:#0a8;font-weight:bold">int</span> * IB, <span style="color:#0a8;font-weight:bold">int</span> * JB, <span style="color:#0a8;font-weight:bold">int</span> * DESCB,
                <span style="color:#0a8;font-weight:bold">double</span> * BETA,
                <span style="color:#0a8;font-weight:bold">double</span> * C, <span style="color:#0a8;font-weight:bold">int</span> * IC, <span style="color:#0a8;font-weight:bold">int</span> * JC, <span style="color:#0a8;font-weight:bold">int</span> * DESCC );
}


<span style="color:#0a8;font-weight:bold">int</span> main(<span style="color:#0a8;font-weight:bold">int</span> argc, <span style="color:#0a8;font-weight:bold">char</span> ** argv)
{
  <span style="color:#777">// MPI init</span>
  MPI_Init(&amp;argc, &amp;argv);
  <span style="color:#0a8;font-weight:bold">int</span> mpi_rank, mpi_size;
  MPI_Comm_rank(MPI_COMM_WORLD, &amp;mpi_rank);
  MPI_Comm_size(MPI_COMM_WORLD, &amp;mpi_size);
  <span style="color:#777">// end MPI init</span>

  <span style="color:#777">// BLACS init</span>
  <span style="color:#0a8;font-weight:bold">int</span> BLACS_CONTEXT, proc_nrows, proc_ncols, myrow, mycol;
  <span style="color:#0a8;font-weight:bold">int</span> proc_id, num_procs;
  proc_nrows = <span style="color:#00D">2</span>; proc_ncols = <span style="color:#00D">2</span>;
n  <span style="color:#777">//int proc_dims[2] = {proc_nrows, proc_ncols};</span>
  Cblacs_pinfo(&amp;proc_id, &amp;num_procs);
  Cblacs_get( -<span style="color:#00D">1</span>, <span style="color:#00D">0</span>, &amp;BLACS_CONTEXT );
  Cblacs_gridinit( &amp;BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Row</span><span style="color:#710">&quot;</span></span>, proc_nrows, proc_ncols );
  Cblacs_pcoord(BLACS_CONTEXT, mpi_rank, &amp;myrow, &amp;mycol);
  cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">myrow </span><span style="color:#710">&quot;</span></span> &lt;&lt; myrow &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> mycol </span><span style="color:#710">&quot;</span></span> &lt;&lt; mycol &lt;&lt; endl;
  cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">procid </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> num_procs </span><span style="color:#710">&quot;</span></span> &lt;&lt; num_procs &lt;&lt; endl;
  <span style="color:#777">// end BLACS init</span>

  <span style="color:#777">// matrix properties</span>
  <span style="color:#0a8;font-weight:bold">int</span> N = <span style="color:#00D">8</span>, nb = <span style="color:#00D">4</span>; <span style="color:#777">// mat size, blk size.</span>
  <span style="color:#0a8;font-weight:bold">double</span>* a = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);
  <span style="color:#0a8;font-weight:bold">double</span>* b = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);
  <span style="color:#0a8;font-weight:bold">double</span>* c = (<span style="color:#0a8;font-weight:bold">double</span>*)malloc(<span style="color:#080;font-weight:bold">sizeof</span>(<span style="color:#0a8;font-weight:bold">double</span>)*nb*nb);

  <span style="color:#777">// generate matrix data</span>
  <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb*nb; ++i) {
    a[i] = <span style="color:#00D">1</span>;
    b[i] = <span style="color:#00D">2</span>;
    c[i] = <span style="color:#00D">0</span>;
  }
  <span style="color:#777">// end matrix properties</span>

  <span style="color:#777">// create array descriptor</span>
  <span style="color:#0a8;font-weight:bold">int</span> desca[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> descb[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> descc[<span style="color:#00D">9</span>];
  <span style="color:#0a8;font-weight:bold">int</span> rsrc = <span style="color:#00D">0</span>, csrc = <span style="color:#00D">0</span>, info;
  descinit_(desca, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  descinit_(descb, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  descinit_(descc, &amp;N, &amp;N, &amp;nb, &amp;nb, &amp;rsrc, &amp;csrc, &amp;BLACS_CONTEXT, &amp;nb, &amp;info);
  cout &lt;&lt; proc_id &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> info: </span><span style="color:#710">&quot;</span></span> &lt;&lt; info &lt;&lt; endl;
  <span style="color:#777">// end create array descriptor</span>
  
  Cblacs_barrier(BLACS_CONTEXT, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">All</span><span style="color:#710">&quot;</span></span>);
  <span style="color:#0a8;font-weight:bold">int</span> ia = <span style="color:#00D">1</span>, ja = <span style="color:#00D">1</span>, ib = <span style="color:#00D">1</span>, jb = <span style="color:#00D">1</span>, ic = <span style="color:#00D">1</span>, jc = <span style="color:#00D">1</span>;
  <span style="color:#0a8;font-weight:bold">double</span> alpha = <span style="color:#00D">1</span>, beta = <span style="color:#00D">1</span>;
  pdgemm_(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">T</span><span style="color:#710">&quot;</span></span>, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">T</span><span style="color:#710">&quot;</span></span>, &amp;N, &amp;N, &amp;N, &amp;alpha, a, &amp;ia, &amp;ja, desca, b, &amp;ib, &amp;jb, descb,
          &amp;beta, c, &amp;ic, &amp;jc, descc);

  <span style="color:#777">// print results on a per-process basis</span>
  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">0</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">1</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">2</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  <span style="color:#080;font-weight:bold">if</span> (proc_id == <span style="color:#00D">3</span>) {
    cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">proc : </span><span style="color:#710">&quot;</span></span> &lt;&lt; proc_id &lt;&lt; endl;
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; nb; ++i) {
      <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a8;font-weight:bold">int</span> j = <span style="color:#00D">0</span>; j &lt; nb; ++j) {
        cout &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">(</span><span style="color:#710">&quot;</span></span> &lt;&lt; nb*myrow + i &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">,</span><span style="color:#710">&quot;</span></span> &lt;&lt;
          nb*mycol + j &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">) </span><span style="color:#710">&quot;</span></span> &lt;&lt; c[i*nb + j] &lt;&lt; <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20"> </span><span style="color:#710">&quot;</span></span>;
      }
      cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
  }

  MPI_Finalize();
}
</pre></td>
</tr></table>
</div>

<h1 id="resources">Resources</h1>

<ul>
  <li><a href="http://www.netlib.org/utk/papers/pblas/node20.html">Use of PBLAS from netlib.</a></li>
  <li><a href="https://www.ibm.com/support/knowledgecenter/en/SSNR5K_5.1.0/com.ibm.cluster.pessl.v5r1.pssl100.doc/am6gr_lnumroc.htm">numroc IBM explanation.</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading Block Cyclic Matrices Using MPI-IO C Interface.]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/05/reading-block-cyclic-matrices-using-mpi-io-c-interface/"/>
    <updated>2018-04-05T13:44:15+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/05/reading-block-cyclic-matrices-using-mpi-io-c-interface</id>
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/10341860/mpi-io-reading-and-writing-block-cyclic-matrix#_=_">This</a> answer on stack overflow is pretty detailed for this purpose. Since the answer is in FORTRAN, I’ll explain with some C code and how I went about this.</p>

<p>A very cumbersome way of reading a row-major matrix from a file into an MPI process is to read individual chunks one by one in a block cyclic manner in a loop. A better way is to use the <a href="https://www.mpich.org/static/docs/v3.1/www3/MPI_Type_create_darray.html">MPI darray type</a> that is useful for reading chunks of the file directly without writing too much code. MPI lets you define a ‘view’ of a file and each process can just read its part of the view. It lets you define “distributed array” data types which you can use for directly reading a matrix stored in a file into memory in a block cyclic manner accoridng to the co-ordinates of the processor. We use the <code>MPI_Type_create_darray</code> <a href="http://mpi.deino.net/mpi_functions/MPI_Type_create_darray.html">function</a> for this purpose.</p>

<p>Here’s a sample usage of this function for initializing a <code>MPI_darray</code>:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
<a href="#n18" name="n18">18</a>
<a href="#n19" name="n19">19</a>
<strong><a href="#n20" name="n20">20</a></strong>
<a href="#n21" name="n21">21</a>
<a href="#n22" name="n22">22</a>
<a href="#n23" name="n23">23</a>
<a href="#n24" name="n24">24</a>
<a href="#n25" name="n25">25</a>
</pre></td>
  <td class="code"><pre>MPI_Status status;
MPI_Datatype MPI_darray;
<span style="color:#0a8;font-weight:bold">int</span> N = <span style="color:#00D">8</span>, nb = <span style="color:#00D">4</span>;
<span style="color:#0a8;font-weight:bold">int</span> dims[<span style="color:#00D">2</span>] = {N, N};
<span style="color:#0a8;font-weight:bold">int</span> distribs[<span style="color:#00D">2</span>] = {MPI_DISTRIBUTE_CYCLIC, MPI_DISTRIBUTE_CYCLIC};
<span style="color:#0a8;font-weight:bold">int</span> dargs[<span style="color:#00D">2</span>] = {nb, nb};
<span style="color:#0a8;font-weight:bold">int</span> proc_nrows = <span style="color:#00D">2</span>, proc_ncols = <span style="color:#00D">2</span>;
<span style="color:#0a8;font-weight:bold">int</span> proc_dims[<span style="color:#00D">2</span>] = {proc_nrows, proc_ncols};

MPI_Type_create_darray(
    num_procs, <span style="color:#777">// size of process group (positive integer)</span>
    proc_id, <span style="color:#777">// rank in process group (non-negative integer)</span>
    <span style="color:#00D">2</span>, <span style="color:#777">//         number of array dimensions as well as process grid dimensions (positive integer)</span>
    dims, <span style="color:#777">// number of elements of type oldtype in each dimension of global array (array of positive integers)</span>
    distribs, <span style="color:#777">// distribution of array in each dimension (array of state)</span>
    dargs, <span style="color:#777">// distribution argument in each dimension (array of positive integers)</span>
    proc_dims, <span style="color:#777">// size of process grid in each dimension (array of positive integers)</span>
    MPI_ORDER_C, <span style="color:#777">// array storage order flag (state)</span>
    MPI_INT, <span style="color:#777">// old datatype (handle)</span>
    &amp;MPI_darray <span style="color:#777">// new datatype (handle)</span>
);
MPI_Type_commit(&amp;MPI_darray);
MPI_Type_size(MPI_darray, &amp;darray_size);
nelements = darray_size / <span style="color:#00D">4</span>;
MPI_Type_get_extent(MPI_darray, &amp;lower_bound, &amp;darray_extent);
</pre></td>
</tr></table>
</div>

<p>For reading a file in MPI, you need to use the <code>MPI_File_*</code> functions. This involves opening the file like any other normal file, but that file is handled internally by MPI. You need to set a ‘view’ for the file for each MPI process, and then the process can ‘seek’ the appropriate location in the file and read the required data.</p>

<p>The following code in useful for this purpose:</p>
<div class="language-c highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>
</pre></td>
</tr></table>
</div>

<p>Sometimes reading from files can give divide-by-zero errors,</p>

<p>Note on <code>MPI_File_set_view</code>: this function is used for setting a ‘file view’ for each process so that the process knows where to start the data reading from. In case you’re using <code>MPI_File_read_all</code> you should know that the file pointer is set implicitly and you don’t need to explicitly supply an offset value. The file pointer for the current view is set based on what the process previous to this process accessed.</p>

<p>A full program for performing a matrix multiplication using PBLAS and BLACS using a block cyclic data distribution can be found <a href="">here</a>. Some more docs are <a href="http://mpi-forum.org/docs/mpi-2.2/mpi22-report/node73.htm">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging MPI Programs With GDB]]></title>
    <link href="http://v0dro.github.io/blog/2018/04/04/debugging-mpi-programs-with-gdb/"/>
    <updated>2018-04-04T15:04:47+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/04/04/debugging-mpi-programs-with-gdb</id>
    <content type="html"><![CDATA[<p>When programming with MPI you might get run time errors like segfaults due to faulty IO programming or the like.</p>

<p>Since you’re programming in a distributed environment, using gdb with MPI programs is a bit of a challenge, but is quite possible and reasonalbly easy to use as well. All you need to do is use the <code>mpirun</code> command with gdb in the following manner:</p>
<pre><code>mpirun -np &lt;num_processes&gt; xterm -e gdb ./a.out
</code></pre>

<p>A modified Makefile using the above command would look like so:</p>
<pre><code>mpi_debug: mpi_types.o $(SOURCES)
	$(CXX) $? -llapacke -llapack -lcblas
    mpirun -np 2 xterm -e gdb ./a.out
</code></pre>

<p>You can then call <code>run</code> inside gdb for each process. <a href="https://stackoverflow.com/questions/329259/how-do-i-debug-an-mpi-program">This stackoverflow answer</a> provides more insights into this.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Learning FORTRAN]]></title>
    <link href="http://v0dro.github.io/blog/2018/03/30/notes-on-learning-fortran/"/>
    <updated>2018-03-30T12:50:57+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/03/30/notes-on-learning-fortran</id>
    <content type="html"><![CDATA[<p>I’ve been trying to understand the distributed <a href="http://people.eecs.berkeley.edu/~demmel/cs267/lecture12/pdgetrf.f">block LU code written in ScaLAPACK</a>, which is written in FORTRAN. In order to understand the algorithms properly I took a 30 min crash course in FORTRAN. In this blog post I’ll write some details about the language that are relevant to understanding the ScaLAPACK code.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#learning-resources">Learning resources</a></li>
  <li><a href="#salient-fortran-features">Salient FORTRAN features</a>
    <ul>
      <li><a href="#program-structure">Program structure</a></li>
      <li><a href="#printing">Printing</a></li>
    </ul>
  </li>
  <li><a href="#fortran-wrt-scalapack">FORTRAN w.r.t ScaLAPACK</a>
    <ul>
      <li><a href="#subroutines-and-functions">Subroutines and functions</a></li>
      <li><a href="#arrays">Arrays</a></li>
      <li><a href="#logical-and-comparison-expressions">Logical and comparison expressions</a></li>
      <li><a href="#loops">Loops</a></li>
    </ul>
  </li>
</ul>

<!-- markdown-toc end -->

<h1 id="learning-resources">Learning resources</h1>

<ul>
  <li><a href="https://www.tutorialspoint.com/fortran/index.htm">Fortran tutorial on tutorialspoint</a>.</li>
  <li><a href="https://www.fortrantutorial.com/">Fortran tutorial website</a>.</li>
  <li><a href="http://www.chem.ox.ac.uk/fortran/subprograms.html">Functions and subroutines</a>.</li>
  <li><a href="http://pages.mtu.edu/~shene/COURSES/cs201/NOTES/F90-Basics.pdf">Presentation on F90 basics</a>.</li>
  <li><a href="http://www.fortran.com/fortran_storenew/Html/Info/books/gd3_c04_1.html">Fortran Arrays</a>.</li>
  <li><a href="http://www.pcc.qub.ac.uk/tec/courses/f90/stu-notes/F90_notesMIF_6.html">Logical and comparison expressions</a>.</li>
</ul>

<h1 id="salient-fortran-features">Salient FORTRAN features</h1>

<p>Here’s a simple addition program:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
</pre></td>
  <td class="code"><pre>program addNumbers

! This simple program adds two numbers. This is a comment.
   implicit none
   
! Type declarations
   real :: a, b, result 
   
! Executable statements 
   a = 12.0
   b = 15.0
   result = a + b
   print *, 'The total is ', result
   
end program addNumbers 
</pre></td>
</tr></table>
</div>

<p>Each program begins with keyword <code>program &lt;prog_name&gt;</code> and ends with <code>end program &lt;prog_name&gt;</code>.</p>

<p>A statement <code>implicit none</code> allows the compiler to check whether all variable types are declared correctly. This statement must be there to check if types have been declared correctly.</p>

<h2 id="program-structure">Program structure</h2>

<p>A full program should be kept inside a <code>program</code> statement. A simple ‘hello world!’ program
looks like so:</p>
<pre><code>program hello
  implicit none

  print*,"Hello"
  print*,"World!"
end program
</code></pre>

<h2 id="printing">Printing</h2>

<p>Write to standard output using the <code>print</code> statement.</p>

<p>Link: https://en.wikibooks.org/wiki/Fortran/Fortran_simple_input_and_output</p>

<p>Printing multi-dimensional arrays can be tricky since the <code>print</code> statement by
default outputs newlines after each printing. Here’s a link that explains how
to print 2d arrays in fortran using <code>write</code>:</p>

<p>Link: https://jblevins.org/log/array-write</p>

<p>If you want to use format specifiers with floating point numbers, read below link:</p>

<p>Link: https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap05/format.html</p>

<h1 id="fortran-wrt-scalapack">FORTRAN w.r.t ScaLAPACK</h1>

<h2 id="subroutines-and-functions">Subroutines and functions</h2>

<p>I will now explain the <code>pdgetrf</code> routine from ScaLAPACK.</p>

<p>The <code>SUBROUTINE</code> keyword is used for defining subroutines. For example:</p>
<pre><code>SUBROUTINE PDGETRF( M, N, A, IA, JA, DESCA, IPIV, INFO )
</code></pre>
<p>Types of arguments to subroutines are defined in the subroutine definition itself. For example, in scalapack:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre>*     .. Scalar Arguments ..
      INTEGER            IA, INFO, JA, M, N
*     ..
*     .. Array Arguments ..
      INTEGER            DESCA( * ), IPIV( * )
      DOUBLE PRECISION   A( * )
</pre></td>
</tr></table>
</div>

<p>Unlike in C, the argument types are not declared alongwith the  name and argument list.</p>

<p>Functions and subroutines are different in FORTRAN. The main difference lies in the fact that functions can be used in an expression and can return only one value (exactly like functions in C or Java). A subroutine on the other hand, cannot be used in expressions, but has the advantage that it can be used for returning multiple values. In the respect of returning multiple values it is somewhat similar to MATLAB functions.</p>

<p>A subroutine ends with the <code>RETURN</code> and <code>END</code> statement. The arguements passed to a subroutine are similar to call by reference in the case of C. If you modify any value inside the subroutine, the value will be modified in the calling function too.</p>

<p>In order to tell the compiler the return value of a function, you must use the name of the function in an assignment statement that will tell the compiler the value to be returned. For example:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
</pre></td>
  <td class="code"><pre> REAL FUNCTION AVRAGE(X,Y,Z)
     REAL X,Y,Z,SUM
     SUM = X + Y + Z
     AVRAGE = SUM /3.0
 RETURN
 END
</pre></td>
</tr></table>
</div>

<h2 id="arrays">Arrays</h2>

<p>Arrays are used/declared in a similar manner to C. For example, to declare an array:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>INTEGER            IDUM1( 1 ), IDUM2( 1 )
</pre></td>
</tr></table>
</div>
<p>Array elements can be accessed using round brackets:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>ICTXT = DESCA( 7 )
</pre></td>
</tr></table>
</div>

<p>By default, arrays in fortran begin from index <code>1</code>.</p>

<p>One can also specify the <code>kind</code> parameter in the array to tell the compiler which of its suppported
kinds it should use.</p>

<p>Multi-dimensional arrays are referenced in their indexing the same way as C arrays <code>(row, col)</code> but
the internal storage is of course column major. See the second link below.</p>

<p>Link:</p>
<ul>
  <li>https://stackoverflow.com/questions/838310/fortran-90-kind-parameter</li>
  <li>https://www.obliquity.com/computer/fortran/array.html</li>
</ul>

<h2 id="logical-and-comparison-expressions">Logical and comparison expressions</h2>

<p>Logical and comparison operators are written enclosed in dots. So <code>&amp;&amp;</code> in C is
<code>.AND.</code> in fortran. Similarly, <code>!=</code> is <code>.NE.</code>.</p>

<h2 id="loops">Loops</h2>

<p>Fortran has a curious way of writing loops, given that I’m coming from the C world. 
Loops are written using the <code>do-continue</code> syntax. Each loop statement in a program 
requires a statement label. Any label number can be used but the <code>do</code> and <code>continue</code>
of a single block must have the same label.</p>

<p>The variable that is defined in the line of the <code>do</code> block is the counter variable.
Its default step is <code>1</code> but you can change that as you want.</p>

<p>The general form is:</p>
<div class="language-fortran highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>do label var =  expr1, expr2, expr3
  ! statements
label continue
</pre></td>
</tr></table>
</div>

<p>In the above loop, <code>var</code> is the loop variable (this must be an integer). <code>expr1</code>
specifies the initial value of <code>var</code>, <code>expr2</code> is the terminating bound, and 
<code>expr3</code> is the increment (step).</p>

<p>Many Fortran 77 compilers allow <code>do</code>-loops to be closed by the <code>enddo</code> 
statement. The advantage of this is that the statement label can then be omitted
since it is assumed that an <code>enddo</code> closes the nearest previous do statement. 
The <code>enddo</code> construct is widely used, but it is not a part of ANSI Fortran 77.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Learning Emacslisp]]></title>
    <link href="http://v0dro.github.io/blog/2018/03/26/notes-on-learning-emacslisp/"/>
    <updated>2018-03-26T11:33:21+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/03/26/notes-on-learning-emacslisp</id>
    <content type="html"><![CDATA[<p>Recently, I started development of an emacs language mode called <a href="https://github.com/v0dro/rubex-mode-emacs">rubex-mode</a> for supporting Rubex syntax highlighting in emacs. This took me to the <a href="https://www.emacswiki.org/emacs/ModeTutorial">ModeTutorial</a> on the emacs wiki, which is a very detailed tutorial for learning how to write new emacs language modes. Before starting the tutorial I had no knowledge of Emacslisp or writing emacs language modes.</p>

<p>In this post I will share some of the important things that I learned about Emacslisp and some things that I think are important about writing language modes for Emacs.</p>

<h1 id="learning-resources">Learning resources</h1>

<ul>
  <li><a href="https://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html">Learn emacs lisp in 15 minutes</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/">Programming in Emacs Lisp</a></li>
  <li><a href="https://emacs.stackexchange.com/questions/715/how-to-know-when-or-when-not-to-use-the-single-quote-before-variable-names">How to know whether to use single quote in elisp.</a></li>
  <li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">Quote in elisp</a></li>
</ul>

<h1 id="emacs-lisp-basics">Emacs lisp basics</h1>

<h2 id="lisp-evaluation">Lisp evaluation</h2>

<p>If you enable ‘lisp-interaction-mode’ in emacs you can evaluate lisp using the <code>C-j</code> shortcut. That will insert the result of the evaluation in the buffer. <code>C-x C-e</code> displays the same result in the minibuffer.</p>

<h2 id="sexps">Sexps</h2>

<p>Programs are made of symbolic expressions (pre-fix notation), like <code>(+ 2 2)</code>, this means ‘2 + 2’.</p>

<p>Expressions are made of atomic expressions or more symbolic expressions. In <code>(+ 2 (+ 1 1))</code>, 1 and 2 are atoms, (+ 2 (+ 1 1)) and (+ 1 1) are symbolic expressions.</p>

<h2 id="getting-and-setting-variables">Getting and setting variables</h2>

<p><code>setq</code> stores a value into a variable:</p>
<div class="language-elisp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>(setq my-name &quot;sameer&quot;)
</pre></td>
</tr></table>
</div>

<p>Variables can also be initialized using <code>defvar</code>. The emacswiki page is <a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/defvar.html">here</a>. <code>defvar</code> is similar to <code>setq</code>, but the difference is that <code>defvar</code> will not set the variable if it already has a value.</p>

<h2 id="setting-global-constants">Setting global constants</h2>

<p>The <code>defconst</code> keyword is used for setting global constants. It informs a person reading your code that symbol has a standard global value, established here, that should not be changed by the user or by other programs. Note that symbol is not evaluated; the symbol to be defined must appear explicitly in the defconst.</p>

<p>For example:</p>
<pre><code>(defconst pi 3.141592653589793 "The value of Pi.")
</code></pre>
<p>Above code initializes the variable <code>pi</code> to a value and sets a docstring.</p>

<h2 id="functions">Functions</h2>

<p>Functions can be defined using the <code>defun</code> keyword. For example, to defined a function <code>hello</code> that accepts an argument <code>name</code> and inserts the variable with a string on the buffer:</p>
<pre><code>(defun hello (name) (insert "Hello " name))
</code></pre>

<p>Fun fact: when evaluating elisp in a buffer, place the cursor at the bottom of the file otherwise emacs will only evaluate code until the cursor and throw unexpected output.</p>

<h2 id="combining-expressions">Combining expressions</h2>

<p>You can use the <code>progn</code> form for evaluating a set of expressions one by one and returning the value of the last one. The preceding expressions are only evaluated for their side effects and their values are discarded.</p>

<p>All emacs commands are basically just elisp function calls. So you can call something like this:</p>
<pre><code>(progn
  (switch-to-buffer-other-window "*scratch*")
  (hello "you"))
</code></pre>
<p>And it will switch the active window to the <code>*scratch*</code> buffer and print <code>Hello you</code> in the buffer.</p>

<p>A value can be bound to a local variable using <code>let</code>. This command can also be used for combining several sexps.</p>
<pre><code>(let ((local-name "you"))
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello local-name))
</code></pre>

<h2 id="quote">Quote</h2>

<p><code>quote</code> is a special form in elisp that returns its single argument, without 
evaluating it. This provides a way to include constants and lists, which are not 
self-evaluating objects, in a program. This <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html">link</a> talks about it in detail.</p>

<p>Its used so often that a short form of using a single quote is often used instead (<code>'</code>). This <a href="https://emacs.stackexchange.com/questions/715/how-to-know-when-or-when-not-to-use-the-single-quote-before-variable-names">answer</a> talks in detail about when to and when not to use it.</p>

<p>In general, if you are trying to use the variable itself, use the quoted form, otherwise directly use the variable name. For example, in the expression <code>(mapcar 'hello list-of-names)</code>, we use a quoted <code>hello</code> because don’t actually want to call the function, we just want to pass a reference to it to the <code>mapcar</code> function which will then call <code>hello</code> at its own leisure.</p>

<h2 id="lists">Lists</h2>

<p>A list of names can be stored like so:</p>
<pre><code>(setq list-of-names '("Sarah" "Chloe" "Mathilde"))
</code></pre>

<p>The above expression is quoted because we want to set the whole expression as a list to <code>list-of-names</code>.</p>

<p>Use the <code>car</code> function for getting the first element of the list and <code>cdr</code> for getting all elements except the first element.</p>

<h3 id="cons-cells">Cons cells</h3>

<p>Lists are composed of cons cells. Each cons cell is a tuple of two lisp objects,
the <code>car</code> and <code>cdr</code>. In the case of a list, the first slot of a cons cell holds 
the element of the list and the next part chains to the next element of the list. 
The cdr of the last cell of the list is <code>nil</code>. This helps in detecting the end 
of a list.</p>

<h2 id="dotted-pair-notation">Dotted pair notation</h2>

<p>A dotted pair notation is a general syntax for creating cons cells that represents
the car and cdr explicitly.  In this syntax, <code>(a . b)</code> stands for a cons cell whose 
<code>car</code> is the object <code>a</code> and whose <code>cdr</code> is the object <code>b</code>. Dotted pair notation is 
more general than list syntax because the <code>cdr</code> does not have to be a list.</p>

<p>Dotted pairs can be chained together to form a list. For example, <code>(1 2 3)</code> is written 
as <code>(1 . (2 . (3 . nil)))</code>.</p>

<h1 id="writing-an-emacs-major-mode">Writing an emacs major mode</h1>

<h2 id="basic-mode-setup">Basic mode setup</h2>

<p>There are certain variables that all modes must define. Here’s a list:</p>
<ul>
  <li><code>wpdl-mode-hook</code>: allows the user to run their own code when your mode is run.</li>
  <li><code>wpdl-mode-map</code>: allows both you and your users to define their own keymaps.</li>
</ul>

<p>In order to tell emacs that this mode must start when a particular file extension is detected, we add to a list called <code>auto-mode-alist</code> using the <code>add-to-list</code> function. For example:</p>
<pre><code>(add-to-list 'auto-mode-alist '("\\.rubex\\'" . rubex-mode))
</code></pre>

<p>Protip: An <code>alist</code> is for historical reasons made of plain cons cells instead of full lists.</p>

<h2 id="syntax-highlighting">Syntax highlighting</h2>

<h2 id="indentation">Indentation</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing Block LU Decomposition Using MPI and BLACS]]></title>
    <link href="http://v0dro.github.io/blog/2018/03/23/implementing-block-lu-decomposition-using-mpi-and-blacs/"/>
    <updated>2018-03-23T18:42:53+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/03/23/implementing-block-lu-decomposition-using-mpi-and-blacs</id>
    <content type="html"><![CDATA[<p>Recently I was tasked with implemented a block LU decomposition in parallel using
a block cyclic process distribution using BLACS and MPI. This decomposition would
then be extended to hierarchical matrices and would eventually work with dense matrices
instead of hierarchical. Thus we cannot use already implemented distributed LU factorization
methods like scalapack for this purpose.</p>

<p>In this post I would like to document my learnings about desinging the parallel algorithm
and installing the various libraries that are required for this purpose. Hopefully, the reader
will find something useful in this post too. This post will cover only LU factorization of dense
matrices. Hierarchical matrices will be covered in another post.</p>

<p>I have written about using the scalapack C++ interface for a simple block LU decomposition 
in <a href="URL">this</a> post.</p>

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>

<ul>
  <li><a href="#installing-libraries">Installing libraries</a></li>
  <li><a href="#designing-the-algorithm">Designing the algorithm</a>
    <ul>
      <li><a href="#asynchronous-block-lu">Asynchronous block LU</a></li>
      <li><a href="#synchronous-block-lu">Synchronous block LU</a></li>
      <li><a href="#resources">Resources</a></li>
    </ul>
  </li>
  <li><a href="#implementation-with-mpi">Implementation with MPI</a>
    <ul>
      <li><a href="#block-cyclic-data-distribution">Block cyclic data distribution</a>
        <ul>
          <li><a href="#block-cyclic-nomenclature">Block cyclic nomenclature</a></li>
        </ul>
      </li>
      <li><a href="#scalapack-protips">ScaLAPACK protips</a>
        <ul>
          <li><a href="#use-of-m-and-n-in-routines">Use of M and N in routines</a></li>
        </ul>
      </li>
      <li><a href="#blacs-protips">BLACS protips</a>
        <ul>
          <li><a href="#blacs-topologies">BLACS topologies</a></li>
          <li><a href="#blacs-general-apis">BLACS general APIs</a></li>
        </ul>
      </li>
      <li><a href="#asynchronous-block-lu">Asynchronous block LU</a></li>
      <li><a href="#synchronous-block-lu">Synchronous block LU</a></li>
    </ul>
  </li>
  <li><a href="#resources">Resources</a>
    <ul>
      <li><a href="#blacs">BLACS</a></li>
    </ul>
  </li>
</ul>

<!-- markdown-toc end -->

<h1 id="installing-libraries">Installing libraries</h1>

<p>For this computation, we use MPICH and <a href="">BLACS</a>. While MPICH is easily installable on most
GNU/Linux distributions, the same cannot be said for BLACS.</p>

<p>I first tried downloading <a href="">BLACS sources</a> and compiling the library, however it gave too
many compilation errors and was taking a long time to debug. Therefore, I resorted to using
the <a href="">ScaLAPACK installer</a>, which is a Python script that downloads the sources of BLACS,
LAPACK and ScaLAPACK, compiles all these libraries on your system and produces a single 
shared object file <code>libscalapack.a</code> which you can use for linking with your program. 
Since BLACS is included in the ScaLAPACK distribution, you can use the scalapack binary
directly for linking.</p>

<p>Just download the ScaLAPACK installer from the website and follow the instructions in the README for quick and easy installation.</p>

<h1 id="designing-the-algorithm">Designing the algorithm</h1>

<h2 id="asynchronous-block-lu">Asynchronous block LU</h2>

<p>One problem that I faced when designing the algorithm is that when writing a CBLACS
program, you are basically writing the same code that is being run on multiple processes, 
however the data that is stored in variables is not the same for each process.</p>

<p>So it becomes important to write the program in such a way that maximum data is shared
between the processes but there is minimmum communication of things like the block
that is currently under process.</p>

<p>If it is a diagonal block, it simply factorizes the block into L &amp; U parts and broadcasts
it to rows and columns.</p>

<p>If it is a row or column block, it listens for the broadcast from the diagonal block and mutliplies the contents that it receives with the data it posseses. It then broadcasts the multiplied matrix block accross the lower right block so that the block can be reduced.</p>

<p>It can be expressed with this line of code:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>p2p_recv(recv_block, blocksize, rows[index] % N, rows[index] % N);
</pre></td>
</tr></table>
</div>

<p>The source row and source col arguments (last two) are computed by keeping in mind
that we can compute the diagonal block of a particular block if we know the absolute
row number of the block.</p>

<p>If is a block in the right lower block of the matrix (the A^ block), it waits for 
the broadcast from the row and column elements, multiplies the received data with
the stored data and over writes the stored data.</p>

<p>The computation and communication is mostly asynchronous. This means that there
needs to be some kind of a trigger to launch the computation or communication
tasks in a given process.</p>

<p>A major problem is synchronization of successive diagonal matrix blocks. The
computation must proceed from the top left corner of the matrix until the lower
right corner. For this to work properly it is important that the diagonal blocks
do not compute and send their data unless the diagonal block to the upper left 
of the block has finished computing.</p>

<h2 id="synchronous-block-lu">Synchronous block LU</h2>

<p>The main thing to take care of in synchronous block LU is that of the indexing of the data array
and the subsequent generation of the matrix. To demonstrate, here is what the matrix structure of
the synchronous block LU looks like:</p>

<!-- insert that hand drawn image of sync block LU here -->

<p>We can know the actual row and col number of the global matrix through the process ID and the
block number. The following lines of code are useful for this purpose:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
</pre></td>
  <td class="code"><pre><span style="color:#777">// bcounter_i is a counter identifying the block row within a process</span>
<span style="color:#777">// bcounter_j is a counter identifying the block col within a process</span>
<span style="color:#777">// num_blocks_per_process is the number of blocks in a process</span>
<span style="color:#777">// myrow is the BLACS process row number</span>
<span style="color:#777">// mycol is the BLACS process col number</span>
<span style="color:#777">// block_size_per_process_r is the row size of each block within the process</span>
<span style="color:#777">// block_size_per_process_c is the col size of each block within the process</span>

row_i = bcounter_i*num_blocks_per_process + myrow*block_size_per_process_r + i;
col_j = bcounter_j*num_blocks_per_process + mycol*block_size_per_process_c + j;
</pre></td>
</tr></table>
</div>

<p>We can get the index number of the data array in the following manner:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre><span style="color:#0a8;font-weight:bold">int</span> index = (bcounter_i*block_size_per_process_r + bcounter_j)*
    num_blocks_per_process +  i*process_block_size + j;
</pre></td>
</tr></table>
</div>

<p>Before creating a full-fledged version of this code, I first made a simple code
that would calculate the LU decomposition in the case where there is only one
matrix block per process.</p>

<h2 id="resources">Resources</h2>

<p>Some resources that I found during this phase are as follows:</p>
<ul>
  <li><a href="http://www.mcs.anl.gov/~itf/dbpp/">Designing and building parallel programs.</a></li>
  <li><a href="http://www-users.cs.umn.edu/~karypis/parbook/">Introduction to Parallel Computing.</a></li>
  <li><a href="https://computing.llnl.gov/tutorials/parallel_comp/#Designing">Designing parallel programs course.</a></li>
  <li><a href="http://people.eecs.berkeley.edu/~demmel/cs267/lecture12/lecture12.html">Lecture on parallel Gaussian from Berkeley</a>.</li>
  <li><a href="https://cseweb.ucsd.edu/classes/sp07/cse262/Projects/260_fa06/Ricketts_SR.pdf">Parallelizing LU factorization.</a></li>
</ul>

<h1 id="implementation-with-mpi">Implementation with MPI</h1>

<p>Each process should hold only the part of the matrix that it is working upon.</p>

<h2 id="block-cyclic-data-distribution">Block cyclic data distribution</h2>

<p>The block cyclic distribution is a central idea in the case of PBLAS and BLACS.
It is important to store the matrix in this configuration since it is the most 
efficient in terms of load balancing for most applications.</p>

<p>If you’re reading a matrix from an external file it can get cumbersome to read 
into in a block cyclic manner manually. You do this with little effort using MPI IO.
Refer <a href="URL">this blog post</a> that describes this in detail along with C code.</p>

<p>For this code we generate the data on a per process basis.</p>

<h3 id="block-cyclic-nomenclature">Block cyclic nomenclature</h3>

<p>Its somewhat confusing how exactly the blocks are named. So here’s the nomenclature
I’m using when talking about certain kinds of blocks:</p>
<ul>
  <li>Process blocks :: blocks inside a process.</li>
  <li>Matrix blocks :: blocks of the global matrix.</li>
  <li>Matrix sub-blocks :: Each matrix block is divided into sub-blocks that are scattered
over processes. Each of these sub-blocks corresponds to a single process block.</li>
</ul>

<h2 id="scalapack-protips">ScaLAPACK protips</h2>

<h3 id="use-of-m-and-n-in-routines">Use of M and N in routines</h3>

<p>ScaLAPACK operates on a block cyclic data distribution. Most of the routines accept
two parameters: <code>M</code> and <code>N</code> that are described as the number of rows and cols of the
distributed submatrix sub(A). Its easy to get confused by thinking of these variables
as the dimensions of the <em>global</em> matrix. However, since scalapack relies on a block
cyclic data distribution, the ‘world’ for all processes at <em>one</em> time is basically one
matrix block which is spread over all the processes. Therefore, when calling scalapack
routines care must be taken to specify the dimensions of the matrix block in <code>M</code> and <code>N</code>
and not those of the global matrix.</p>

<p>If you see other code that does not rely on multiple sub-matrix blocks inside processes, 
they will usually pass the dimensions of the global matrix to the routine, which is correct
for that case since there is only one sub-matrix block per process.</p>

<h2 id="blacs-protips">BLACS protips</h2>

<h3 id="blacs-topologies">BLACS topologies</h3>

<h3 id="blacs-general-apis">BLACS general APIs</h3>

<p>Similar to MPI, BLACS contains some routines for sending and receiving data in 
a point-to-point manner. They are as below:</p>
<ul>
  <li><code>gesd2d</code>: This routine is for point-to-point sending of data from one process to another. This routine is non-blocking by default (unlike <code>MPI_Send</code> which is blocking). It’s prototype for the C interface is as follows:
    <div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> Cdgesd2d(
  <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS context</span>
  <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// row size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// col size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">double</span>* A, <span style="color:#777">// pointer to matrix block</span>
  <span style="color:#0a8;font-weight:bold">int</span> LDA, <span style="color:#777">// leading dim of A (col size for C programs)</span>
  <span style="color:#0a8;font-weight:bold">int</span> RDEST, <span style="color:#777">// row number of destination process</span>
  <span style="color:#0a8;font-weight:bold">int</span> CDEST <span style="color:#777">// col number of destination process</span>
);
</pre></td>
</tr></table>
    </div>
  </li>
  <li><code>trsd2d</code>: This routine is used for point-to-point sending of trapezoidal matrices.</li>
  <li><code>gerv2d</code>: This routine is used for point-to-point receiving of general rectangular
matrices. This routine will block until the message is received. Its prototype looks like so:
    <div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">void</span> Cdgerv2d(
  <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS conntext</span>
  <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// row size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// col size of matrix block</span>
  <span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#777">// pointer to matrix data.</span>
  <span style="color:#0a8;font-weight:bold">int</span> LDA, <span style="color:#777">// leading dim of A (col size for C)</span>
  <span style="color:#0a8;font-weight:bold">int</span> RSRC, <span style="color:#777">// process row co-ordinate of the sending process.</span>
  <span style="color:#0a8;font-weight:bold">int</span> CSRC <span style="color:#777">// process col co-ordinate of the sending process.</span>
);
</pre></td>
</tr></table>
    </div>
  </li>
</ul>

<p>For broadcast receive, there is the <code>gebr2d</code> routine. This routine is particularly 
useful since it can broadcast over all processes, or a specific row or column. 
This can be helpful over using MPI directly since it allows us to easily broadcast
over rows or columns without having to define separate communicators.</p>

<p>The prototype of this routine is as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
</pre></td>
  <td class="code"><pre><span style="color:#777">// Cd stands for 'C double'</span>
<span style="color:#777">// ge is 'general rectangular matrix'</span>
<span style="color:#777">// br is 'broadcast receive'</span>
<span style="color:#088;font-weight:bold">void</span> Cdgebr2d(
    <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS context</span>
    <span style="color:#0a8;font-weight:bold">char</span>* SCOPE, <span style="color:#777">// scope of the broadcast. Can be &quot;Row&quot;, &quot;Column&quot; or &quot;All&quot;</span>
    <span style="color:#0a8;font-weight:bold">char</span>* TOP, <span style="color:#777">// indicates communication pattern to use for broadcast.</span>
    <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// number of rows of matrix.</span>
    <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// number of columns of matrix.</span>
    <span style="color:#0a8;font-weight:bold">double</span>* A, <span style="color:#777">// pointer to matrix data.</span>
    <span style="color:#0a8;font-weight:bold">int</span> LDA, <span style="color:#777">// leading dim of matrix (col size for C)</span>
    <span style="color:#0a8;font-weight:bold">int</span> RSRC, <span style="color:#777">// process row co-ordinate of the process who called broadcast/send.</span>
    <span style="color:#0a8;font-weight:bold">int</span> CSRC <span style="color:#777">// process column co-ordinate of the process who called broadcast/send.</span>
);
</pre></td>
</tr></table>
</div>

<p>For broadcast send, there is the <code>gebs2d</code> routine. This is helpful for receiving broadcasts.
The prototype of this function is as follows:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
</pre></td>
  <td class="code"><pre>Cdgebs2d(
    <span style="color:#0a8;font-weight:bold">int</span> CBLACS_CONTEXT, <span style="color:#777">// CBLACS context.</span>
    <span style="color:#0a8;font-weight:bold">char</span>* SCOPE, <span style="color:#777">// scope of broadcast. can be &quot;All&quot;, &quot;Row&quot; or &quot;Column&quot;.</span>
    <span style="color:#0a8;font-weight:bold">char</span>* TOP, <span style="color:#777">// network topology to be used.</span>
    <span style="color:#0a8;font-weight:bold">int</span> M, <span style="color:#777">// num of rows of the matrix.</span>
    <span style="color:#0a8;font-weight:bold">int</span> N, <span style="color:#777">// num of cols of the matrix.</span>
    <span style="color:#0a8;font-weight:bold">double</span> *A, <span style="color:#777">// pointer to the matrix data.</span>
    <span style="color:#0a8;font-weight:bold">int</span> LDA <span style="color:#777">// leading dimension of A.</span>
);
</pre></td>
</tr></table>
</div>
<p>The <code>TOP</code> argument specifies the communication pattern to use. Leave it as a blank space
(<code>" "</code>) to use the default.</p>

<h2 id="asynchronous-block-lu-1">Asynchronous block LU</h2>

<h2 id="synchronous-block-lu-1">Synchronous block LU</h2>

<p>In the asynchronous LU, it is assumed that the block size is equal to the processor size,
i.e each block of the matrix is limited to only a single processor. For synchronous LU 
decomposition, we take blocks which are spread out over multiple processors. To illustrate, 
see the below figure:</p>

<p>Four of the above colors represent a single block and each color represents a process. This
means that each block is spread out over 4 processes. This ensures that the processes are
always kept busy no matter the operation.</p>

<p>It should be remembered that scalapack expects the data to be in column-major format.
Therefore, it must be stored that way.</p>

<h1 id="resources-1">Resources</h1>

<h2 id="blacs">BLACS</h2>

<ul>
  <li><a href="https://software.intel.com/en-us/mkl-developer-reference-c-blacs-routines">Intel MKL BLACS resources</a>.</li>
  <li><a href="https://andyspiros.wordpress.com/2011/07/08/an-example-of-blacs-with-c/">Blog post detailing use of BLACS for scatter operations.</a></li>
  <li><a href="http://www.netlib.org/blacs/BLACS/QRef.html#BS">Netlib BLACS reference</a>.</li>
  <li><a href="http://www.netlib.org/blacs/BLACS/Array.html">BLACS array-based communication</a>.</li>
  <li><a href="http://www.netlib.org/lapack/lawnspdf/lawn94.pdf">BLACS user manual</a>.</li>
  <li><a href="http://www.netlib.org/blacs/BLACS/Top.html">BLACS communication topologies</a>.</li>
  <li><a href="https://scicomp.stackexchange.com/questions/1688/how-do-i-use-scalapack-pblas-for-matrix-vector-multiplication">Using PBLAS for matrix multiplication.</a></li>
  <li><a href="https://software.intel.com/en-us/mkl-developer-reference-c-pblas-routines-overview">PBLAS rountines overview from Intel.</a></li>
  <li><a href="http://www.nersc.gov/users/software/programming-libraries/math-libraries/libsci/libsci-example/">ScaLAPACK pdgemm matrix multiplication example.</a></li>
  <li><a href="http://www.training.prace-ri.eu/uploads/tx_pracetmo/scalable_linear_algebra.pdf">Presentation about Scalapack/PBLAS/BLACS with good details on usage.</a></li>
  <li><a href="http://www.netlib.org/utk/papers/scalapack/node8.html">Block cyclic data distribution (netlib).</a></li>
  <li><a href="http://www.netlib.org/blacs/BLACS/Top.html">BLACS Topology.</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Japan Chronicles]]></title>
    <link href="http://v0dro.github.io/blog/2018/02/02/japan-chronicles/"/>
    <updated>2018-02-02T21:57:46+09:00</updated>
    <id>http://v0dro.github.io/blog/2018/02/02/japan-chronicles</id>
    <content type="html"><![CDATA[<p>In this post (which will hopefully be continually upgraded for a long, long time) I will document some interesting experiences that I have been having as an Indian living and studying in Japan.</p>

<h1 id="reflections-of-life-in-tokyo">Reflections of life in Tokyo</h1>

<h2 id="life-in-a-university-cs-lab">Life in a university CS lab</h2>

<h2 id="dorm-life">Dorm life</h2>

<h2 id="moving-to-a-new-apartment">Moving to a new apartment</h2>

<h1 id="travelling-aroung-tokyo">Travelling aroung Tokyo</h1>

<p>Since the past 4 months I have been very busy with settling down into a new life and doing some 
really challenging work at my University. In this subsection I will document my experiences of 
travelling around the wonderful city of Tokyo. You can of course follow my <a href="">instagram</a> or 
<a href="">twitter</a> for quick updates :)</p>

<h1 id="travelling">Travelling</h1>

<h2 id="hiking">Hiking</h2>

<h3 id="mt-takao">Mt. Takao</h3>

<h3 id="mt-koubou">Mt. Koubou</h3>

<h3 id="okutama-valley">Okutama valley</h3>

<h3 id="mt-fuji">Mt. Fuji</h3>

<h2 id="skiing">Skiing</h2>

<h3 id="yuzawa-ski-resort">Yuzawa ski resort</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Explanation of ExaFMM Learning Codes.]]></title>
    <link href="http://v0dro.github.io/blog/2017/10/23/explanation-of-exafmm-learning-codes/"/>
    <updated>2017-10-23T21:33:24+09:00</updated>
    <id>http://v0dro.github.io/blog/2017/10/23/explanation-of-exafmm-learning-codes</id>
    <content type="html"><![CDATA[<p>In this file I will write descriptions of the exafmm ‘learning’ codes and my understanding of them. I have been tasked with understanding the code and porting it to Ruby, my favorite language.
We shall start from the first tutorial, i.e. <a href="">0_tree</a>. You can find the full Ruby code here.</p>

<!-- MarkdownTOC style="round" autolink="true" depth="4" -->

<ul>
  <li>0_tree
    <ul>
      <li>step1.cxx</li>
      <li>step2.cxx</li>
      <li>step3.cxx</li>
      <li>step04.cxx</li>
    </ul>
  </li>
  <li>1_traversal
    <ul>
      <li>step1.cxx</li>
      <li>step2.cxx</li>
    </ul>
  </li>
  <li>2_kernels
    <ul>
      <li>kernel.h</li>
      <li>vector.h</li>
      <li>exafmm.h</li>
      <li>exafmm2d.h and step1.cxx</li>
      <li>step2.cxx</li>
    </ul>
  </li>
</ul>

<!-- /MarkdownTOC -->

<h1 id="0_tree">0_tree</h1>

<h2 id="step1cxx">step1.cxx</h2>

<p>This program simply populates some bodies with random numbers, creates a hypothetical X and Y axes and figures out the quadrant of each of the bodies.</p>

<p>Each of the nodes of the tree have a maximum of <a href="">4 immediate children</a>. We first initialize 100 <code>struct Body</code> objects, and then set the X and Y co-ordinates of each of them to a random number between 0 and 1.</p>

<p>In order to actually build the tree we follow the following steps:</p>

<ul>
  <li>First <a href="">get the bounds</a> between which the random numbers lie. That is, we figure out the min and max random number that is present in the bodies.</li>
  <li>We then get a <a href="">‘center’ and a ‘radius’</a>. This is useful for creating ‘quadrants’ and partitioning points into different quandrants in later steps. The center is calculated by adding the min and max numbers (which we treat as the diameter) and dividing by 2. This step is necessary since there is no ‘square’ space that can be partitioned into multiple spaces like there was in the lecture series. The way of calculating the radius <code>r0</code> is a little peculiar. It does not use the distance formula, its main purpose is….</li>
  <li>And then simply count the bodies in each quadrant and display them.</li>
</ul>

<p>Ruby code:
The body is represented as the Ruby class <code>Body</code>:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre><span style="color:#080;font-weight:bold">class</span> <span style="color:#B06;font-weight:bold">Body</span>
  attr_reader <span style="color:#A60">:x</span>

  <span style="color:#080;font-weight:bold">def</span> <span style="color:#06B;font-weight:bold">initialize</span>
    <span style="color:#33B">@x</span> = [<span style="color:#60E">0.0</span>, <span style="color:#60E">0.0</span>]
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>There is an interesting way of knowing the quadrant in this code. It goes like this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>a = body.x[<span style="color:#00D">0</span>] &gt; x0[<span style="color:#00D">0</span>] ? <span style="color:#00D">1</span> : <span style="color:#00D">0</span>
b = body.x[<span style="color:#00D">1</span>] &gt; x0[<span style="color:#00D">1</span>] ? <span style="color:#00D">1</span> : <span style="color:#00D">0</span>
quadrant = a + (b &lt;&lt; <span style="color:#00D">1</span>)
</pre></td>
</tr></table>
</div>
<p>Above code basically plays with 0 and 1 and returns a number between 0 and 3 as the correct quadrant number.</p>

<h2 id="step2cxx">step2.cxx</h2>

<p>This code basically takes the bodies created in the previous step, counts the number of bodies in each quadrant and sorts them by quadrant.</p>

<p>The new steps introduced in this program can be summarized as follows:</p>
<ul>
  <li>Count the bodies in each quadrant and store the count in an array. The <code>size</code> array in case of the Ruby implementation.</li>
  <li>In the next step we successively add the number of elements in each quadrant so that it gives us the offset value at which elements from a new quadrant will start in the <code>bodies</code> Array (of course, after it is sorted).</li>
  <li>We then sort the bodies according to the quadrant that they belong to. Something peculiar that I notice about this part is that <code>counter[quadrant]</code> also gets incremented after each iteration for sorting. Why is this the case even though the counters have been set to the correct offsets previously?</li>
</ul>

<h2 id="step3cxx">step3.cxx</h2>

<p>This program introduces a new method called <code>buildTree</code>, inside of which we will actually build the tree. It removes some of the sorting logic from <code>main</code> and puts it inside <code>buildTree</code>. The <code>buildTree</code> function performs the following functions:</p>
<ul>
  <li>Most of the functions relating to sorting etc are same. Only difference is that there is in-place sorting of the <code>bodies</code> array and the <code>buffer</code> array does not store elements anymore.</li>
  <li>A new function introduced is that we re-calculate the center and the radius based on sorted co-ordinates. This is done because we want new center and radii for the children.</li>
  <li>The <code>buildTree</code> function is called recursively such that the quadrants are divided until a point is reached where the inner most quadrant in the hierarchy does not contain more than 4 elements.</li>
</ul>

<p>Implementation:</p>

<p>There is an interesting piece of code in the part for calculating new center and radius:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre> <span style="color:#777"># i is quadrant number</span>
center[d] = x0[d] + radius * (((i &amp; <span style="color:#00D">1</span> &lt;&lt; d) &gt;&gt; d) * <span style="color:#00D">2</span> - <span style="color:#00D">1</span>)
</pre></td>
</tr></table>
</div>

<p>In the above code, there is some bit shifting and interleaving taking place whose prime purpose is to split the quadrant number into X and Y dimension and then using this to calculate the center of the child cell.</p>

<p>Another piece of code is this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>counter = <span style="color:#036;font-weight:bold">Array</span>.new <span style="color:#00D">4</span>, start
<span style="color:#00D">1</span>.upto(<span style="color:#00D">3</span>) <span style="color:#080;font-weight:bold">do</span> |i|
  counter[i] = size[i-<span style="color:#00D">1</span>] + counter[i-<span style="color:#00D">1</span>]
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#777"># sort bodies and store them in buffer</span>
buffer = bodies.dup
start.upto(finish-<span style="color:#00D">1</span>) <span style="color:#080;font-weight:bold">do</span> |n|
  quadrant = quadrant_of x0, buffer[n]
  bodies[counter[quadrant]] = buffer[n]
  counter[quadrant] += <span style="color:#00D">1</span>
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>In the above code, the <code>counter</code> variable is first used to store offsets of the elements in different quadrants. In the next loop it is in fact a counter for that stores in the index of the body that is currently under consideration.</p>

<h2 id="step04cxx">step04.cxx</h2>

<p>In this step we use the code written in the previous steps and actually build the tree.
The tree is built recursively by splitting into quadrants and then assigning them to cells
based on the quadrant. The ‘tree’ is actually stored in an array.</p>

<p>The cells are stored in a C++ vector called <code>cells</code>.</p>

<p>In the <code>Cell</code> struct, I wonder why the body is stored as a pointer and not a variable.</p>

<p>Implementation in the Ruby code, like saving the size of an Array during a recursive call
is slightly different since Ruby does not support pointers, but the data structures and
overall code is more or less a direct port.</p>

<h1 id="1_traversal">1_traversal</h1>

<p>These codes are for traversal of the tree that was created in the previous step. The full code can be found in <a href="">1_traversal.rb</a> file.</p>

<h2 id="step1cxx-1">step1.cxx</h2>

<p>This step implements the P2M and M2M passes of the FMM.</p>

<p>One major difference between the C++ and Ruby implementation is that since Ruby does not have pointers, I
have used the array indices of the elements instead. For this purpose there are two attributes in the
<code>Cell</code> class called <code>first_child_index</code> that is responsible for holding the index in the <code>cells</code> array
about the location of the first child of this cell, and the second <code>first_body_index</code> which is responsible for holding the index of the body in the <code>bodies</code> array.</p>

<p>This step does this by introducing a method called <code>upwardPass</code> which iterates through nodes and thier children and computes the P2M and M2M kernels.</p>

<h2 id="step2cxx-1">step2.cxx</h2>

<p>This step implements the rest of the kernels i.e. M2L, L2L, L2P and P2P. It also introduces two new methods <code>downward_pass</code> that calculates the local forces from other local forces and L2P interactions and <code>horizontal_pass</code> that calculates the inter-particle interactions and m2l.</p>

<p>No special code as such over here, its just the regular FMM stuff.</p>

<h1 id="2_kernels">2_kernels</h1>

<p>This code is quite different from the previous two. While the previous programs were mostly retricted to a single file, this program substantially increases complexity and spreads the implementation across several files. We start using 3 dimensional co-ordinates too.</p>

<p>In this code, we start to make a move towards spherical co-ordinate system to represent the particles in 3D. A few notable algorithms taken from some research papers have been implemented in this code.</p>

<p>Lets describe each file and see what implementation lies inside</p>

<h2 id="kernelh">kernel.h</h2>

<p>The <code>kernel.h</code> header file implemenets all the FMM kernels. It also implements two special functions called <code>evalMultipole</code> and <code>evalLocal</code> that evaluate the multipoles and local expansion for spherical co-ordinates using the actual algorithm that is actually used in exafmm. An implementation of this algorithm can be found on page 16 of the paper <a href="https://arxiv.org/pdf/1010.1482.pdf%20">“Treecode and fast multipole method for N-body simulation with CUDA”</a> by Yokota sensei. A preliminary implementation of this algorithm can be found in <a href="http://www.sciencedirect.com/science/article/pii/S0021999199963556">“A Fast Adaptive Multipole Algorithm in Three Dimensions”</a> by Cheng.</p>

<p>The Ruby implementation of this file is in <code>kernel.rb</code>.</p>

<p>I will now describe this algorithm here best I can:</p>

<h3 id="preliminaries">Preliminaries</h3>

<h4 id="ynm-vector">Ynm vector</h4>

<p>This is a vector that defines the <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">spherical harmonics</a> of degree <em>n</em> and order <em>m</em>. A primitive version for computing this exists in the paper by Cheng and a newer, faster version in the paper by Yokota.</p>

<p>Spherical harmonics allow us to define series of a function in 3D rather in 1D that is usually the case for things like the expansion of <em>sin(x)</em>. They are representations of functions on the surface of a sphere instead of on a circle, which is usually the case with other 2D expansion functions. They are like the Fourier series of the sphere. This <a href="http://mathworld.wolfram.com/SphericalHarmonic.html">article</a> explains the notations used nicely.</p>

<p>The order (<em>n</em>) and degree (<em>m</em>) correspond to the order and degree of the <a href="http://mathworld.wolfram.com/LegendrePolynomial.html">Legendre polynomial</a> that is used for obtaining the spherical harmonic. <em>n</em> is an integer and <em>m</em> goes from <em>0..n</em>.</p>

<p>For causes of optimization, the values stored inside <code>ynm</code> are not the ones that correspond to the spherical harmonic, but are values that yield optimized results when the actual computation happens.</p>

<h4 id="historical-origins-of-kernelh">Historical origins of kernel.h</h4>

<p>This file is a new and improved version of the laplace.h file from the exafmm-alpha repo. Due to the enhacements made, the code in this file performs calculations that are significantly more accurate than those in laplace.h.</p>

<p>laplace.h consists of a C++ class inside which all the functions reside, along with a constructor that computes pre-determined values for subsequent computation of the kernels. For example, in the constructor of the <code>Kernel</code> class, there is a line like so:</p>
<div class="language-cpp highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>Anm[nm] = oddOrEven(n)/std::sqrt(fnmm*fnpm);
</pre></td>
</tr></table>
</div>
<p>This line is computing the value of <script type="math/tex">A^{m}_{n}</script> as is given by Cheng’s paper (equation 14). This value is used in M2L and L2L kernels later. However, this value is never directly computed in the new and optimized <code>kernel.h</code> file. Instead, it modifies the computation of the <code>Ynm</code> vector such that it no longer becomes necessary to involve the <code>Anm</code> term in any kernel computation.</p>

<h3 id="functions">Functions</h3>

<h4 id="cart2sph">cart2sph</h4>

<p>This function converts cartesian co-ordinates in (X,Y,Z) to spherical co-ordinates involving <code>radius</code>, <code>theta</code> and <code>phi</code>. <code>radius</code> is simply the square root of the norm of the co-ordinates (norm is defined as the sum of squares of the co-ordinates in <code>vec.h</code>).</p>

<h4 id="evalmultipole-simple-implementation">evalMultipole simple implementation</h4>

<p>This algorithm calculates the multipole of a cell. It uses spherical harmonics so that net force of the forces inside a sphere and can be estimated on the surface of the sphere, which can then be treated as a single body for estimating forces.</p>

<p>The optimizations that are presented in the <code>kernel.h</code> version of this file are quite complex to understand since they look quite different from the original equation.</p>

<p>For code that is still sane and easier to read, head over to the <a href="https://github.com/exafmm/exafmm-alpha/blob/develop/kernels/laplace.h#L48">laplace.h</a> file in exafmm-alpha. The explanations that follow for now are from this file. We will see how the same functions in <code>kernel.h</code> have been modified to make computation faster and less dependent on large number divisions which reduce the accuracy of the system.</p>

<p>The <code>evalMultipole</code> function basically tries to populate the <code>Ynm</code> array with data that is computed with the following equation:</p>

<script type="math/tex; mode=display">\rho^{n}Y_{n}^{m}=\sum_{m=0}^{P-1}\sum_{n=m+1}^{P-1}\rho^{n}P_{n}^{m}(x)\sqrt{\frac{(n-m)!}{(n+m)!}}e^{im\beta}</script>

<p>It starts with evaluating terms that need not be computed for every iteration of <code>n</code>, and computes those terms in the outer loop itself. The terms in the outer loop correspond to the condition <code>m=n</code>. The first of these is the exponential term <script type="math/tex">e^{im\beta}</script>.</p>

<p>After this is a curious case of computation of some indexes called <code>npn</code> and <code>nmn</code>. These are computed as follows:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>npn = m * m + <span style="color:#00D">2</span> * m <span style="color:#777"># case Y n  n</span>
nmn = m * m         <span style="color:#777"># case Y n -n</span>
</pre></td>
</tr></table>
</div>

<p>The corresponding index calculation for the inner loop is like this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>npm = n * n + n + m <span style="color:#777"># case Y n  m</span>
nmm = n * n + n - m <span style="color:#777"># case Y n -m</span>
</pre></td>
</tr></table>
</div>

<p>This indexes the <code>Ynm</code> array. This is done because we are visualizing the Ynm array as a pyramid whose base spans from <code>-m</code> to <code>m</code> and who height is <code>n</code>. A rough visualization of this pyramid would be like so:</p>
<pre><code>   -m ---------- m
n  10 11 12 13  14
|    6  7  8  9
|     3  4   5  
|      1   2
V        0
</code></pre>

<p>The above formulas will give the indexes for each half of the pyramid. Since the values of one half of the pyramid are conjugates of the other half, we can only iterate from <code>m=0</code> to <code>m&lt;P</code> and use this indexing method for gaining the index of the other half of the pyramid.</p>

<p>Now let us talk about the evaluation of the <a href="http://mathworld.wolfram.com/AssociatedLegendrePolynomial.html">Associated Legendre Polynomial</a> <script type="math/tex">P^m_{n}(cos(\theta))</script>, where <em>m</em> is the order of the differential equation and <em>n</em> is the degree. The Associated Legendre Polynomial is the solution to the <a href="http://mathworld.wolfram.com/AssociatedLegendreDifferentialEquation.html">Associated Legendre Equation</a>. The Legendre polynomial can be expressed in terms of the <a href="https://en.wikipedia.org/wiki/Associated_Legendre_polynomials#Definition_for_non-negative_integer_parameters_.E2.84.93_and_m">Rodrigues form</a> for computation without dependence on the simple Legendre Polynomial <script type="math/tex">P_{n}</script>. However, due to the factorials and rather large divisions that need to be performed to compute the Associated Legendre polynomial in this form, computing this equation for large values of <em>m</em> and <em>n</em> quickly becomes unstable. Therefore, we use a recurrence relation of the Polynomial in order to compute different values.</p>

<p>The recurrence relation looks like so:</p>

<script type="math/tex; mode=display">(n-m+1)P^m_{n+1}(x)=x(2n+1)P^m_n(x)-(n+m)P^m_{n-1}(x)</script>

<p>This is expressed in the code with the following line:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>p = (x * (<span style="color:#00D">2</span> * n + <span style="color:#00D">1</span>) * p1 - (n + m) * p2) / (n - m + <span style="color:#00D">1</span>)
</pre></td>
</tr></table>
</div>
<p>It can be seen that <code>p</code> is equivalent to <script type="math/tex">P^{m}_{n+1}</script>, <code>p1</code> is equivalent to <script type="math/tex">P^{m}_{n}</script> and <code>p2</code> is equivalent to <script type="math/tex">P^{m}_{n-1}</script>. This convention is followed everywhere in the code.</p>

<p>Observe that the above equation requires the value of <em>P</em> for <em>n-1</em> and <em>n+1</em> to be computed so that the value for <em>P</em> at <em>n</em> can be computed. Therefore, we first set <em>m=m+1</em> and then compute <script type="math/tex">P^m_{m+1}</script> which can be expressed like this:
<script type="math/tex">P^{m}_{m+1}(x)=x(2m+1)P^{m}_{m}(x)</script></p>

<p>The above equation is expressed by the following line in the code:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>p = x * (<span style="color:#00D">2</span> * m + <span style="color:#00D">1</span>) * p1
</pre></td>
</tr></table>
</div>

<p>If you read the code closely, you will see that just at the beginning of the <code>evalMultipole</code> function, we initialize <code>p1 = 1</code> the first time the looping is done. This is because when <code>p1</code> at the first instance is identified with <code>m = 0</code>, and we substitute <code>m=0</code> in this equation:</p>

<script type="math/tex; mode=display">P^{m}_{m} = (-1)^{m}(2m-1)!(1-x^{2})^{\frac{m}{2}}</script>

<p>We will get <script type="math/tex">P^{m}_{m}(x)=1</script>.</p>

<p>When you look at the code initially, there might be some confusion regarding the significance of having to <code>rho</code> terms, <code>rhom</code> and <code>rhon</code>. This is written because each term of <code>Ynm</code> depends on a particular power of <code>rho</code> raised to <code>n</code>. So just before the inner loop, you can see the line <code>rhon = rhom</code>, which basically reduces the number of times that <code>rho</code> needs to be multiplied since the outer loop’s value of <code>rho</code> is already set to what it should be for that particular iteration.</p>

<p>Finally, see that there is a line right after the inner loop which reads like this:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>pn = -pn * fact * y
</pre></td>
</tr></table>
</div>
<p>This line is for calculating the value of <code>p1</code> or <script type="math/tex">P^{m}_{m}</script> after the first iteration of the loop. Since the second factorial term in the equation basically just deals with odd numbers, the calculation of this term can be simplified by simply incrementing by <code>2</code> with <code>fact += 2</code>. The <code>y</code> term in the above equation is in fact <code>sin(alpha)</code> (defined at the top of this function). This is because, if you see the original equation, you will see that the third term is <script type="math/tex">(1-x^{2})</script>, and <em>x</em> is in fact <code>cos(alpha)</code>. Therefore, using the trigonometric equation, we can say simply substitute the entire term with <code>y</code>.</p>

<h4 id="evalmultipole-optimized-implementation">evalMultipole optimized implementation</h4>

<p>Now that a background of the basic implementation of <code>evalMultipole</code> has been established, we can move over to understanding the code that is placed inside the <a href="https://github.com/exafmm/exafmm/blob/learning/2_kernels/kernel.h">kernel.h</a> file of the <code>exafmm/learning</code> branch. This code is more optimized and can compute results with much higher accuracy than the code that is present in the <code>exafmm-alpha</code> repo that we previously saw. The main insipiration for this code come’s from the Treecode paper posted above.</p>

<p>In this code, most of the stuff relating to indexing and calculation of the powers of <code>rho</code> is pretty much the same. However, there are some important changes with regards to the computation of the values that go inside the <code>Ynm</code> array. This change is also reflected in the subsequent kernels.</p>

<p>The simplication in computation is basically based on the notion that a P2M kernel will eventually be expanded to M2M and therefore it makes sense to compute some terms that are required for M2M inside P2M itself. In order to see how exactly this will work, consider the line in laplace.h that is used for computing the M2M:</p>
<pre><code>M += Cj-&gt;M[jnkms] * std::pow(I,real_t(m-abs(m))) * Ynm[nm] * real_t(oddOrEven(n) * Anm[nm] * Anm[jnkm] / Anm[jk]);
</code></pre>
<p>The above line computes the M2M as given by eq.13 in <a href="https://ac.els-cdn.com/S0021999199963556/1-s2.0-S0021999199963556-main.pdf?_tid=262a8f4c-d58d-11e7-82f6-00000aacb360&amp;acdnat=1512018967_7cd88d8da2a5a747344fe9c0619e5563">Cheng’s paper</a>. Now, division and multiplication of such large numbers makes the M2M calculation very unstable if the order and/or degree of the equations is large. Therefore, the new <code>evalMultipole</code> simplifies this computation by computing some terms in the P2M stage itself.</p>

<p>In order to understand this, let us see the equation given by Cheng. Let us call this equation <code>1</code>:</p>

<script type="math/tex; mode=display">M^{k}_{j}=\sum_{n=0}^{j}\sum_{m=-n}^{m=n} \frac{O_{j-n}^{k-m}\cdot i^{|k-m|-|k|-|m|}\cdot A^{m}_{n}\cdot A^{k-m}_{j-n}\cdot \rho^{n}\cdot Y^{-m}_{n}(\alpha,\beta)}{A_{j}^{k}}</script>

<p>In the new M2M kernel, the <em>A</em> terms are clubbed together with other terms such that no actual division or multiplication involving these terms takes place the way it does in the laplace.h code. In this regard, we club together <script type="math/tex">O^{k-m}_{j-n}</script> and <script type="math/tex">A^{k-m}_{j-n}</script>. You will notice that <em>O</em> is the actually the multipole that is computed in the P2M stage (the <code>Cj-&gt;M[jnkms]</code> term in the code sample above). Therefore, the actual equation of the P2M kernel using the new evalMultipole method becomes like this:</p>

<script type="math/tex; mode=display">M^{m}_{n}=\sum^{P-1}_{n=0}\sum^{n}_{m=-n} q_{j}\cdot \rho^{n} \cdot Y^{-m}_{n}(\alpha, \beta)\cdot A^{m}_{n}</script>

<p>The <script type="math/tex">A^{m}_{n}</script> part in eq. (1) will be clubbed with the spherical harmonic <em>Y</em> and will be calculated inside the <code>evalMultipole</code> method for every particle in case of P2M and every multipole in case of M2M. Thus since the P2M and M2M have similar behaviour (i.e. grouping of many particles to lesser particles) we can use the same function for both.</p>

<p>In retrospect, inside the evalMultipole method, the part of the above P2M equation after the <em>q</em> is calculated. This equation, upon expansion of spherical harmonics into its consitituents and cancellation of terms with <script type="math/tex">A^{m}_{n}</script>, can be simplified as the following equation. Note that the computed value of this equation is what gets stored inside the <code>Ynm</code> array.</p>

<script type="math/tex; mode=display">array^{n}_{m}=\sum^{P-1}_{m=0}\sum^{P-1}_{n=m+1} \frac{\rho^{n} \cdot P^{n}_{m}(x) \cdot e^{im\beta}}{-(n+m)!}</script>

<p>The implementation of this equation inside evalMultipole is a little funny. It has been optimized in such a way that the division operations never happen between numbers that are too big. The factorials are calculated on the fly while the loop is in progress. This can get a little confusing at first since it is not very obvious. The factorial is mainly calculated in two lines of code, <a href="https://github.com/exafmm/exafmm/blob/learning/2_kernels/kernel.h#L56">here</a> and <a href="https://github.com/exafmm/exafmm/blob/learning/2_kernels/kernel.h#L65">here</a>.</p>

<p>The first line of code reads <code>rhon /= -(n + m)</code>. The origin of this is obvious as can be seen from the above equation that is being calculated inside evalMultipole. The division happens after each iteration and there is no stored factorial that is used the way it was in <code>laplace.h</code> for reducing the number that needs to be used in the division.</p>

<p>The second line of code reads like <code>rhom /= -(2 * m + 2) * (2 * m + 1)</code>. In this case, notice that the LHS has the variable <code>rhom</code>. This variable is used only in the outer loop for computation of Ynm (i.e. the case of <code>n=m</code>). In order to explain this, consider that the inner loop starts from <code>n=m+1</code> and can be rewritten as <code>rhon /= -(2*m+1)</code> (at least for the first iteration). When the Ynm value needs to be calculated for the outer loop, we must have the current value of <code>m</code> and the value for the next iteration in the <code>rhom</code>, therefore we use <code>2*m+2</code> as well.</p>

<p>To understand in somewhat more detail, see the following Ruby code that recreates the values of the above indices:</p>
<div class="language-ruby highlighter-coderay"><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
</pre></td>
  <td class="code"><pre><span style="color:#036;font-weight:bold">P</span> = <span style="color:#00D">5</span>
m = <span style="color:#00D">0</span>
n = m+<span style="color:#00D">1</span>

prod1 = <span style="color:#00D">1</span>
<span style="color:#00D">0</span>.upto(<span style="color:#036;font-weight:bold">P</span>-<span style="color:#00D">1</span>) <span style="color:#080;font-weight:bold">do</span> |m|
  prod = prod1
  (m+<span style="color:#00D">1</span>).upto(<span style="color:#036;font-weight:bold">P</span>-<span style="color:#00D">1</span>) <span style="color:#080;font-weight:bold">do</span> |n|
    puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">m: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>m<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> n: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>n<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> 2m+1: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>m+n<span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
    prod *= (m + n)
  <span style="color:#080;font-weight:bold">end</span>
  prod1 *= (<span style="color:#00D">2</span>*m + <span style="color:#00D">1</span>)*(<span style="color:#00D">2</span>*m + <span style="color:#00D">2</span>)
  puts <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">P1: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span>prod1<span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> 2m+1: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span><span style="color:#00D">2</span>*m+<span style="color:#00D">1</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#D20"> 2m+2: </span><span style="background-color:hsla(0,0%,0%,0.07);color:black"><span style="font-weight:bold;color:#666">#{</span><span style="color:#00D">2</span>*m+<span style="color:#00D">2</span><span style="font-weight:bold;color:#666">}</span></span><span style="color:#710">&quot;</span></span>
<span style="color:#080;font-weight:bold">end</span>
</pre></td>
</tr></table>
</div>

<p>The above code produces the follwoing output:</p>
<pre><code>m: 0 n: 1 2m+1: 1
P: 1
m: 0 n: 2 2m+1: 2
P: 2
m: 0 n: 3 2m+1: 3
P: 6
m: 0 n: 4 2m+1: 4
P: 24
P1: 2 2m+1: 1 2m+2: 2
m: 1 n: 2 2m+1: 3
P: 6
m: 1 n: 3 2m+1: 4
P: 24
m: 1 n: 4 2m+1: 5
P: 120
P1: 24 2m+1: 3 2m+2: 4
m: 2 n: 3 2m+1: 5
P: 120
m: 2 n: 4 2m+1: 6
P: 720
P1: 720 2m+1: 5 2m+2: 6
m: 3 n: 4 2m+1: 7
P: 5040
P1: 40320 2m+1: 7 2m+2: 8
P1: 3628800 2m+1: 9 2m+2: 10
</code></pre>
<p>If you observe the output of code, you can see that the indices being calculated during P1 phase are exactly one greater than the previous phase, which indicates that the factorial value is being calculated properly, incrementally.</p>

<h2 id="vectorh">vector.h</h2>

<p>This file defines a new custom type for storing 1D vectors called <code>vec</code> as a  C++ class. It also defines various functions that can be used on vectors like <code>norm</code>, <code>exp</code> and other simple arithmetic.</p>

<p>The Ruby implementation of this file is in <code>vector.rb</code>.</p>

<h2 id="exafmmh">exafmm.h</h2>

<h2 id="exafmm2dh-and-step1cxx">exafmm2d.h and step1.cxx</h2>

<p>Shows a very simple preliminary implementation of the actuall exafmm code. Mostly useful for understanding purpose only.</p>

<h2 id="step2cxx-2">step2.cxx</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GSOC 2016 Wrap Up for SciRuby]]></title>
    <link href="http://v0dro.github.io/blog/2016/11/24/gsoc-2016-wrap-up-for-sciruby/"/>
    <updated>2016-11-24T13:27:34+09:00</updated>
    <id>http://v0dro.github.io/blog/2016/11/24/gsoc-2016-wrap-up-for-sciruby</id>
    <content type="html"><![CDATA[<p>In the summer of 2016 I was chosen by the SciRuby core team to be admin for SciRuby for Google Summer of Code 2016. GSOC is an important yearly event for us as an organization since it provides a great platform for an upcoming organization like SciRuby and helps us get more users and contributors for the various libraries that we maintain.</p>

<p>This blog post is meant to be a summary of the work that SciRuby did over the summer and also of my experience at the GSOC 2016 mentor’s summit.</p>

<h2 id="gsoc-student-work">GSOC student work</h2>

<p>For the 2016 edition of GSOC we had 4 students - <a href="https://github.com/lokeshh">Lokesh Sharma</a>, <a href="https://github.com/prasunanand">Prasun Anand</a>, <a href="https://github.com/gau27">Gaurav Tamba</a> and <a href="https://github.com/rajithv">Rajith Vidanaarachchi</a>. All four were undergraduate computer engineering students from colleges in India or Sri Lanka at the time of GSOC 2016.</p>

<p>Lokesh worked on making improvements to <a href="https://github.com/sciruby/daru">daru</a>, a Ruby DataFrame library. He made very significant contributions to daru by adding functionality for storing and performing operations on categorical data, and also significantly sped up the sorting and grouping functionality of daru. His work has now been successfully integrated into the main branch and has also been released on rubygems. Lokesh has remained active as a daru contributor and regularly contributes code and replies to Pull Requests and issues. You can find a wrap up of the work he did throughout the summer in <a href="http://sciruby.com/blog/2016/11/24/gsoc-2016-adding-categorical-data-support/">this blog post</a>.</p>

<p>Prasun worked on creating a Java backend for <a href="https://github.com/sciruby/nmatrix">NMatrix</a>, a Ruby library for performing linear algebra operations similar to numpy in Python. This project opened the doors for scientific computation on JRuby. Prasun was able to complete all his project objectives, and his work is currently awaiting review because of the <a href="https://github.com/SciRuby/nmatrix/pull/558">sheer size of the Pull Request</a> and the variety of changes to the library that he had to make in order to accomplish his project goals. You can read about his summer’s work <a href="http://sciruby.com/blog/2016/10/24/gsoc-2016-port-nmatrix-to-jruby/">here</a>. Prasun will also be <a href="http://rubyconfindia.org/program/#prasun-anand">speaking at Ruby Conf India 2017</a> about his GSOC work and scientific computing on JRuby in general.</p>

<p>Gaurav worked on creating a Ruby wrapper for NASA’s <a href="https://naif.jpl.nasa.gov/naif/toolkit.html">SPICE toolkit</a>. A need for this was felt since Gaurav’s mentor John is a rocket scientist and was keen having a Ruby wrapper for a library that he used regularly in his work. This resulted in the <a href="https://github.com/SciRuby/spice_rub">spice_rub</a> gem. It exposes a very intuitive Ruby interface to the SPICE toolkit. Gaurav also gave a lightning talk about his work at <a href="">Deccan Ruby Conf (Pune, India)</a>. Blog posts summarizing his work can be found <a href="http://sciruby.com/blog/2016/11/24/spicerub-kernelpool-and-kernels/">here</a>, <a href="http://sciruby.com/blog/2016/11/24/gsoc-2016-a-look-at-spicerub-body/">here</a> and <a href="http://sciruby.com/blog/2016/11/24/gsoc-2016-a-look-at-spicerub-time/">here</a>.</p>

<p>Rajith worked on growing the Ruby wrapper over <a href="https://github.com/symengine/symengine">symengine</a>. His mentor Abinash was a student with SciRuby for GSOC 2015 and volunteered to mentor Rajith so that Rajith could build upon the work that he had done the previous summer. This resulted in a huge increase in functionality for the <a href="https://github.com/symengine/symengine.rb">symengine.rb ruby gem</a>.</p>

<p>To summarize, all four of our students could execute their chosen tasks within the stipulated time and we did not have to fail anyone. All in all, we mentors had a great time working with the students and hope to keep doing this year on year!</p>

<h2 id="gsoc-2016-mentors-summit">GSOC 2016 mentor’s summit</h2>

<p>The GSOC 2016 mentor’s summit was fantastic. It was great meeting all the contributors and listening to ideas from projects that I had never heard about previously. I also had the opportunity to conduct an unconference session and  share my ideas on Scientific Computation in Ruby with like minded people from other organizations.</p>

<p>Here are some photos that I took at the summit:</p>

<p><img src="http://v0dro.github.io/images/gsoc_summit/1.JPG" alt="'ID card'" /></p>

<p><img src="http://v0dro.github.io/images/gsoc_summit/2.JPG" alt="'A visit to the Computer History Museum'" /></p>

<p><img src="http://v0dro.github.io/images/gsoc_summit/3.JPG" alt="'The (now discontinued) self driving car'" /></p>

<p><img src="http://v0dro.github.io/images/gsoc_summit/4.JPG" alt="'Chocolate table at the GSOC summit'" /></p>

<p><img src="http://v0dro.github.io/images/gsoc_summit/5.JPG" alt="'Attendees from India'" /></p>
]]></content>
  </entry>
  
</feed>
